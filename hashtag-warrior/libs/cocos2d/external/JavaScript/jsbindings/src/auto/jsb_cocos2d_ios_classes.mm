/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c cocos2d_jsb.ini" on 2013-06-17
* Script version: v0.6
*/
#import "jsb_config.h"
#if JSB_INCLUDE_COCOS2D_IOS

#import "jsb_cocos2d_classes.h"

// needed for callbacks from objective-c to JS
#import <objc/runtime.h>
#import "JRSwizzle.h"

#import "jsfriendapi.h"
#import "jsb_config.h"
#import "jsb_core.h"

#import "jsb_cocos2d_ios_classes.h"


/*
 * CCDirector
 */
#pragma mark - CCDirector

JSClass* JSB_CCDirector_class = NULL;
JSObject* JSB_CCDirector_object = NULL;
// Constructor
JSBool JSB_CCDirector_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDirector createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDirector_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDirector)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDirector_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDirector *proxy = [[JSB_CCDirector alloc] initWithJSObject:obj class:[CCDirector class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionManager* (o)
JSBool JSB_CCDirector_actionManager(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionManager* ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real actionManager ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSTimeInterval (d)
JSBool JSB_CCDirector_animationInterval(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSTimeInterval ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real animationInterval ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGFloat (d)
JSBool JSB_CCDirector_contentScaleFactor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGFloat ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real contentScaleFactor ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCDirector_convertToGL_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real convertToGL:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCDirector_convertToUI_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real convertToUI:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: UITouch*
// Ret value: CGPoint (N/A)
JSBool JSB_CCDirector_convertTouchToGL_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real convertTouchToGL:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_createStatsLabel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real createStatsLabel ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCDirector_delegate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real delegate ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCDirector_displayStats(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real displayStats ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_drawScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real drawScene ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: BOOL (b)
JSBool JSB_CCDirector_enableRetinaDisplay_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real enableRetinaDisplay:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_end(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real end ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCDirector_getZEye(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real getZEye ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCDirector_isAnimating(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real isAnimating ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCDirector_isPaused(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real isPaused ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCDirector_nextDeltaTimeZero(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real nextDeltaTimeZero ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCDirector_notificationNode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real notificationNode ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_pause(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real pause ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_popScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real popScene ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_popToRootScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real popToRootScene ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCDirector_popToSceneStackLevel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real popToSceneStackLevel:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccDirectorProjection (i)
JSBool JSB_CCDirector_projection(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccDirectorProjection ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real projection ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_purgeCachedData(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real purgeCachedData ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCScene*
// Ret value: void (None)
JSBool JSB_CCDirector_pushScene_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real pushScene:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCScene*
// Ret value: void (None)
JSBool JSB_CCDirector_replaceScene_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real replaceScene:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCDirector_reshapeProjection_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real reshapeProjection:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_resume(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real resume ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCScene*
// Ret value: void (None)
JSBool JSB_CCDirector_runWithScene_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real runWithScene:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScene* (o)
JSBool JSB_CCDirector_runningScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCScene* ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real runningScene ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScheduler* (o)
JSBool JSB_CCDirector_scheduler(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCScheduler* ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real scheduler ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSB_CCDirector_secondsPerFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTime ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real secondsPerFrame ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCDirector_sendCleanupToScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real sendCleanupToScene ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCActionManager*
// Ret value: void (None)
JSBool JSB_CCDirector_setActionManager_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setActionManager:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCDirector_setAlphaBlending_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setAlphaBlending:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSTimeInterval
// Ret value: void (None)
JSBool JSB_CCDirector_setAnimationInterval_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setAnimationInterval:(NSTimeInterval)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGFloat
// Ret value: void (None)
JSBool JSB_CCDirector_setContentScaleFactor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setContentScaleFactor:(CGFloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCDirector_setDelegate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setDelegate:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCDirector_setDepthTest_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setDepthTest:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCDirector_setDisplayStats_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setDisplayStats:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_setGLDefaultValues(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setGLDefaultValues ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCDirector_setNextDeltaTimeZero_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setNextDeltaTimeZero:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCDirector_setNotificationNode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setNotificationNode:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccDirectorProjection
// Ret value: void (None)
JSBool JSB_CCDirector_setProjection_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setProjection:(ccDirectorProjection)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCScheduler*
// Ret value: void (None)
JSBool JSB_CCDirector_setScheduler_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setScheduler:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_setViewport(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real setViewport ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDirector* (o)
JSBool JSB_CCDirector_sharedDirector_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCDirector* ret_val;

	ret_val = [CCDirector sharedDirector ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_startAnimation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real startAnimation ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirector_stopAnimation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirector *real = (CCDirector*) [proxy realObj];
	[real stopAnimation ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCDirector_totalFrames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real totalFrames ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCDirector_winSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real winSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCDirector_winSizeInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCDirector *real = (CCDirector*) [proxy realObj];
	ret_val = [real winSizeInPixels ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

void JSB_CCDirector_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDirector_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDirector_class->name = name;
	JSB_CCDirector_class->addProperty = JS_PropertyStub;
	JSB_CCDirector_class->delProperty = JS_PropertyStub;
	JSB_CCDirector_class->getProperty = JS_PropertyStub;
	JSB_CCDirector_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDirector_class->enumerate = JS_EnumerateStub;
	JSB_CCDirector_class->resolve = JS_ResolveStub;
	JSB_CCDirector_class->convert = JS_ConvertStub;
	JSB_CCDirector_class->finalize = JSB_CCDirector_finalize;
	JSB_CCDirector_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActionManager", JSB_CCDirector_actionManager, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnimationInterval", JSB_CCDirector_animationInterval, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("contentScaleFactor", JSB_CCDirector_contentScaleFactor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToGL", JSB_CCDirector_convertToGL_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToUI", JSB_CCDirector_convertToUI_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertTouchToGL", JSB_CCDirector_convertTouchToGL_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createStatsLabel", JSB_CCDirector_createStatsLabel, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDelegate", JSB_CCDirector_delegate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayStats", JSB_CCDirector_displayStats, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawScene", JSB_CCDirector_drawScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableRetinaDisplay", JSB_CCDirector_enableRetinaDisplay_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("end", JSB_CCDirector_end, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getZEye", JSB_CCDirector_getZEye, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsAnimating", JSB_CCDirector_isAnimating, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isPaused", JSB_CCDirector_isPaused, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNextDeltaTimeZero", JSB_CCDirector_nextDeltaTimeZero, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNotificationNode", JSB_CCDirector_notificationNode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pause", JSB_CCDirector_pause, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("popScene", JSB_CCDirector_popScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("popToRootScene", JSB_CCDirector_popToRootScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("popToSceneStackLevel", JSB_CCDirector_popToSceneStackLevel_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProjection", JSB_CCDirector_projection, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("purgeCachedData", JSB_CCDirector_purgeCachedData, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pushScene", JSB_CCDirector_pushScene_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("replaceScene", JSB_CCDirector_replaceScene_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reshapeProjection", JSB_CCDirector_reshapeProjection_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resume", JSB_CCDirector_resume, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("runWithScene", JSB_CCDirector_runWithScene_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRunningScene", JSB_CCDirector_runningScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getScheduler", JSB_CCDirector_scheduler, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSecondsPerFrame", JSB_CCDirector_secondsPerFrame, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSendCleanupToScene", JSB_CCDirector_sendCleanupToScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setActionManager", JSB_CCDirector_setActionManager_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAlphaBlending", JSB_CCDirector_setAlphaBlending_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnimationInterval", JSB_CCDirector_setAnimationInterval_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setContentScaleFactor", JSB_CCDirector_setContentScaleFactor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDelegate", JSB_CCDirector_setDelegate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDepthTest", JSB_CCDirector_setDepthTest_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisplayStats", JSB_CCDirector_setDisplayStats_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGLDefaultValues", JSB_CCDirector_setGLDefaultValues, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setNextDeltaTimeZero", JSB_CCDirector_setNextDeltaTimeZero_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setNotificationNode", JSB_CCDirector_setNotificationNode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProjection", JSB_CCDirector_setProjection_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setScheduler", JSB_CCDirector_setScheduler_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setViewport", JSB_CCDirector_setViewport, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("startAnimation", JSB_CCDirector_startAnimation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stopAnimation", JSB_CCDirector_stopAnimation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTotalFrames", JSB_CCDirector_totalFrames, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getWinSize", JSB_CCDirector_winSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("winSizeInPixels", JSB_CCDirector_winSizeInPixels, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDirector_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("getInstance", JSB_CCDirector_sharedDirector_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDirector_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCDirector_class, JSB_CCDirector_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDirector

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDirector_class, JSB_CCDirector_object, NULL);
	JSB_CCDirector *proxy = [[JSB_CCDirector alloc] initWithJSObject:jsobj class:[CCDirector class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDirectorIOS
 */
#pragma mark - CCDirectorIOS

JSClass* JSB_CCDirectorIOS_class = NULL;
JSObject* JSB_CCDirectorIOS_object = NULL;
// Constructor
JSBool JSB_CCDirectorIOS_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDirectorIOS createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDirectorIOS_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDirectorIOS)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDirectorIOS_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDirectorIOS *proxy = [[JSB_CCDirectorIOS alloc] initWithJSObject:obj class:[CCDirectorIOS class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDirectorIOS_drawScene(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDirectorIOS *real = (CCDirectorIOS*) [proxy realObj];
	[real drawScene ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDirector* (o)
JSBool JSB_CCDirectorIOS_sharedDirector_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCDirector* ret_val;

	ret_val = [CCDirectorIOS sharedDirector ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCDirectorIOS_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDirectorIOS_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDirectorIOS_class->name = name;
	JSB_CCDirectorIOS_class->addProperty = JS_PropertyStub;
	JSB_CCDirectorIOS_class->delProperty = JS_PropertyStub;
	JSB_CCDirectorIOS_class->getProperty = JS_PropertyStub;
	JSB_CCDirectorIOS_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDirectorIOS_class->enumerate = JS_EnumerateStub;
	JSB_CCDirectorIOS_class->resolve = JS_ResolveStub;
	JSB_CCDirectorIOS_class->convert = JS_ConvertStub;
	JSB_CCDirectorIOS_class->finalize = JSB_CCDirectorIOS_finalize;
	JSB_CCDirectorIOS_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("drawScene", JSB_CCDirectorIOS_drawScene, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDirectorIOS_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedDirector", JSB_CCDirectorIOS_sharedDirector_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDirectorIOS_object = JS_InitClass(cx, globalObj, JSB_CCDirector_object, JSB_CCDirectorIOS_class, JSB_CCDirectorIOS_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDirectorIOS

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDirectorIOS_class, JSB_CCDirectorIOS_object, NULL);
	JSB_CCDirectorIOS *proxy = [[JSB_CCDirectorIOS alloc] initWithJSObject:jsobj class:[CCDirectorIOS class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDirectorDisplayLink
 */
#pragma mark - CCDirectorDisplayLink

JSClass* JSB_CCDirectorDisplayLink_class = NULL;
JSObject* JSB_CCDirectorDisplayLink_object = NULL;
// Constructor
JSBool JSB_CCDirectorDisplayLink_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDirectorDisplayLink createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDirectorDisplayLink_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDirectorDisplayLink)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDirectorDisplayLink_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDirectorDisplayLink *proxy = [[JSB_CCDirectorDisplayLink alloc] initWithJSObject:obj class:[CCDirectorDisplayLink class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCDirectorDisplayLink_mainLoop_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDirectorDisplayLink *real = (CCDirectorDisplayLink*) [proxy realObj];
	[real mainLoop:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDirector* (o)
JSBool JSB_CCDirectorDisplayLink_sharedDirector_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCDirector* ret_val;

	ret_val = [CCDirectorDisplayLink sharedDirector ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCDirectorDisplayLink_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDirectorDisplayLink_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDirectorDisplayLink_class->name = name;
	JSB_CCDirectorDisplayLink_class->addProperty = JS_PropertyStub;
	JSB_CCDirectorDisplayLink_class->delProperty = JS_PropertyStub;
	JSB_CCDirectorDisplayLink_class->getProperty = JS_PropertyStub;
	JSB_CCDirectorDisplayLink_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDirectorDisplayLink_class->enumerate = JS_EnumerateStub;
	JSB_CCDirectorDisplayLink_class->resolve = JS_ResolveStub;
	JSB_CCDirectorDisplayLink_class->convert = JS_ConvertStub;
	JSB_CCDirectorDisplayLink_class->finalize = JSB_CCDirectorDisplayLink_finalize;
	JSB_CCDirectorDisplayLink_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("mainLoop", JSB_CCDirectorDisplayLink_mainLoop_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDirectorDisplayLink_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedDirector", JSB_CCDirectorDisplayLink_sharedDirector_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDirectorDisplayLink_object = JS_InitClass(cx, globalObj, JSB_CCDirectorIOS_object, JSB_CCDirectorDisplayLink_class, JSB_CCDirectorDisplayLink_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDirectorDisplayLink

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDirectorDisplayLink_class, JSB_CCDirectorDisplayLink_object, NULL);
	JSB_CCDirectorDisplayLink *proxy = [[JSB_CCDirectorDisplayLink alloc] initWithJSObject:jsobj class:[CCDirectorDisplayLink class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLayer
 */
#pragma mark - CCLayer

JSClass* JSB_CCLayer_class = NULL;
JSObject* JSB_CCLayer_object = NULL;
// Constructor
JSBool JSB_CCLayer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLayer createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLayer_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLayer)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLayer_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLayer *proxy = [[JSB_CCLayer alloc] initWithJSObject:obj class:[CCLayer class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayer_isAccelerometerEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayer *real = (CCLayer*) [proxy realObj];
	ret_val = [real isAccelerometerEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayer_isTouchEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayer *real = (CCLayer*) [proxy realObj];
	ret_val = [real isTouchEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayer_setAccelerometerEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setAccelerometerEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLayer_setAccelerometerInterval_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setAccelerometerInterval:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayer_setTouchEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setTouchEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTouchesMode
// Ret value: void (None)
JSBool JSB_CCLayer_setTouchMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setTouchMode:(ccTouchesMode)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCLayer_setTouchPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setTouchPriority:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayer_setTouchSwallow_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayer *real = (CCLayer*) [proxy realObj];
	[real setTouchSwallow:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTouchesMode (i)
JSBool JSB_CCLayer_touchMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTouchesMode ret_val;

	CCLayer *real = (CCLayer*) [proxy realObj];
	ret_val = [real touchMode ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCLayer_touchPriority(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCLayer *real = (CCLayer*) [proxy realObj];
	ret_val = [real touchPriority ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayer_touchSwallow(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayer *real = (CCLayer*) [proxy realObj];
	ret_val = [real touchSwallow ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLayer* (o)
JSBool JSB_CCLayer_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCLayer* ret_val;

	ret_val = [CCLayer node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCLayer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLayer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLayer_class->name = name;
	JSB_CCLayer_class->addProperty = JS_PropertyStub;
	JSB_CCLayer_class->delProperty = JS_PropertyStub;
	JSB_CCLayer_class->getProperty = JS_PropertyStub;
	JSB_CCLayer_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLayer_class->enumerate = JS_EnumerateStub;
	JSB_CCLayer_class->resolve = JS_ResolveStub;
	JSB_CCLayer_class->convert = JS_ConvertStub;
	JSB_CCLayer_class->finalize = JSB_CCLayer_finalize;
	JSB_CCLayer_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("isAccelerometerEnabled", JSB_CCLayer_isAccelerometerEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isTouchEnabled", JSB_CCLayer_isTouchEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAccelerometerEnabled", JSB_CCLayer_setAccelerometerEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAccelerometerInterval", JSB_CCLayer_setAccelerometerInterval_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTouchEnabled", JSB_CCLayer_setTouchEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTouchMode", JSB_CCLayer_setTouchMode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTouchPriority", JSB_CCLayer_setTouchPriority_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTouchSwallow", JSB_CCLayer_setTouchSwallow_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTouchMode", JSB_CCLayer_touchMode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTouchPriority", JSB_CCLayer_touchPriority, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTouchSwallow", JSB_CCLayer_touchSwallow, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchEnded", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchBegan", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchMoved", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchesEnded", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchesCancelled", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchCancelled", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchesMoved", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onAccelerometer", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onTouchesBegan", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLayer_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLayer_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLayer_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCLayer_class, JSB_CCLayer_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLayer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLayer_class, JSB_CCLayer_object, NULL);
	JSB_CCLayer *proxy = [[JSB_CCLayer alloc] initWithJSObject:jsobj class:[CCLayer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

+(void) swizzleMethods
{
	[super swizzleMethods];

	static BOOL CCLayer_already_swizzled = NO;
	if( ! CCLayer_already_swizzled ) {
		NSError *error;

		if( ! [CCLayer jr_swizzleMethod:@selector(ccTouchBegan:withEvent:) withMethod:@selector(JSHook_ccTouchBegan:withEvent:) error:&error] )
			NSLog(@"Error swizzling %@", error);

		CCLayer_already_swizzled = YES;
	}
}

-(void) ccTouchEnded:(UITouch*)touch withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchEnded", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSObject(cx, touch);
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchEnded", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(BOOL) ccTouchBegan:(UITouch*)touch withEvent:(UIEvent*)event 
{
	BOOL ret = nil;
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchBegan", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSObject(cx, touch);
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchBegan", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
			JSBool ret_val;
			JSBool ok = JS_ValueToBoolean( cx, rval, &ret_val );
			ret = ret_val;
			JSB_PRECONDITION2( ok, cx, ret, "Error converting return value to object");
		}
	}
	return ret;
}

-(void) ccTouchMoved:(UITouch*)touch withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchMoved", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSObject(cx, touch);
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchMoved", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) ccTouchesEnded:(NSSet*)touches withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchesEnded", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSSet( cx, (NSSet*) touches );
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchesEnded", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) ccTouchesCancelled:(NSSet*)touches withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchesCancelled", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSSet( cx, (NSSet*) touches );
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchesCancelled", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) ccTouchCancelled:(UITouch*)touch withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchCancelled", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSObject(cx, touch);
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchCancelled", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) ccTouchesMoved:(NSSet*)touches withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchesMoved", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSSet( cx, (NSSet*) touches );
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchesMoved", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) ccTouchesBegan:(NSSet*)touches withEvent:(UIEvent*)event 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onTouchesBegan", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=2;
			jsval argv[2];
			argv[0] = JSB_jsval_from_NSSet( cx, (NSSet*) touches );
			argv[1] = JSB_jsval_from_NSObject(cx, event);

			JS_GetProperty(cx, _jsObj, "onTouchesBegan", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

@end
@implementation CCLayer (JSBindings)

-(void) ccTouchEnded:(UITouch*)touch withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchEnded:touch withEvent:event ];

}

-(BOOL) JSHook_ccTouchBegan:(UITouch*)touch withEvent:(UIEvent*)event 
{
	BOOL ret = nil;
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		ret = [proxy ccTouchBegan:touch withEvent:event ];
	return ret;

}

-(void) ccTouchMoved:(UITouch*)touch withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchMoved:touch withEvent:event ];

}

-(void) ccTouchesEnded:(NSSet*)touches withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchesEnded:touches withEvent:event ];

}

-(void) ccTouchesCancelled:(NSSet*)touches withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchesCancelled:touches withEvent:event ];

}

-(void) ccTouchCancelled:(UITouch*)touch withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchCancelled:touch withEvent:event ];

}

-(void) ccTouchesMoved:(NSSet*)touches withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchesMoved:touches withEvent:event ];

}

-(void) accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy accelerometer:accelerometer didAccelerate:acceleration ];

}

-(void) ccTouchesBegan:(NSSet*)touches withEvent:(UIEvent*)event 
{
	JSB_CCLayer *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy ccTouchesBegan:touches withEvent:event ];

}
@end

/*
 * CCLayerMultiplex
 */
#pragma mark - CCLayerMultiplex

JSClass* JSB_CCLayerMultiplex_class = NULL;
JSObject* JSB_CCLayerMultiplex_object = NULL;
// Constructor
JSBool JSB_CCLayerMultiplex_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLayerMultiplex createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLayerMultiplex_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLayerMultiplex)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLayerMultiplex_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLayerMultiplex *proxy = [[JSB_CCLayerMultiplex alloc] initWithJSObject:obj class:[CCLayerMultiplex class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: None (None)
JSBool JSB_CCLayerMultiplex_initWithArray_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerMultiplex *real = [(CCLayerMultiplex*)[proxy.klass alloc] initWithArray:(NSArray*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCLayerMultiplex* (o)
JSBool JSB_CCLayerMultiplex_layerWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLayerMultiplex* ret_val;

	ret_val = [CCLayerMultiplex layerWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSB_CCLayerMultiplex_switchTo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerMultiplex *real = (CCLayerMultiplex*) [proxy realObj];
	[real switchTo:(unsigned int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSB_CCLayerMultiplex_switchToAndReleaseMe_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerMultiplex *real = (CCLayerMultiplex*) [proxy realObj];
	[real switchToAndReleaseMe:(unsigned int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCLayerMultiplex_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLayerMultiplex_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLayerMultiplex_class->name = name;
	JSB_CCLayerMultiplex_class->addProperty = JS_PropertyStub;
	JSB_CCLayerMultiplex_class->delProperty = JS_PropertyStub;
	JSB_CCLayerMultiplex_class->getProperty = JS_PropertyStub;
	JSB_CCLayerMultiplex_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLayerMultiplex_class->enumerate = JS_EnumerateStub;
	JSB_CCLayerMultiplex_class->resolve = JS_ResolveStub;
	JSB_CCLayerMultiplex_class->convert = JS_ConvertStub;
	JSB_CCLayerMultiplex_class->finalize = JSB_CCLayerMultiplex_finalize;
	JSB_CCLayerMultiplex_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithArray", JSB_CCLayerMultiplex_initWithArray_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("switchTo", JSB_CCLayerMultiplex_switchTo_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("switchToAndReleaseMe", JSB_CCLayerMultiplex_switchToAndReleaseMe_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLayerMultiplex_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLayerMultiplex_layerWithArray__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLayerMultiplex_object = JS_InitClass(cx, globalObj, JSB_CCLayer_object, JSB_CCLayerMultiplex_class, JSB_CCLayerMultiplex_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLayerMultiplex

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLayerMultiplex_class, JSB_CCLayerMultiplex_object, NULL);
	JSB_CCLayerMultiplex *proxy = [[JSB_CCLayerMultiplex alloc] initWithJSObject:jsobj class:[CCLayerMultiplex class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLayerRGBA
 */
#pragma mark - CCLayerRGBA

JSClass* JSB_CCLayerRGBA_class = NULL;
JSObject* JSB_CCLayerRGBA_object = NULL;
// Constructor
JSBool JSB_CCLayerRGBA_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLayerRGBA createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLayerRGBA_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLayerRGBA)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLayerRGBA_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLayerRGBA *proxy = [[JSB_CCLayerRGBA alloc] initWithJSObject:obj class:[CCLayerRGBA class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLayerRGBA_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLayerRGBA_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLayerRGBA_displayedColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real displayedColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLayerRGBA_displayedOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real displayedOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayerRGBA_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayerRGBA_isCascadeColorEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real isCascadeColorEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayerRGBA_isCascadeOpacityEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	ret_val = [real isCascadeOpacityEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_setCascadeColorEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real setCascadeColorEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_setCascadeOpacityEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real setCascadeOpacityEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_updateDisplayedColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real updateDisplayedColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLayerRGBA_updateDisplayedOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerRGBA *real = (CCLayerRGBA*) [proxy realObj];
	[real updateDisplayedOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLayerRGBA* (o)
JSBool JSB_CCLayerRGBA_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCLayerRGBA* ret_val;

	ret_val = [CCLayerRGBA node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCLayerRGBA_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLayerRGBA_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLayerRGBA_class->name = name;
	JSB_CCLayerRGBA_class->addProperty = JS_PropertyStub;
	JSB_CCLayerRGBA_class->delProperty = JS_PropertyStub;
	JSB_CCLayerRGBA_class->getProperty = JS_PropertyStub;
	JSB_CCLayerRGBA_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLayerRGBA_class->enumerate = JS_EnumerateStub;
	JSB_CCLayerRGBA_class->resolve = JS_ResolveStub;
	JSB_CCLayerRGBA_class->convert = JS_ConvertStub;
	JSB_CCLayerRGBA_class->finalize = JSB_CCLayerRGBA_finalize;
	JSB_CCLayerRGBA_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getOpacity", JSB_CCLayerRGBA_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("color", JSB_CCLayerRGBA_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("displayedColor", JSB_CCLayerRGBA_displayedColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("displayedOpacity", JSB_CCLayerRGBA_displayedOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCLayerRGBA_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeColorEnabled", JSB_CCLayerRGBA_isCascadeColorEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeOpacityEnabled", JSB_CCLayerRGBA_isCascadeOpacityEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeColorEnabled", JSB_CCLayerRGBA_setCascadeColorEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeOpacityEnabled", JSB_CCLayerRGBA_setCascadeOpacityEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCLayerRGBA_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCLayerRGBA_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCLayerRGBA_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedColor", JSB_CCLayerRGBA_updateDisplayedColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedOpacity", JSB_CCLayerRGBA_updateDisplayedOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLayerRGBA_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLayerRGBA_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLayerRGBA_object = JS_InitClass(cx, globalObj, JSB_CCLayer_object, JSB_CCLayerRGBA_class, JSB_CCLayerRGBA_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLayerRGBA

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLayerRGBA_class, JSB_CCLayerRGBA_object, NULL);
	JSB_CCLayerRGBA *proxy = [[JSB_CCLayerRGBA alloc] initWithJSObject:jsobj class:[CCLayerRGBA class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLayerColor
 */
#pragma mark - CCLayerColor

JSClass* JSB_CCLayerColor_class = NULL;
JSObject* JSB_CCLayerColor_object = NULL;
// Constructor
JSBool JSB_CCLayerColor_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLayerColor createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLayerColor_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLayerColor)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLayerColor_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLayerColor *proxy = [[JSB_CCLayerColor alloc] initWithJSObject:obj class:[CCLayerColor class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSB_CCLayerColor_changeHeight_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerColor *real = (CCLayerColor*) [proxy realObj];
	[real changeHeight:(GLfloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSB_CCLayerColor_changeWidth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerColor *real = (CCLayerColor*) [proxy realObj];
	[real changeWidth:(GLfloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLfloat, GLfloat
// Ret value: void (None)
JSBool JSB_CCLayerColor_changeWidth_height_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerColor *real = (CCLayerColor*) [proxy realObj];
	[real changeWidth:(GLfloat)arg0 height:(GLfloat)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4B, GLfloat, GLfloat
// Ret value: None (None)
JSBool JSB_CCLayerColor_initWithColor_width_height_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4B arg0; double arg1; double arg2; 

	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCLayerColor *real = [(CCLayerColor*)[proxy.klass alloc] initWithColor:(ccColor4B)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else if( argc == 3 ) {
		CCLayerColor *real = [(CCLayerColor*)[proxy.klass alloc] initWithColor:(ccColor4B)arg0 width:(GLfloat)arg1 height:(GLfloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccColor4B, GLfloat, GLfloat
// Ret value: CCLayerColor* (o)
JSBool JSB_CCLayerColor_layerWithColor_width_height__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4B arg0; double arg1; double arg2; 

	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLayerColor* ret_val;

	if( argc == 1 ) {
		ret_val = [CCLayerColor layerWithColor:(ccColor4B)arg0  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCLayerColor layerWithColor:(ccColor4B)arg0 width:(GLfloat)arg1 height:(GLfloat)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCLayerColor_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLayerColor_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLayerColor_class->name = name;
	JSB_CCLayerColor_class->addProperty = JS_PropertyStub;
	JSB_CCLayerColor_class->delProperty = JS_PropertyStub;
	JSB_CCLayerColor_class->getProperty = JS_PropertyStub;
	JSB_CCLayerColor_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLayerColor_class->enumerate = JS_EnumerateStub;
	JSB_CCLayerColor_class->resolve = JS_ResolveStub;
	JSB_CCLayerColor_class->convert = JS_ConvertStub;
	JSB_CCLayerColor_class->finalize = JSB_CCLayerColor_finalize;
	JSB_CCLayerColor_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("changeHeight", JSB_CCLayerColor_changeHeight_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("changeWidth", JSB_CCLayerColor_changeWidth_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("changeWidthHeight", JSB_CCLayerColor_changeWidth_height_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCLayerColor_initWithColor_width_height_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCLayerColor_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLayerColor_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLayerColor_layerWithColor_width_height__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLayerColor_object = JS_InitClass(cx, globalObj, JSB_CCLayerRGBA_object, JSB_CCLayerColor_class, JSB_CCLayerColor_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLayerColor

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLayerColor_class, JSB_CCLayerColor_object, NULL);
	JSB_CCLayerColor *proxy = [[JSB_CCLayerColor alloc] initWithJSObject:jsobj class:[CCLayerColor class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLayerGradient
 */
#pragma mark - CCLayerGradient

JSClass* JSB_CCLayerGradient_class = NULL;
JSObject* JSB_CCLayerGradient_object = NULL;
// Constructor
JSBool JSB_CCLayerGradient_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLayerGradient createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLayerGradient_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLayerGradient)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLayerGradient_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLayerGradient *proxy = [[JSB_CCLayerGradient alloc] initWithJSObject:obj class:[CCLayerGradient class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLayerGradient_compressedInterpolation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real compressedInterpolation ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLayerGradient_endColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real endColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLayerGradient_endOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real endOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: ccColor4B, ccColor4B, CGPoint
// Ret value: None (None)
JSBool JSB_CCLayerGradient_initWithColor_fadingTo_alongVector_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4B arg0; ccColor4B arg1; CGPoint arg2; 

	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg0 );
	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 2 ) {
		CCLayerGradient *real = [(CCLayerGradient*)[proxy.klass alloc] initWithColor:(ccColor4B)arg0 fadingTo:(ccColor4B)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else if( argc == 3 ) {
		CCLayerGradient *real = [(CCLayerGradient*)[proxy.klass alloc] initWithColor:(ccColor4B)arg0 fadingTo:(ccColor4B)arg1 alongVector:(CGPoint)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccColor4B, ccColor4B, CGPoint
// Ret value: CCLayerGradient* (o)
JSBool JSB_CCLayerGradient_layerWithColor_fadingTo_alongVector__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4B arg0; ccColor4B arg1; CGPoint arg2; 

	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg0 );
	ok &= JSB_jsval_to_ccColor4B( cx, *argvp++, (ccColor4B*) &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLayerGradient* ret_val;

	if( argc == 2 ) {
		ret_val = [CCLayerGradient layerWithColor:(ccColor4B)arg0 fadingTo:(ccColor4B)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCLayerGradient layerWithColor:(ccColor4B)arg0 fadingTo:(ccColor4B)arg1 alongVector:(CGPoint)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setCompressedInterpolation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setCompressedInterpolation:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setEndColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setEndColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setEndOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setEndOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setStartColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setStartColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setStartOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setStartOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCLayerGradient_setVector_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	[real setVector:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLayerGradient_startColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real startColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLayerGradient_startOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real startOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCLayerGradient_vector(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCLayerGradient *real = (CCLayerGradient*) [proxy realObj];
	ret_val = [real vector ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

void JSB_CCLayerGradient_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLayerGradient_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLayerGradient_class->name = name;
	JSB_CCLayerGradient_class->addProperty = JS_PropertyStub;
	JSB_CCLayerGradient_class->delProperty = JS_PropertyStub;
	JSB_CCLayerGradient_class->getProperty = JS_PropertyStub;
	JSB_CCLayerGradient_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLayerGradient_class->enumerate = JS_EnumerateStub;
	JSB_CCLayerGradient_class->resolve = JS_ResolveStub;
	JSB_CCLayerGradient_class->convert = JS_ConvertStub;
	JSB_CCLayerGradient_class->finalize = JSB_CCLayerGradient_finalize;
	JSB_CCLayerGradient_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("isCompressedInterpolation", JSB_CCLayerGradient_compressedInterpolation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndColor", JSB_CCLayerGradient_endColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndOpacity", JSB_CCLayerGradient_endOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCLayerGradient_initWithColor_fadingTo_alongVector_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCompressedInterpolation", JSB_CCLayerGradient_setCompressedInterpolation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndColor", JSB_CCLayerGradient_setEndColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndOpacity", JSB_CCLayerGradient_setEndOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartColor", JSB_CCLayerGradient_setStartColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartOpacity", JSB_CCLayerGradient_setStartOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVector", JSB_CCLayerGradient_setVector_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartColor", JSB_CCLayerGradient_startColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartOpacity", JSB_CCLayerGradient_startOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVector", JSB_CCLayerGradient_vector, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLayerGradient_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLayerGradient_layerWithColor_fadingTo_alongVector__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLayerGradient_object = JS_InitClass(cx, globalObj, JSB_CCLayerColor_object, JSB_CCLayerGradient_class, JSB_CCLayerGradient_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLayerGradient

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLayerGradient_class, JSB_CCLayerGradient_object, NULL);
	JSB_CCLayerGradient *proxy = [[JSB_CCLayerGradient alloc] initWithJSObject:jsobj class:[CCLayerGradient class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenu
 */
#pragma mark - CCMenu

JSClass* JSB_CCMenu_class = NULL;
JSObject* JSB_CCMenu_object = NULL;
// Constructor
JSBool JSB_CCMenu_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenu createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenu_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenu)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenu_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenu *proxy = [[JSB_CCMenu alloc] initWithJSObject:obj class:[CCMenu class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsHorizontally(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsHorizontally ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsHorizontallyWithPadding_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsHorizontallyWithPadding:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsInColumnsWithArray_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsInColumnsWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsInRowsWithArray_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsInRowsWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsVertically(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsVertically ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCMenu_alignItemsVerticallyWithPadding_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real alignItemsVerticallyWithPadding:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenu_enabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenu *real = (CCMenu*) [proxy realObj];
	ret_val = [real enabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: None (None)
JSBool JSB_CCMenu_initWithArray_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = [(CCMenu*)[proxy.klass alloc] initWithArray:(NSArray*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCMenu* (o)
JSBool JSB_CCMenu_menuWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenu* ret_val;

	ret_val = [CCMenu menuWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenu_setEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real setEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCMenu_setHandlerPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenu *real = (CCMenu*) [proxy realObj];
	[real setHandlerPriority:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenu_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenu_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenu_class->name = name;
	JSB_CCMenu_class->addProperty = JS_PropertyStub;
	JSB_CCMenu_class->delProperty = JS_PropertyStub;
	JSB_CCMenu_class->getProperty = JS_PropertyStub;
	JSB_CCMenu_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenu_class->enumerate = JS_EnumerateStub;
	JSB_CCMenu_class->resolve = JS_ResolveStub;
	JSB_CCMenu_class->convert = JS_ConvertStub;
	JSB_CCMenu_class->finalize = JSB_CCMenu_finalize;
	JSB_CCMenu_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("alignItemsHorizontally", JSB_CCMenu_alignItemsHorizontally, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("alignItemsHorizontallyWithPadding", JSB_CCMenu_alignItemsHorizontallyWithPadding_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("alignItemsInColumns", JSB_CCMenu_alignItemsInColumnsWithArray_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("alignItemsInRows", JSB_CCMenu_alignItemsInRowsWithArray_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("alignItemsVertically", JSB_CCMenu_alignItemsVertically, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("alignItemsVerticallyWithPadding", JSB_CCMenu_alignItemsVerticallyWithPadding_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEnabled", JSB_CCMenu_enabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithArray", JSB_CCMenu_initWithArray_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEnabled", JSB_CCMenu_setEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setHandlerPriority", JSB_CCMenu_setHandlerPriority_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenu_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCMenu_menuWithArray__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenu_object = JS_InitClass(cx, globalObj, JSB_CCLayerRGBA_object, JSB_CCMenu_class, JSB_CCMenu_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenu

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenu_class, JSB_CCMenu_object, NULL);
	JSB_CCMenu *proxy = [[JSB_CCMenu alloc] initWithJSObject:jsobj class:[CCMenu class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end


#endif // JSB_INCLUDE_COCOS2D_IOS
