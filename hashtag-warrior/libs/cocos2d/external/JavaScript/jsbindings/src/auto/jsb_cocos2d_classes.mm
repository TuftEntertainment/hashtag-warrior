/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c cocos2d_jsb.ini" on 2013-06-17
* Script version: v0.6
*/
#import "jsb_config.h"
#if JSB_INCLUDE_COCOS2D

#import "jsb_NS_manual.h"
#import "jsb_cocos2d_manual.h"

// needed for callbacks from objective-c to JS
#import <objc/runtime.h>
#import "JRSwizzle.h"

#import "jsfriendapi.h"
#import "jsb_config.h"
#import "jsb_core.h"

#import "jsb_cocos2d_classes.h"


/*
 * CCNode
 */
#pragma mark - CCNode

JSClass* JSB_CCNode_class = NULL;
JSObject* JSB_CCNode_object = NULL;
// Constructor
JSBool JSB_CCNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCNode *proxy = [[JSB_CCNode alloc] initWithJSObject:obj class:[CCNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionManager* (o)
JSBool JSB_CCNode_actionManager(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionManager* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real actionManager ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSB_CCNode_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:arg0  ];
	}
	else if( argc == 2 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:arg0 z:(NSInteger)arg1  ];
	}
	else if( argc == 3 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_anchorPoint(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real anchorPoint ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_anchorPointInPoints(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real anchorPointInPoints ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSB_CCNode_boundingBox(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGRect ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real boundingBox ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGRect( cx, (CGRect)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCamera* (o)
JSBool JSB_CCNode_camera(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCCamera* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real camera ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCArray* (array)
JSBool JSB_CCNode_children(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCArray* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real children ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_cleanup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real cleanup ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCNode_contentSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real contentSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_convertToNodeSpace_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToNodeSpace:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_convertToNodeSpaceAR_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToNodeSpaceAR:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_convertToWorldSpace_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToWorldSpace:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_convertToWorldSpaceAR_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToWorldSpaceAR:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: CCAction* (o)
JSBool JSB_CCNode_getActionByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAction* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real getActionByTag:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: CCNode* (o)
JSBool JSB_CCNode_getChildByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCNode* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real getChildByTag:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccGLServerState (i)
JSBool JSB_CCNode_glServerState(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccGLServerState ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real glServerState ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGridBase* (o)
JSBool JSB_CCNode_grid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGridBase* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real grid ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNode_ignoreAnchorPointForPosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real ignoreAnchorPointForPosition ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCNode_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = [(CCNode*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNode_isRunning(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real isRunning ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	ret_val = [CCNode node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSB_CCNode_nodeToParentTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real nodeToParentTransform ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 6, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSB_CCNode_nodeToWorldTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real nodeToWorldTransform ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 6, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCNode_numberOfRunningActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real numberOfRunningActions ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCNode_orderOfArrival(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real orderOfArrival ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCNode_parent(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real parent ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSB_CCNode_parentToNodeTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real parentToNodeTransform ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 6, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_pauseSchedulerAndActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real pauseSchedulerAndActions ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCNode_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real position ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNode_removeAllChildrenWithCleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 0 && argc <= 1 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	if (argc >= 1) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 0 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeAllChildren ];
	}
	else if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeAllChildrenWithCleanup:(BOOL)arg0  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*, BOOL
// Ret value: void (None)
JSBool JSB_CCNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeChild:arg0  ];
	}
	else if( argc == 2 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeChild:arg0 cleanup:(BOOL)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger, BOOL
// Ret value: void (None)
JSBool JSB_CCNode_removeChildByTag_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeChildByTag:(NSInteger)arg0  ];
	}
	else if( argc == 2 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeChildByTag:(NSInteger)arg0 cleanup:(BOOL)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNode_removeFromParentAndCleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 0 && argc <= 1 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	if (argc >= 1) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 0 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeFromParent ];
	}
	else if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real removeFromParentAndCleanup:(BOOL)arg0  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger
// Ret value: void (None)
JSBool JSB_CCNode_reorderChild_z_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real reorderChild:arg0 z:(NSInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_resumeSchedulerAndActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real resumeSchedulerAndActions ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_rotation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotation ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_rotationX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotationX ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_rotationY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotationY ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: CCAction* (o)
JSBool JSB_CCNode_runAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAction* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real runAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_scale(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scale ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_scaleX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scaleX ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_scaleY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scaleY ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_scheduleUpdate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real scheduleUpdate ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCNode_scheduleUpdateWithPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real scheduleUpdateWithPriority:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScheduler* (o)
JSBool JSB_CCNode_scheduler(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCScheduler* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scheduler ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionManager*
// Ret value: void (None)
JSBool JSB_CCNode_setActionManager_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setActionManager:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCNode_setAnchorPoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setAnchorPoint:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCNode_setContentSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setContentSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccGLServerState
// Ret value: void (None)
JSBool JSB_CCNode_setGlServerState_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setGlServerState:(ccGLServerState)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCGridBase*
// Ret value: void (None)
JSBool JSB_CCNode_setGrid_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setGrid:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNode_setIgnoreAnchorPointForPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setIgnoreAnchorPointForPosition:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCNode_setOrderOfArrival_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setOrderOfArrival:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCNode_setParent_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setParent:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setRotation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotation:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setRotationX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotationX:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setRotationY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotationY:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setScale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScale:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setScaleX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScaleX:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setScaleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScaleY:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCScheduler*
// Ret value: void (None)
JSBool JSB_CCNode_setScheduler_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScheduler:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSB_CCNode_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setShaderProgram:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setSkewX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setSkewX:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setSkewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setSkewY:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCNode_setTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setTag:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCNode_setUserObject_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setUserObject:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCNode_setVertexZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setVertexZ:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNode_setVisible_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setVisible:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCNode_setZOrder_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real setZOrder:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSB_CCNode_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_skewX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real skewX ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_skewY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real skewY ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_sortAllChildren(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real sortAllChildren ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: void (None)
JSBool JSB_CCNode_stopAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCNode_stopActionByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopActionByTag:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_stopAllActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopAllActions ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCNode_tag(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real tag ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_transform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real transform ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_transformAncestors(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real transformAncestors ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_unscheduleAllSelectors(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real unscheduleAllSelectors ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_unscheduleUpdate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real unscheduleUpdate ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCNode_userObject(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real userObject ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCNode_vertexZ(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real vertexZ ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNode_visible(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real visible ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCNode_visit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real visit ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSB_CCNode_worldToNodeTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real worldToNodeTransform ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 6, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCNode_zOrder(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real zOrder ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

void JSB_CCNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCNode_class->name = name;
	JSB_CCNode_class->addProperty = JS_PropertyStub;
	JSB_CCNode_class->delProperty = JS_PropertyStub;
	JSB_CCNode_class->getProperty = JS_PropertyStub;
	JSB_CCNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCNode_class->enumerate = JS_EnumerateStub;
	JSB_CCNode_class->resolve = JS_ResolveStub;
	JSB_CCNode_class->convert = JS_ConvertStub;
	JSB_CCNode_class->finalize = JSB_CCNode_finalize;
	JSB_CCNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActionManager", JSB_CCNode_actionManager, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addChild", JSB_CCNode_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorPoint", JSB_CCNode_anchorPoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnchorPointInPoints", JSB_CCNode_anchorPointInPoints, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBoundingBox", JSB_CCNode_boundingBox, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getCamera", JSB_CCNode_camera, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getChildren", JSB_CCNode_children, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("cleanup", JSB_CCNode_cleanup, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getContentSize", JSB_CCNode_contentSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToNodeSpace", JSB_CCNode_convertToNodeSpace_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToNodeSpaceAR", JSB_CCNode_convertToNodeSpaceAR_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToWorldSpace", JSB_CCNode_convertToWorldSpace_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("convertToWorldSpaceAR", JSB_CCNode_convertToWorldSpaceAR_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getActionByTag", JSB_CCNode_getActionByTag_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getChildByTag", JSB_CCNode_getChildByTag_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGlServerState", JSB_CCNode_glServerState, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGrid", JSB_CCNode_grid, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIgnoreAnchorPointForPosition", JSB_CCNode_ignoreAnchorPointForPosition, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCNode_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsRunning", JSB_CCNode_isRunning, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("nodeToParentTransform", JSB_CCNode_nodeToParentTransform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("nodeToWorldTransform", JSB_CCNode_nodeToWorldTransform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("numberOfRunningActions", JSB_CCNode_numberOfRunningActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOrderOfArrival", JSB_CCNode_orderOfArrival, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getParent", JSB_CCNode_parent, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("parentToNodeTransform", JSB_CCNode_parentToNodeTransform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseSchedulerAndActions", JSB_CCNode_pauseSchedulerAndActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSB_CCNode_position, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAllChildren", JSB_CCNode_removeAllChildrenWithCleanup_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeChild", JSB_CCNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeChildByTag", JSB_CCNode_removeChildByTag_cleanup_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeFromParent", JSB_CCNode_removeFromParentAndCleanup_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reorderChild", JSB_CCNode_reorderChild_z_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resumeSchedulerAndActions", JSB_CCNode_resumeSchedulerAndActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotation", JSB_CCNode_rotation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotationX", JSB_CCNode_rotationX, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotationY", JSB_CCNode_rotationY, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("runAction", JSB_CCNode_runAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getScale", JSB_CCNode_scale, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getScaleX", JSB_CCNode_scaleX, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getScaleY", JSB_CCNode_scaleY, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("schedule", JSB_CCNode_schedule_interval_repeat_delay_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("scheduleOnce", JSB_CCNode_scheduleOnce_delay_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdate", JSB_CCNode_scheduleUpdate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdateWithPriority", JSB_CCNode_scheduleUpdateWithPriority_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getScheduler", JSB_CCNode_scheduler, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setActionManager", JSB_CCNode_setActionManager_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnchorPoint", JSB_CCNode_setAnchorPoint_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setContentSize", JSB_CCNode_setContentSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGlServerState", JSB_CCNode_setGlServerState_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGrid", JSB_CCNode_setGrid_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ignoreAnchorPointForPosition", JSB_CCNode_setIgnoreAnchorPointForPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOrderOfArrival", JSB_CCNode_setOrderOfArrival_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setParent", JSB_CCNode_setParent_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSB_CCNode_setPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotation", JSB_CCNode_setRotation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotationX", JSB_CCNode_setRotationX_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotationY", JSB_CCNode_setRotationY_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setScale", JSB_CCNode_setScale_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setScaleX", JSB_CCNode_setScaleX_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setScaleY", JSB_CCNode_setScaleY_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setScheduler", JSB_CCNode_setScheduler_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSB_CCNode_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSkewX", JSB_CCNode_setSkewX_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSkewY", JSB_CCNode_setSkewY_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTag", JSB_CCNode_setTag_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUserObject", JSB_CCNode_setUserObject_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVertexZ", JSB_CCNode_setVertexZ_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVisible", JSB_CCNode_setVisible_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setZOrder", JSB_CCNode_setZOrder_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSB_CCNode_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSkewX", JSB_CCNode_skewX, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSkewY", JSB_CCNode_skewY, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("sortAllChildren", JSB_CCNode_sortAllChildren, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stopAction", JSB_CCNode_stopAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stopActionByTag", JSB_CCNode_stopActionByTag_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stopAllActions", JSB_CCNode_stopAllActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTag", JSB_CCNode_tag, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("transform", JSB_CCNode_transform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("transformAncestors", JSB_CCNode_transformAncestors, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unschedule", JSB_CCNode_unschedule_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllCallbacks", JSB_CCNode_unscheduleAllSelectors, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleUpdate", JSB_CCNode_unscheduleUpdate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getUserObject", JSB_CCNode_userObject, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVertexZ", JSB_CCNode_vertexZ, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isVisible", JSB_CCNode_visible, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("visit", JSB_CCNode_visit, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("worldToNodeTransform", JSB_CCNode_worldToNodeTransform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getZOrder", JSB_CCNode_zOrder, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onEnter", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onExitTransitionDidStart", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onExit", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("onEnterTransitionDidFinish", JSB_do_nothing, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCNode_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCNode_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCNode_class, JSB_CCNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCNode_class, JSB_CCNode_object, NULL);
	JSB_CCNode *proxy = [[JSB_CCNode alloc] initWithJSObject:jsobj class:[CCNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

+(void) swizzleMethods
{
	[super swizzleMethods];

	static BOOL CCNode_already_swizzled = NO;
	if( ! CCNode_already_swizzled ) {
		NSError *error;

		if( ! [CCNode jr_swizzleMethod:@selector(onEnter) withMethod:@selector(JSHook_onEnter) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(update:) withMethod:@selector(JSHook_update:) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onExitTransitionDidStart) withMethod:@selector(JSHook_onExitTransitionDidStart) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onExit) withMethod:@selector(JSHook_onExit) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onEnterTransitionDidFinish) withMethod:@selector(JSHook_onEnterTransitionDidFinish) error:&error] )
			NSLog(@"Error swizzling %@", error);

		CCNode_already_swizzled = YES;
	}
}

-(void) onEnter
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onEnter", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onEnter", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) update:(ccTime)delta 
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "update", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=1;
			jsval argv[1];
			argv[0] = DOUBLE_TO_JSVAL(delta);

			JS_GetProperty(cx, _jsObj, "update", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) onExitTransitionDidStart
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onExitTransitionDidStart", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onExitTransitionDidStart", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) onExit
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onExit", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onExit", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

-(void) onEnterTransitionDidFinish
{
	if (_jsObj) {
		JSContext* cx = [[JSBCore sharedInstance] globalContext];
		JSBool found;
		JSB_ENSURE_AUTOCOMPARTMENT(cx, _jsObj);
		JS_HasProperty(cx, _jsObj, "onEnterTransitionDidFinish", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onEnterTransitionDidFinish", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
	
}

@end
@implementation CCNode (JSBindings)

-(void) JSHook_onEnter
{
	//1st call native, then JS. Order is important
	[self JSHook_onEnter];
	JSB_CCNode *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy onEnter];

}

-(void) JSHook_update:(ccTime)delta 
{
	//1st call native, then JS. Order is important
	[self JSHook_update:delta ];
	JSB_CCNode *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy update:delta ];

}

-(void) JSHook_onExitTransitionDidStart
{
	//1st call native, then JS. Order is important
	[self JSHook_onExitTransitionDidStart];
	JSB_CCNode *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy onExitTransitionDidStart];

}

-(void) JSHook_onExit
{
	//1st call native, then JS. Order is important
	[self JSHook_onExit];
	JSB_CCNode *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy onExit];

}

-(void) JSHook_onEnterTransitionDidFinish
{
	//1st call native, then JS. Order is important
	[self JSHook_onEnterTransitionDidFinish];
	JSB_CCNode *proxy = objc_getAssociatedObject(self, &JSB_association_proxy_key);
	if( proxy )
		[proxy onEnterTransitionDidFinish];

}
@end

/*
 * CCParticleSystem
 */
#pragma mark - CCParticleSystem

JSClass* JSB_CCParticleSystem_class = NULL;
JSObject* JSB_CCParticleSystem_object = NULL;
// Constructor
JSBool JSB_CCParticleSystem_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSystem createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSystem_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSystem)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSystem_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSystem *proxy = [[JSB_CCParticleSystem alloc] initWithJSObject:obj class:[CCParticleSystem class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCParticleSystem_active(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real active ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_angle(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real angle ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_angleVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real angleVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCParticleSystem_atlasIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real atlasIndex ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCParticleSystem_autoRemoveOnFinish(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real autoRemoveOnFinish ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleBatchNode* (o)
JSBool JSB_CCParticleSystem_batchNode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleBatchNode* ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real batchNode ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCParticleSystem_blendAdditive(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real blendAdditive ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCParticleSystem_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real duration ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_emissionRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real emissionRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCParticleSystem_emitterMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real emitterMode ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F (N/A)
JSBool JSB_CCParticleSystem_endColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor4F( cx, (ccColor4F)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F (N/A)
JSBool JSB_CCParticleSystem_endColorVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endColorVar ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor4F( cx, (ccColor4F)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endRadius(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endRadius ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endRadiusVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endRadiusVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSize ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endSizeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSizeVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endSpin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSpin ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_endSpinVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSpinVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCParticleSystem_gravity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real gravity ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: NSDictionary*
// Ret value: None (None)
JSBool JSB_CCParticleSystem_initWithDictionary_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithDictionary:(NSDictionary*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSDictionary*, NSString*
// Ret value: None (None)
JSBool JSB_CCParticleSystem_initWithDictionary_path_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithDictionary:(NSDictionary*)arg0 path:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCParticleSystem_initWithFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: None (None)
JSBool JSB_CCParticleSystem_initWithTotalParticles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithTotalParticles:(NSUInteger)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCParticleSystem_isFull(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real isFull ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_life(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real life ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_lifeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real lifeVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCParticleSystem_particleCount(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real particleCount ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSystem* (o)
JSBool JSB_CCParticleSystem_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSystem* ret_val;

	ret_val = [CCParticleSystem particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSystem* (o)
JSBool JSB_CCParticleSystem_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSystem* ret_val;

	ret_val = [CCParticleSystem particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCParticleSystem_posVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real posVar ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: tCCPositionType (i)
JSBool JSB_CCParticleSystem_positionType(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	tCCPositionType ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real positionType ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCParticleSystem_postStep(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real postStep ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_radialAccel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real radialAccel ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_radialAccelVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real radialAccelVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCParticleSystem_resetSystem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real resetSystem ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_rotatePerSecond(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real rotatePerSecond ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_rotatePerSecondVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real rotatePerSecondVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setAngle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAngle:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setAngleVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAngleVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setAtlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAtlasIndex:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setAutoRemoveOnFinish_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAutoRemoveOnFinish:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCParticleBatchNode*
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setBatchNode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setBatchNode:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setBlendAdditive_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setBlendAdditive:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setDuration:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEmissionRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEmissionRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEmitterMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEmitterMode:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 

	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndColor:(ccColor4F)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndColorVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 

	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndColorVar:(ccColor4F)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndRadius_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndRadius:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndRadiusVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndRadiusVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSize:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndSizeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSizeVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndSpin_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSpin:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setEndSpinVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSpinVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setGravity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setGravity:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setLife_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setLife:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setLifeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setLifeVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setPosVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setPosVar:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: tCCPositionType
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setPositionType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setPositionType:(tCCPositionType)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setRadialAccel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRadialAccel:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setRadialAccelVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRadialAccelVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setRotatePerSecond_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRotatePerSecond:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setRotatePerSecondVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRotatePerSecondVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setSourcePosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSourcePosition:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setSpeed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSpeed:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setSpeedVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSpeedVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 

	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartColor:(ccColor4F)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartColorVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 

	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartColorVar:(ccColor4F)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartRadius_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartRadius:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartRadiusVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartRadiusVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSize:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartSizeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSizeVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartSpin_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSpin:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setStartSpinVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSpinVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setTangentialAccel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTangentialAccel:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setTangentialAccelVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTangentialAccelVar:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCParticleSystem_setTotalParticles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCParticleSystem_sourcePosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real sourcePosition ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_speed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real speed ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_speedVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real speedVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F (N/A)
JSBool JSB_CCParticleSystem_startColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor4F( cx, (ccColor4F)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F (N/A)
JSBool JSB_CCParticleSystem_startColorVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startColorVar ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor4F( cx, (ccColor4F)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startRadius(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startRadius ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startRadiusVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startRadiusVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSize ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startSizeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSizeVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startSpin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSpin ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_startSpinVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSpinVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCParticleSystem_stopSystem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real stopSystem ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_tangentialAccel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real tangentialAccel ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCParticleSystem_tangentialAccelVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real tangentialAccelVar ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCParticleSystem_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCParticleSystem_totalParticles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real totalParticles ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCParticleSystem_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCParticleSystem_updateWithNoTime(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real updateWithNoTime ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCParticleSystem_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSystem_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSystem_class->name = name;
	JSB_CCParticleSystem_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSystem_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSystem_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSystem_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSystem_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSystem_class->resolve = JS_ResolveStub;
	JSB_CCParticleSystem_class->convert = JS_ConvertStub;
	JSB_CCParticleSystem_class->finalize = JSB_CCParticleSystem_finalize;
	JSB_CCParticleSystem_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActive", JSB_CCParticleSystem_active, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAngle", JSB_CCParticleSystem_angle, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAngleVar", JSB_CCParticleSystem_angleVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAtlasIndex", JSB_CCParticleSystem_atlasIndex, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAutoRemoveOnFinish", JSB_CCParticleSystem_autoRemoveOnFinish, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBatchNode", JSB_CCParticleSystem_batchNode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBlendAdditive", JSB_CCParticleSystem_blendAdditive, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCParticleSystem_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDuration", JSB_CCParticleSystem_duration, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEmissionRate", JSB_CCParticleSystem_emissionRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEmitterMode", JSB_CCParticleSystem_emitterMode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndColor", JSB_CCParticleSystem_endColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndColorVar", JSB_CCParticleSystem_endColorVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndRadius", JSB_CCParticleSystem_endRadius, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndRadiusVar", JSB_CCParticleSystem_endRadiusVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndSize", JSB_CCParticleSystem_endSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndSizeVar", JSB_CCParticleSystem_endSizeVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndSpin", JSB_CCParticleSystem_endSpin, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getEndSpinVar", JSB_CCParticleSystem_endSpinVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGravity", JSB_CCParticleSystem_gravity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDictionary", JSB_CCParticleSystem_initWithDictionary_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDictionaryPath", JSB_CCParticleSystem_initWithDictionary_path_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithFile", JSB_CCParticleSystem_initWithFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTotalParticles", JSB_CCParticleSystem_initWithTotalParticles_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFull", JSB_CCParticleSystem_isFull, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLife", JSB_CCParticleSystem_life, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLifeVar", JSB_CCParticleSystem_lifeVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getParticleCount", JSB_CCParticleSystem_particleCount, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosVar", JSB_CCParticleSystem_posVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPositionType", JSB_CCParticleSystem_positionType, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("postStep", JSB_CCParticleSystem_postStep, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRadialAccel", JSB_CCParticleSystem_radialAccel, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRadialAccelVar", JSB_CCParticleSystem_radialAccelVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resetSystem", JSB_CCParticleSystem_resetSystem, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotatePerSecond", JSB_CCParticleSystem_rotatePerSecond, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotatePerSecondVar", JSB_CCParticleSystem_rotatePerSecondVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSB_CCParticleSystem_setAngle_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAngleVar", JSB_CCParticleSystem_setAngleVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAtlasIndex", JSB_CCParticleSystem_setAtlasIndex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAutoRemoveOnFinish", JSB_CCParticleSystem_setAutoRemoveOnFinish_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBatchNode", JSB_CCParticleSystem_setBatchNode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendAdditive", JSB_CCParticleSystem_setBlendAdditive_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCParticleSystem_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDuration", JSB_CCParticleSystem_setDuration_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEmissionRate", JSB_CCParticleSystem_setEmissionRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEmitterMode", JSB_CCParticleSystem_setEmitterMode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndColor", JSB_CCParticleSystem_setEndColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndColorVar", JSB_CCParticleSystem_setEndColorVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndRadius", JSB_CCParticleSystem_setEndRadius_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndRadiusVar", JSB_CCParticleSystem_setEndRadiusVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndSize", JSB_CCParticleSystem_setEndSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndSizeVar", JSB_CCParticleSystem_setEndSizeVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndSpin", JSB_CCParticleSystem_setEndSpin_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEndSpinVar", JSB_CCParticleSystem_setEndSpinVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGravity", JSB_CCParticleSystem_setGravity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLife", JSB_CCParticleSystem_setLife_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLifeVar", JSB_CCParticleSystem_setLifeVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCParticleSystem_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosVar", JSB_CCParticleSystem_setPosVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPositionType", JSB_CCParticleSystem_setPositionType_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRadialAccel", JSB_CCParticleSystem_setRadialAccel_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRadialAccelVar", JSB_CCParticleSystem_setRadialAccelVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotatePerSecond", JSB_CCParticleSystem_setRotatePerSecond_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotatePerSecondVar", JSB_CCParticleSystem_setRotatePerSecondVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSourcePosition", JSB_CCParticleSystem_setSourcePosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSpeed", JSB_CCParticleSystem_setSpeed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSpeedVar", JSB_CCParticleSystem_setSpeedVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartColor", JSB_CCParticleSystem_setStartColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartColorVar", JSB_CCParticleSystem_setStartColorVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartRadius", JSB_CCParticleSystem_setStartRadius_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartRadiusVar", JSB_CCParticleSystem_setStartRadiusVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartSize", JSB_CCParticleSystem_setStartSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartSizeVar", JSB_CCParticleSystem_setStartSizeVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartSpin", JSB_CCParticleSystem_setStartSpin_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStartSpinVar", JSB_CCParticleSystem_setStartSpinVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTangentialAccel", JSB_CCParticleSystem_setTangentialAccel_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTangentialAccelVar", JSB_CCParticleSystem_setTangentialAccelVar_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCParticleSystem_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTotalParticles", JSB_CCParticleSystem_setTotalParticles_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSourcePosition", JSB_CCParticleSystem_sourcePosition, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpeed", JSB_CCParticleSystem_speed, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpeedVar", JSB_CCParticleSystem_speedVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartColor", JSB_CCParticleSystem_startColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartColorVar", JSB_CCParticleSystem_startColorVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartRadius", JSB_CCParticleSystem_startRadius, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartRadiusVar", JSB_CCParticleSystem_startRadiusVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartSize", JSB_CCParticleSystem_startSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartSizeVar", JSB_CCParticleSystem_startSizeVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartSpin", JSB_CCParticleSystem_startSpin, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStartSpinVar", JSB_CCParticleSystem_startSpinVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stopSystem", JSB_CCParticleSystem_stopSystem, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTangentialAccel", JSB_CCParticleSystem_tangentialAccel, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTangentialAccelVar", JSB_CCParticleSystem_tangentialAccelVar, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCParticleSystem_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTotalParticles", JSB_CCParticleSystem_totalParticles, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_CCParticleSystem_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateWithNoTime", JSB_CCParticleSystem_updateWithNoTime, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSystem_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleSystem_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleSystem_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSystem_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCParticleSystem_class, JSB_CCParticleSystem_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSystem

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSystem_class, JSB_CCParticleSystem_object, NULL);
	JSB_CCParticleSystem *proxy = [[JSB_CCParticleSystem alloc] initWithJSObject:jsobj class:[CCParticleSystem class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSystemQuad
 */
#pragma mark - CCParticleSystemQuad

JSClass* JSB_CCParticleSystemQuad_class = NULL;
JSObject* JSB_CCParticleSystemQuad_object = NULL;
// Constructor
JSBool JSB_CCParticleSystemQuad_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSystemQuad createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSystemQuad_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSystemQuad)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSystemQuad_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSystemQuad *proxy = [[JSB_CCParticleSystemQuad alloc] initWithJSObject:obj class:[CCParticleSystemQuad class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCParticleSystemQuad_initIndices(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real initIndices ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCParticleSystemQuad_initTexCoordsWithRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real initTexCoordsWithRect:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCParticleSystemQuad_setDisplayFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real setDisplayFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: void (None)
JSBool JSB_CCParticleSystemQuad_setTexture_withRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real setTexture:arg0 withRect:(CGRect)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSystemQuad* (o)
JSBool JSB_CCParticleSystemQuad_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSystemQuad* ret_val;

	ret_val = [CCParticleSystemQuad particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSystemQuad* (o)
JSBool JSB_CCParticleSystemQuad_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSystemQuad* ret_val;

	ret_val = [CCParticleSystemQuad particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleSystemQuad_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSystemQuad_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSystemQuad_class->name = name;
	JSB_CCParticleSystemQuad_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSystemQuad_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSystemQuad_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSystemQuad_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSystemQuad_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSystemQuad_class->resolve = JS_ResolveStub;
	JSB_CCParticleSystemQuad_class->convert = JS_ConvertStub;
	JSB_CCParticleSystemQuad_class->finalize = JSB_CCParticleSystemQuad_finalize;
	JSB_CCParticleSystemQuad_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initIndices", JSB_CCParticleSystemQuad_initIndices, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initTexCoordsWithRect", JSB_CCParticleSystemQuad_initTexCoordsWithRect_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrame", JSB_CCParticleSystemQuad_setDisplayFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureWithRect", JSB_CCParticleSystemQuad_setTexture_withRect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSystemQuad_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCParticleSystemQuad_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithTotalParticles", JSB_CCParticleSystemQuad_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSystemQuad_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystem_object, JSB_CCParticleSystemQuad_class, JSB_CCParticleSystemQuad_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSystemQuad

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSystemQuad_class, JSB_CCParticleSystemQuad_object, NULL);
	JSB_CCParticleSystemQuad *proxy = [[JSB_CCParticleSystemQuad alloc] initWithJSObject:jsobj class:[CCParticleSystemQuad class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleMeteor
 */
#pragma mark - CCParticleMeteor

JSClass* JSB_CCParticleMeteor_class = NULL;
JSObject* JSB_CCParticleMeteor_object = NULL;
// Constructor
JSBool JSB_CCParticleMeteor_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleMeteor createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleMeteor_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleMeteor)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleMeteor_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleMeteor *proxy = [[JSB_CCParticleMeteor alloc] initWithJSObject:obj class:[CCParticleMeteor class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleMeteor_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleMeteor *real = [(CCParticleMeteor*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleMeteor* (o)
JSBool JSB_CCParticleMeteor_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleMeteor* (o)
JSBool JSB_CCParticleMeteor_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleMeteor* (o)
JSBool JSB_CCParticleMeteor_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleMeteor_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleMeteor_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleMeteor_class->name = name;
	JSB_CCParticleMeteor_class->addProperty = JS_PropertyStub;
	JSB_CCParticleMeteor_class->delProperty = JS_PropertyStub;
	JSB_CCParticleMeteor_class->getProperty = JS_PropertyStub;
	JSB_CCParticleMeteor_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleMeteor_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleMeteor_class->resolve = JS_ResolveStub;
	JSB_CCParticleMeteor_class->convert = JS_ConvertStub;
	JSB_CCParticleMeteor_class->finalize = JSB_CCParticleMeteor_finalize;
	JSB_CCParticleMeteor_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleMeteor_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleMeteor_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleMeteor_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleMeteor_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleMeteor_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleMeteor_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleMeteor_class, JSB_CCParticleMeteor_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleMeteor

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleMeteor_class, JSB_CCParticleMeteor_object, NULL);
	JSB_CCParticleMeteor *proxy = [[JSB_CCParticleMeteor alloc] initWithJSObject:jsobj class:[CCParticleMeteor class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFontDefinition
 */
#pragma mark - CCFontDefinition

JSClass* JSB_CCFontDefinition_class = NULL;
JSObject* JSB_CCFontDefinition_object = NULL;
// Constructor
JSBool JSB_CCFontDefinition_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFontDefinition createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFontDefinition_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFontDefinition)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFontDefinition_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFontDefinition *proxy = [[JSB_CCFontDefinition alloc] initWithJSObject:obj class:[CCFontDefinition class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextAlignment (i)
JSBool JSB_CCFontDefinition_alignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextAlignment ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real alignment ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCFontDefinition_dimensions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real dimensions ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: _Bool
// Ret value: void (None)
JSBool JSB_CCFontDefinition_enableShadow_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real enableShadow:(_Bool)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: _Bool
// Ret value: void (None)
JSBool JSB_CCFontDefinition_enableStroke_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real enableStroke:(_Bool)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCFontDefinition_fontFillColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real fontFillColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCFontDefinition_fontName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real fontName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCFontDefinition_fontSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real fontSize ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCFontDefinition_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCFontDefinition *real = [(CCFontDefinition*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, int
// Ret value: None (None)
JSBool JSB_CCFontDefinition_initWithFontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; int32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = [(CCFontDefinition*)[proxy.klass alloc] initWithFontName:(NSString*)arg0 fontSize:(int)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLineBreakMode (i)
JSBool JSB_CCFontDefinition_lineBreakMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCLineBreakMode ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real lineBreakMode ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: CCTextAlignment
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setAlignment:(CCTextAlignment)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setDimensions_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setDimensions:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setFontFillColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setFontFillColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setFontName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setFontName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setFontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setFontSize:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCLineBreakMode
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setLineBreakMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setLineBreakMode:(CCLineBreakMode)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGFloat
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setShadowBlur_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setShadowBlur:(CGFloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setShadowOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setShadowOffset:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setStrokeColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setStrokeColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGFloat
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setStrokeSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setStrokeSize:(CGFloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCVerticalTextAlignment
// Ret value: void (None)
JSBool JSB_CCFontDefinition_setVertAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	[real setVertAlignment:(CCVerticalTextAlignment)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGFloat (d)
JSBool JSB_CCFontDefinition_shadowBlur(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGFloat ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real shadowBlur ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: _Bool (b)
JSBool JSB_CCFontDefinition_shadowEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	_Bool ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real shadowEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCFontDefinition_shadowOffset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real shadowOffset ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCFontDefinition_strokeColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real strokeColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: _Bool (b)
JSBool JSB_CCFontDefinition_strokeEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	_Bool ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real strokeEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGFloat (d)
JSBool JSB_CCFontDefinition_strokeSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGFloat ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real strokeSize ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCVerticalTextAlignment (i)
JSBool JSB_CCFontDefinition_vertAlignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCVerticalTextAlignment ret_val;

	CCFontDefinition *real = (CCFontDefinition*) [proxy realObj];
	ret_val = [real vertAlignment ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

void JSB_CCFontDefinition_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFontDefinition_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFontDefinition_class->name = name;
	JSB_CCFontDefinition_class->addProperty = JS_PropertyStub;
	JSB_CCFontDefinition_class->delProperty = JS_PropertyStub;
	JSB_CCFontDefinition_class->getProperty = JS_PropertyStub;
	JSB_CCFontDefinition_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFontDefinition_class->enumerate = JS_EnumerateStub;
	JSB_CCFontDefinition_class->resolve = JS_ResolveStub;
	JSB_CCFontDefinition_class->convert = JS_ConvertStub;
	JSB_CCFontDefinition_class->finalize = JSB_CCFontDefinition_finalize;
	JSB_CCFontDefinition_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAlignment", JSB_CCFontDefinition_alignment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDimensions", JSB_CCFontDefinition_dimensions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableShadow", JSB_CCFontDefinition_enableShadow_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableStroke", JSB_CCFontDefinition_enableStroke_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFontFillColor", JSB_CCFontDefinition_fontFillColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFontName", JSB_CCFontDefinition_fontName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFontSize", JSB_CCFontDefinition_fontSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCFontDefinition_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithFontNameFontSize", JSB_CCFontDefinition_initWithFontName_fontSize_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLineBreakMode", JSB_CCFontDefinition_lineBreakMode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAlignment", JSB_CCFontDefinition_setAlignment_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDimensions", JSB_CCFontDefinition_setDimensions_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontFillColor", JSB_CCFontDefinition_setFontFillColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSB_CCFontDefinition_setFontName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSB_CCFontDefinition_setFontSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLineBreakMode", JSB_CCFontDefinition_setLineBreakMode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setShadowBlur", JSB_CCFontDefinition_setShadowBlur_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setShadowOffset", JSB_CCFontDefinition_setShadowOffset_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStrokeColor", JSB_CCFontDefinition_setStrokeColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStrokeSize", JSB_CCFontDefinition_setStrokeSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVertAlignment", JSB_CCFontDefinition_setVertAlignment_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("shadowBlur", JSB_CCFontDefinition_shadowBlur, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("shadowEnabled", JSB_CCFontDefinition_shadowEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("shadowOffset", JSB_CCFontDefinition_shadowOffset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("strokeColor", JSB_CCFontDefinition_strokeColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("strokeEnabled", JSB_CCFontDefinition_strokeEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("strokeSize", JSB_CCFontDefinition_strokeSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVertAlignment", JSB_CCFontDefinition_vertAlignment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFontDefinition_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCFontDefinition_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCFontDefinition_class, JSB_CCFontDefinition_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFontDefinition

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFontDefinition_class, JSB_CCFontDefinition_object, NULL);
	JSB_CCFontDefinition *proxy = [[JSB_CCFontDefinition alloc] initWithJSObject:jsobj class:[CCFontDefinition class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAction
 */
#pragma mark - CCAction

JSClass* JSB_CCAction_class = NULL;
JSObject* JSB_CCAction_object = NULL;
// Constructor
JSBool JSB_CCAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAction *proxy = [[JSB_CCAction alloc] initWithJSObject:obj class:[CCAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAction* (o)
JSBool JSB_CCAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCAction* ret_val;

	ret_val = [CCAction action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCAction_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCAction *real = [(CCAction*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCAction_isDone(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real isDone ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCAction_originalTarget(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real originalTarget ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCAction_setTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAction *real = (CCAction*) [proxy realObj];
	[real setTag:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCAction_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAction *real = (CCAction*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCAction_step_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAction *real = (CCAction*) [proxy realObj];
	[real step:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCAction_stop(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCAction *real = (CCAction*) [proxy realObj];
	[real stop ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCAction_tag(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real tag ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCAction_target(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real target ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCAction_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAction *real = (CCAction*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAction_class->name = name;
	JSB_CCAction_class->addProperty = JS_PropertyStub;
	JSB_CCAction_class->delProperty = JS_PropertyStub;
	JSB_CCAction_class->getProperty = JS_PropertyStub;
	JSB_CCAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAction_class->enumerate = JS_EnumerateStub;
	JSB_CCAction_class->resolve = JS_ResolveStub;
	JSB_CCAction_class->convert = JS_ConvertStub;
	JSB_CCAction_class->finalize = JSB_CCAction_finalize;
	JSB_CCAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCAction_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDone", JSB_CCAction_isDone, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOriginalTarget", JSB_CCAction_originalTarget, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTag", JSB_CCAction_setTag_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("startWithTarget", JSB_CCAction_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("step", JSB_CCAction_step_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stop", JSB_CCAction_stop, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTag", JSB_CCAction_tag, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTarget", JSB_CCAction_target, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_CCAction_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSB_CCAction_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAction_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCAction_class, JSB_CCAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAction_class, JSB_CCAction_object, NULL);
	JSB_CCAction *proxy = [[JSB_CCAction alloc] initWithJSObject:jsobj class:[CCAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFiniteTimeAction
 */
#pragma mark - CCFiniteTimeAction

JSClass* JSB_CCFiniteTimeAction_class = NULL;
JSObject* JSB_CCFiniteTimeAction_object = NULL;
// Constructor
JSBool JSB_CCFiniteTimeAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFiniteTimeAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFiniteTimeAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFiniteTimeAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFiniteTimeAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFiniteTimeAction *proxy = [[JSB_CCFiniteTimeAction alloc] initWithJSObject:obj class:[CCFiniteTimeAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSB_CCFiniteTimeAction_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTime ret_val;

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	ret_val = [real duration ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSB_CCFiniteTimeAction_reverse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	ret_val = [real reverse ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCFiniteTimeAction_setDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	[real setDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSB_CCFiniteTimeAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	ret_val = [CCFiniteTimeAction action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFiniteTimeAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFiniteTimeAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFiniteTimeAction_class->name = name;
	JSB_CCFiniteTimeAction_class->addProperty = JS_PropertyStub;
	JSB_CCFiniteTimeAction_class->delProperty = JS_PropertyStub;
	JSB_CCFiniteTimeAction_class->getProperty = JS_PropertyStub;
	JSB_CCFiniteTimeAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFiniteTimeAction_class->enumerate = JS_EnumerateStub;
	JSB_CCFiniteTimeAction_class->resolve = JS_ResolveStub;
	JSB_CCFiniteTimeAction_class->convert = JS_ConvertStub;
	JSB_CCFiniteTimeAction_class->finalize = JSB_CCFiniteTimeAction_finalize;
	JSB_CCFiniteTimeAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDuration", JSB_CCFiniteTimeAction_duration, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reverse", JSB_CCFiniteTimeAction_reverse, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDuration", JSB_CCFiniteTimeAction_setDuration_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFiniteTimeAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSB_CCFiniteTimeAction_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFiniteTimeAction_object = JS_InitClass(cx, globalObj, JSB_CCAction_object, JSB_CCFiniteTimeAction_class, JSB_CCFiniteTimeAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFiniteTimeAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFiniteTimeAction_class, JSB_CCFiniteTimeAction_object, NULL);
	JSB_CCFiniteTimeAction *proxy = [[JSB_CCFiniteTimeAction alloc] initWithJSObject:jsobj class:[CCFiniteTimeAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionInterval
 */
#pragma mark - CCActionInterval

JSClass* JSB_CCActionInterval_class = NULL;
JSObject* JSB_CCActionInterval_object = NULL;
// Constructor
JSBool JSB_CCActionInterval_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionInterval createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionInterval_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionInterval)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionInterval_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionInterval *proxy = [[JSB_CCActionInterval alloc] initWithJSObject:obj class:[CCActionInterval class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCActionInterval* (o)
JSBool JSB_CCActionInterval_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	ret_val = [CCActionInterval actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSB_CCActionInterval_elapsed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTime ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real elapsed ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: None (None)
JSBool JSB_CCActionInterval_initWithDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionInterval *real = [(CCActionInterval*)[proxy.klass alloc] initWithDuration:(ccTime)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCActionInterval_isDone(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real isDone ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCActionInterval_reverse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real reverse ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCActionInterval_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionInterval_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionInterval_class->name = name;
	JSB_CCActionInterval_class->addProperty = JS_PropertyStub;
	JSB_CCActionInterval_class->delProperty = JS_PropertyStub;
	JSB_CCActionInterval_class->getProperty = JS_PropertyStub;
	JSB_CCActionInterval_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionInterval_class->enumerate = JS_EnumerateStub;
	JSB_CCActionInterval_class->resolve = JS_ResolveStub;
	JSB_CCActionInterval_class->convert = JS_ConvertStub;
	JSB_CCActionInterval_class->finalize = JSB_CCActionInterval_finalize;
	JSB_CCActionInterval_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getElapsed", JSB_CCActionInterval_elapsed, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDuration", JSB_CCActionInterval_initWithDuration_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isDone", JSB_CCActionInterval_isDone, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reverse", JSB_CCActionInterval_reverse, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionInterval_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSB_CCActionInterval_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCActionInterval_object = JS_InitClass(cx, globalObj, JSB_CCFiniteTimeAction_object, JSB_CCActionInterval_class, JSB_CCActionInterval_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionInterval

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionInterval_class, JSB_CCActionInterval_object, NULL);
	JSB_CCActionInterval *proxy = [[JSB_CCActionInterval alloc] initWithJSObject:jsobj class:[CCActionInterval class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressFromTo
 */
#pragma mark - CCProgressFromTo

JSClass* JSB_CCProgressFromTo_class = NULL;
JSObject* JSB_CCProgressFromTo_object = NULL;
// Constructor
JSBool JSB_CCProgressFromTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCProgressFromTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCProgressFromTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCProgressFromTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCProgressFromTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCProgressFromTo *proxy = [[JSB_CCProgressFromTo alloc] initWithJSObject:obj class:[CCProgressFromTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCProgressFromTo* (o)
JSBool JSB_CCProgressFromTo_actionWithDuration_from_to__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressFromTo* ret_val;

	ret_val = [CCProgressFromTo actionWithDuration:(ccTime)arg0 from:(float)arg1 to:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCProgressFromTo_initWithDuration_from_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressFromTo *real = [(CCProgressFromTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 from:(float)arg1 to:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCProgressFromTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCProgressFromTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCProgressFromTo_class->name = name;
	JSB_CCProgressFromTo_class->addProperty = JS_PropertyStub;
	JSB_CCProgressFromTo_class->delProperty = JS_PropertyStub;
	JSB_CCProgressFromTo_class->getProperty = JS_PropertyStub;
	JSB_CCProgressFromTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCProgressFromTo_class->enumerate = JS_EnumerateStub;
	JSB_CCProgressFromTo_class->resolve = JS_ResolveStub;
	JSB_CCProgressFromTo_class->convert = JS_ConvertStub;
	JSB_CCProgressFromTo_class->finalize = JSB_CCProgressFromTo_finalize;
	JSB_CCProgressFromTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationFromTo", JSB_CCProgressFromTo_initWithDuration_from_to_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCProgressFromTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCProgressFromTo_actionWithDuration_from_to__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCProgressFromTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCProgressFromTo_class, JSB_CCProgressFromTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCProgressFromTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCProgressFromTo_class, JSB_CCProgressFromTo_object, NULL);
	JSB_CCProgressFromTo *proxy = [[JSB_CCProgressFromTo alloc] initWithJSObject:jsobj class:[CCProgressFromTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXObjectGroup
 */
#pragma mark - CCTMXObjectGroup

JSClass* JSB_CCTMXObjectGroup_class = NULL;
JSObject* JSB_CCTMXObjectGroup_object = NULL;
// Constructor
JSBool JSB_CCTMXObjectGroup_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTMXObjectGroup createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTMXObjectGroup_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTMXObjectGroup)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTMXObjectGroup_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTMXObjectGroup *proxy = [[JSB_CCTMXObjectGroup alloc] initWithJSObject:obj class:[CCTMXObjectGroup class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTMXObjectGroup_groupName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real groupName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXObjectGroup_objectNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSMutableDictionary* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real objectNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCTMXObjectGroup_objects(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real objects ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCTMXObjectGroup_positionOffset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real positionOffset ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXObjectGroup_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real properties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSObject* (o)
JSBool JSB_CCTMXObjectGroup_propertyNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSObject* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real propertyNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTMXObjectGroup_setGroupName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setGroupName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCTMXObjectGroup_setObjects_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setObjects:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCTMXObjectGroup_setPositionOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setPositionOffset:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXObjectGroup_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCTMXObjectGroup_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTMXObjectGroup_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTMXObjectGroup_class->name = name;
	JSB_CCTMXObjectGroup_class->addProperty = JS_PropertyStub;
	JSB_CCTMXObjectGroup_class->delProperty = JS_PropertyStub;
	JSB_CCTMXObjectGroup_class->getProperty = JS_PropertyStub;
	JSB_CCTMXObjectGroup_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTMXObjectGroup_class->enumerate = JS_EnumerateStub;
	JSB_CCTMXObjectGroup_class->resolve = JS_ResolveStub;
	JSB_CCTMXObjectGroup_class->convert = JS_ConvertStub;
	JSB_CCTMXObjectGroup_class->finalize = JSB_CCTMXObjectGroup_finalize;
	JSB_CCTMXObjectGroup_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getGroupName", JSB_CCTMXObjectGroup_groupName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("objectNamed", JSB_CCTMXObjectGroup_objectNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getObjects", JSB_CCTMXObjectGroup_objects, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPositionOffset", JSB_CCTMXObjectGroup_positionOffset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSB_CCTMXObjectGroup_properties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("propertyNamed", JSB_CCTMXObjectGroup_propertyNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGroupName", JSB_CCTMXObjectGroup_setGroupName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setObjects", JSB_CCTMXObjectGroup_setObjects_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPositionOffset", JSB_CCTMXObjectGroup_setPositionOffset_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSB_CCTMXObjectGroup_setProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTMXObjectGroup_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCTMXObjectGroup_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTMXObjectGroup_class, JSB_CCTMXObjectGroup_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTMXObjectGroup

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTMXObjectGroup_class, JSB_CCTMXObjectGroup_object, NULL);
	JSB_CCTMXObjectGroup *proxy = [[JSB_CCTMXObjectGroup alloc] initWithJSObject:jsobj class:[CCTMXObjectGroup class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMoveBy
 */
#pragma mark - CCMoveBy

JSClass* JSB_CCMoveBy_class = NULL;
JSObject* JSB_CCMoveBy_object = NULL;
// Constructor
JSBool JSB_CCMoveBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMoveBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMoveBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMoveBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMoveBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMoveBy *proxy = [[JSB_CCMoveBy alloc] initWithJSObject:obj class:[CCMoveBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: CCMoveBy* (o)
JSBool JSB_CCMoveBy_actionWithDuration_position__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMoveBy* ret_val;

	ret_val = [CCMoveBy actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: None (None)
JSBool JSB_CCMoveBy_initWithDuration_position_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMoveBy *real = [(CCMoveBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCMoveBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMoveBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMoveBy_class->name = name;
	JSB_CCMoveBy_class->addProperty = JS_PropertyStub;
	JSB_CCMoveBy_class->delProperty = JS_PropertyStub;
	JSB_CCMoveBy_class->getProperty = JS_PropertyStub;
	JSB_CCMoveBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMoveBy_class->enumerate = JS_EnumerateStub;
	JSB_CCMoveBy_class->resolve = JS_ResolveStub;
	JSB_CCMoveBy_class->convert = JS_ConvertStub;
	JSB_CCMoveBy_class->finalize = JSB_CCMoveBy_finalize;
	JSB_CCMoveBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPosition", JSB_CCMoveBy_initWithDuration_position_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMoveBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCMoveBy_actionWithDuration_position__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMoveBy_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCMoveBy_class, JSB_CCMoveBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMoveBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMoveBy_class, JSB_CCMoveBy_object, NULL);
	JSB_CCMoveBy *proxy = [[JSB_CCMoveBy alloc] initWithJSObject:jsobj class:[CCMoveBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCamera
 */
#pragma mark - CCCamera

JSClass* JSB_CCCamera_class = NULL;
JSObject* JSB_CCCamera_object = NULL;
// Constructor
JSBool JSB_CCCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCamera createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCamera_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCamera)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCamera_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCamera *proxy = [[JSB_CCCamera alloc] initWithJSObject:obj class:[CCCamera class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCCamera_dirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCCamera *real = (CCCamera*) [proxy realObj];
	ret_val = [real dirty ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCCamera_getZEye_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	ret_val = [CCCamera getZEye ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCCamera_locate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real locate ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCCamera_restore(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real restore ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSB_CCCamera_setCenterX_centerY_centerZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setCenterX:(float)arg0 centerY:(float)arg1 centerZ:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCCamera_setDirty_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setDirty:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSB_CCCamera_setEyeX_eyeY_eyeZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setEyeX:(float)arg0 eyeY:(float)arg1 eyeZ:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSB_CCCamera_setUpX_upY_upZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setUpX:(float)arg0 upY:(float)arg1 upZ:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCamera_class->name = name;
	JSB_CCCamera_class->addProperty = JS_PropertyStub;
	JSB_CCCamera_class->delProperty = JS_PropertyStub;
	JSB_CCCamera_class->getProperty = JS_PropertyStub;
	JSB_CCCamera_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCamera_class->enumerate = JS_EnumerateStub;
	JSB_CCCamera_class->resolve = JS_ResolveStub;
	JSB_CCCamera_class->convert = JS_ConvertStub;
	JSB_CCCamera_class->finalize = JSB_CCCamera_finalize;
	JSB_CCCamera_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDirty", JSB_CCCamera_dirty, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("locate", JSB_CCCamera_locate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("restore", JSB_CCCamera_restore, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCenter", JSB_CCCamera_setCenterX_centerY_centerZ_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDirty", JSB_CCCamera_setDirty_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEye", JSB_CCCamera_setEyeX_eyeY_eyeZ_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUp", JSB_CCCamera_setUpX_upY_upZ_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCamera_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("getZEye", JSB_CCCamera_getZEye_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCamera_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCCamera_class, JSB_CCCamera_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCamera_class, JSB_CCCamera_object, NULL);
	JSB_CCCamera *proxy = [[JSB_CCCamera alloc] initWithJSObject:jsobj class:[CCCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCReverseTime
 */
#pragma mark - CCReverseTime

JSClass* JSB_CCReverseTime_class = NULL;
JSObject* JSB_CCReverseTime_object = NULL;
// Constructor
JSBool JSB_CCReverseTime_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCReverseTime createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCReverseTime_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCReverseTime)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCReverseTime_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCReverseTime *proxy = [[JSB_CCReverseTime alloc] initWithJSObject:obj class:[CCReverseTime class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*
// Ret value: CCReverseTime* (o)
JSBool JSB_CCReverseTime_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCReverseTime* ret_val;

	ret_val = [CCReverseTime actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSB_CCReverseTime_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCReverseTime *real = [(CCReverseTime*)[proxy.klass alloc] initWithAction:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCReverseTime_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCReverseTime_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCReverseTime_class->name = name;
	JSB_CCReverseTime_class->addProperty = JS_PropertyStub;
	JSB_CCReverseTime_class->delProperty = JS_PropertyStub;
	JSB_CCReverseTime_class->getProperty = JS_PropertyStub;
	JSB_CCReverseTime_class->setProperty = JS_StrictPropertyStub;
	JSB_CCReverseTime_class->enumerate = JS_EnumerateStub;
	JSB_CCReverseTime_class->resolve = JS_ResolveStub;
	JSB_CCReverseTime_class->convert = JS_ConvertStub;
	JSB_CCReverseTime_class->finalize = JSB_CCReverseTime_finalize;
	JSB_CCReverseTime_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSB_CCReverseTime_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCReverseTime_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithAction", JSB_CCReverseTime_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCReverseTime_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCReverseTime_class, JSB_CCReverseTime_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCReverseTime

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCReverseTime_class, JSB_CCReverseTime_object, NULL);
	JSB_CCReverseTime *proxy = [[JSB_CCReverseTime alloc] initWithJSObject:jsobj class:[CCReverseTime class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionEase
 */
#pragma mark - CCActionEase

JSClass* JSB_CCActionEase_class = NULL;
JSObject* JSB_CCActionEase_object = NULL;
// Constructor
JSBool JSB_CCActionEase_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionEase createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionEase_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionEase)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionEase_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionEase *proxy = [[JSB_CCActionEase alloc] initWithJSObject:obj class:[CCActionEase class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionEase* (o)
JSBool JSB_CCActionEase_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionEase* ret_val;

	ret_val = [CCActionEase actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: None (None)
JSBool JSB_CCActionEase_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionEase *real = [(CCActionEase*)[proxy.klass alloc] initWithAction:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCActionEase_inner(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCActionEase *real = (CCActionEase*) [proxy realObj];
	ret_val = [real inner ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCActionEase_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionEase_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionEase_class->name = name;
	JSB_CCActionEase_class->addProperty = JS_PropertyStub;
	JSB_CCActionEase_class->delProperty = JS_PropertyStub;
	JSB_CCActionEase_class->getProperty = JS_PropertyStub;
	JSB_CCActionEase_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionEase_class->enumerate = JS_EnumerateStub;
	JSB_CCActionEase_class->resolve = JS_ResolveStub;
	JSB_CCActionEase_class->convert = JS_ConvertStub;
	JSB_CCActionEase_class->finalize = JSB_CCActionEase_finalize;
	JSB_CCActionEase_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSB_CCActionEase_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInner", JSB_CCActionEase_inner, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionEase_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithAction", JSB_CCActionEase_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCActionEase_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCActionEase_class, JSB_CCActionEase_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionEase

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionEase_class, JSB_CCActionEase_object, NULL);
	JSB_CCActionEase *proxy = [[JSB_CCActionEase alloc] initWithJSObject:jsobj class:[CCActionEase class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElastic
 */
#pragma mark - CCEaseElastic

JSClass* JSB_CCEaseElastic_class = NULL;
JSObject* JSB_CCEaseElastic_object = NULL;
// Constructor
JSBool JSB_CCEaseElastic_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseElastic createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseElastic_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseElastic)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseElastic_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseElastic *proxy = [[JSB_CCEaseElastic alloc] initWithJSObject:obj class:[CCEaseElastic class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElastic* (o)
JSBool JSB_CCEaseElastic_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseElastic* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElastic actionWithAction:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElastic actionWithAction:arg0 period:(float)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: None (None)
JSBool JSB_CCEaseElastic_initWithAction_period_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseElastic *real = [(CCEaseElastic*)[proxy.klass alloc] initWithAction:arg0 period:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCEaseElastic_period(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCEaseElastic *real = (CCEaseElastic*) [proxy realObj];
	ret_val = [real period ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCEaseElastic_setPeriod_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseElastic *real = (CCEaseElastic*) [proxy realObj];
	[real setPeriod:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCEaseElastic_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseElastic_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseElastic_class->name = name;
	JSB_CCEaseElastic_class->addProperty = JS_PropertyStub;
	JSB_CCEaseElastic_class->delProperty = JS_PropertyStub;
	JSB_CCEaseElastic_class->getProperty = JS_PropertyStub;
	JSB_CCEaseElastic_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseElastic_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseElastic_class->resolve = JS_ResolveStub;
	JSB_CCEaseElastic_class->convert = JS_ConvertStub;
	JSB_CCEaseElastic_class->finalize = JSB_CCEaseElastic_finalize;
	JSB_CCEaseElastic_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionPeriod", JSB_CCEaseElastic_initWithAction_period_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPeriod", JSB_CCEaseElastic_period, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPeriod", JSB_CCEaseElastic_setPeriod_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseElastic_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseElastic_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseElastic_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseElastic_class, JSB_CCEaseElastic_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseElastic

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseElastic_class, JSB_CCEaseElastic_object, NULL);
	JSB_CCEaseElastic *proxy = [[JSB_CCEaseElastic alloc] initWithJSObject:jsobj class:[CCEaseElastic class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticOut
 */
#pragma mark - CCEaseElasticOut

JSClass* JSB_CCEaseElasticOut_class = NULL;
JSObject* JSB_CCEaseElasticOut_object = NULL;
// Constructor
JSBool JSB_CCEaseElasticOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseElasticOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseElasticOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseElasticOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseElasticOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseElasticOut *proxy = [[JSB_CCEaseElasticOut alloc] initWithJSObject:obj class:[CCEaseElasticOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseElasticOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseElasticOut *real = (CCEaseElasticOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticOut* (o)
JSBool JSB_CCEaseElasticOut_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseElasticOut* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticOut actionWithAction:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticOut actionWithAction:arg0 period:(float)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseElasticOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseElasticOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseElasticOut_class->name = name;
	JSB_CCEaseElasticOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseElasticOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseElasticOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseElasticOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseElasticOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseElasticOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseElasticOut_class->convert = JS_ConvertStub;
	JSB_CCEaseElasticOut_class->finalize = JSB_CCEaseElasticOut_finalize;
	JSB_CCEaseElasticOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseElasticOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseElasticOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseElasticOut_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseElasticOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseElastic_object, JSB_CCEaseElasticOut_class, JSB_CCEaseElasticOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseElasticOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseElasticOut_class, JSB_CCEaseElasticOut_object, NULL);
	JSB_CCEaseElasticOut *proxy = [[JSB_CCEaseElasticOut alloc] initWithJSObject:jsobj class:[CCEaseElasticOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressTo
 */
#pragma mark - CCProgressTo

JSClass* JSB_CCProgressTo_class = NULL;
JSObject* JSB_CCProgressTo_object = NULL;
// Constructor
JSBool JSB_CCProgressTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCProgressTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCProgressTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCProgressTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCProgressTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCProgressTo *proxy = [[JSB_CCProgressTo alloc] initWithJSObject:obj class:[CCProgressTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: CCProgressTo* (o)
JSBool JSB_CCProgressTo_actionWithDuration_percent__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTo* ret_val;

	ret_val = [CCProgressTo actionWithDuration:(ccTime)arg0 percent:(float)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSB_CCProgressTo_initWithDuration_percent_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTo *real = [(CCProgressTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 percent:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCProgressTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCProgressTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCProgressTo_class->name = name;
	JSB_CCProgressTo_class->addProperty = JS_PropertyStub;
	JSB_CCProgressTo_class->delProperty = JS_PropertyStub;
	JSB_CCProgressTo_class->getProperty = JS_PropertyStub;
	JSB_CCProgressTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCProgressTo_class->enumerate = JS_EnumerateStub;
	JSB_CCProgressTo_class->resolve = JS_ResolveStub;
	JSB_CCProgressTo_class->convert = JS_ConvertStub;
	JSB_CCProgressTo_class->finalize = JSB_CCProgressTo_finalize;
	JSB_CCProgressTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPercent", JSB_CCProgressTo_initWithDuration_percent_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCProgressTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCProgressTo_actionWithDuration_percent__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCProgressTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCProgressTo_class, JSB_CCProgressTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCProgressTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCProgressTo_class, JSB_CCProgressTo_object, NULL);
	JSB_CCProgressTo *proxy = [[JSB_CCProgressTo alloc] initWithJSObject:jsobj class:[CCProgressTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScene
 */
#pragma mark - CCScene

JSClass* JSB_CCScene_class = NULL;
JSObject* JSB_CCScene_object = NULL;
// Constructor
JSBool JSB_CCScene_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCScene createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCScene_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCScene)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCScene_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCScene *proxy = [[JSB_CCScene alloc] initWithJSObject:obj class:[CCScene class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCScene_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCScene *real = [(CCScene*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScene* (o)
JSBool JSB_CCScene_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCScene* ret_val;

	ret_val = [CCScene node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCScene_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCScene_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCScene_class->name = name;
	JSB_CCScene_class->addProperty = JS_PropertyStub;
	JSB_CCScene_class->delProperty = JS_PropertyStub;
	JSB_CCScene_class->getProperty = JS_PropertyStub;
	JSB_CCScene_class->setProperty = JS_StrictPropertyStub;
	JSB_CCScene_class->enumerate = JS_EnumerateStub;
	JSB_CCScene_class->resolve = JS_ResolveStub;
	JSB_CCScene_class->convert = JS_ConvertStub;
	JSB_CCScene_class->finalize = JSB_CCScene_finalize;
	JSB_CCScene_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCScene_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCScene_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCScene_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCScene_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCScene_class, JSB_CCScene_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCScene

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCScene_class, JSB_CCScene_object, NULL);
	JSB_CCScene *proxy = [[JSB_CCScene alloc] initWithJSObject:jsobj class:[CCScene class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionInstant
 */
#pragma mark - CCActionInstant

JSClass* JSB_CCActionInstant_class = NULL;
JSObject* JSB_CCActionInstant_object = NULL;
// Constructor
JSBool JSB_CCActionInstant_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionInstant createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionInstant_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionInstant)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionInstant_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionInstant *proxy = [[JSB_CCActionInstant alloc] initWithJSObject:obj class:[CCActionInstant class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCActionInstant_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCActionInstant *real = [(CCActionInstant*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInstant* (o)
JSBool JSB_CCActionInstant_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInstant* ret_val;

	ret_val = [CCActionInstant action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCActionInstant_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionInstant_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionInstant_class->name = name;
	JSB_CCActionInstant_class->addProperty = JS_PropertyStub;
	JSB_CCActionInstant_class->delProperty = JS_PropertyStub;
	JSB_CCActionInstant_class->getProperty = JS_PropertyStub;
	JSB_CCActionInstant_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionInstant_class->enumerate = JS_EnumerateStub;
	JSB_CCActionInstant_class->resolve = JS_ResolveStub;
	JSB_CCActionInstant_class->convert = JS_ConvertStub;
	JSB_CCActionInstant_class->finalize = JSB_CCActionInstant_finalize;
	JSB_CCActionInstant_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCActionInstant_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionInstant_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSB_CCActionInstant_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCActionInstant_object = JS_InitClass(cx, globalObj, JSB_CCFiniteTimeAction_object, JSB_CCActionInstant_class, JSB_CCActionInstant_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionInstant

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionInstant_class, JSB_CCActionInstant_object, NULL);
	JSB_CCActionInstant *proxy = [[JSB_CCActionInstant alloc] initWithJSObject:jsobj class:[CCActionInstant class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipX
 */
#pragma mark - CCFlipX

JSClass* JSB_CCFlipX_class = NULL;
JSObject* JSB_CCFlipX_object = NULL;
// Constructor
JSBool JSB_CCFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFlipX createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFlipX_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFlipX)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFlipX_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFlipX *proxy = [[JSB_CCFlipX alloc] initWithJSObject:obj class:[CCFlipX class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: CCFlipX* (o)
JSBool JSB_CCFlipX_actionWithFlipX__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFlipX* ret_val;

	ret_val = [CCFlipX actionWithFlipX:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: None (None)
JSBool JSB_CCFlipX_initWithFlipX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFlipX *real = [(CCFlipX*)[proxy.klass alloc] initWithFlipX:(BOOL)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFlipX_class->name = name;
	JSB_CCFlipX_class->addProperty = JS_PropertyStub;
	JSB_CCFlipX_class->delProperty = JS_PropertyStub;
	JSB_CCFlipX_class->getProperty = JS_PropertyStub;
	JSB_CCFlipX_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFlipX_class->enumerate = JS_EnumerateStub;
	JSB_CCFlipX_class->resolve = JS_ResolveStub;
	JSB_CCFlipX_class->convert = JS_ConvertStub;
	JSB_CCFlipX_class->finalize = JSB_CCFlipX_finalize;
	JSB_CCFlipX_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithFlipX", JSB_CCFlipX_initWithFlipX_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFlipX_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFlipX_actionWithFlipX__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFlipX_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCFlipX_class, JSB_CCFlipX_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFlipX_class, JSB_CCFlipX_object, NULL);
	JSB_CCFlipX *proxy = [[JSB_CCFlipX alloc] initWithJSObject:jsobj class:[CCFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipY
 */
#pragma mark - CCFlipY

JSClass* JSB_CCFlipY_class = NULL;
JSObject* JSB_CCFlipY_object = NULL;
// Constructor
JSBool JSB_CCFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFlipY createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFlipY_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFlipY)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFlipY_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFlipY *proxy = [[JSB_CCFlipY alloc] initWithJSObject:obj class:[CCFlipY class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: CCFlipY* (o)
JSBool JSB_CCFlipY_actionWithFlipY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFlipY* ret_val;

	ret_val = [CCFlipY actionWithFlipY:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: None (None)
JSBool JSB_CCFlipY_initWithFlipY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFlipY *real = [(CCFlipY*)[proxy.klass alloc] initWithFlipY:(BOOL)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFlipY_class->name = name;
	JSB_CCFlipY_class->addProperty = JS_PropertyStub;
	JSB_CCFlipY_class->delProperty = JS_PropertyStub;
	JSB_CCFlipY_class->getProperty = JS_PropertyStub;
	JSB_CCFlipY_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFlipY_class->enumerate = JS_EnumerateStub;
	JSB_CCFlipY_class->resolve = JS_ResolveStub;
	JSB_CCFlipY_class->convert = JS_ConvertStub;
	JSB_CCFlipY_class->finalize = JSB_CCFlipY_finalize;
	JSB_CCFlipY_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithFlipY", JSB_CCFlipY_initWithFlipY_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFlipY_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFlipY_actionWithFlipY__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFlipY_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCFlipY_class, JSB_CCFlipY_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFlipY_class, JSB_CCFlipY_object, NULL);
	JSB_CCFlipY *proxy = [[JSB_CCFlipY alloc] initWithJSObject:jsobj class:[CCFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGridAction
 */
#pragma mark - CCGridAction

JSClass* JSB_CCGridAction_class = NULL;
JSObject* JSB_CCGridAction_object = NULL;
// Constructor
JSBool JSB_CCGridAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGridAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGridAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGridAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGridAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGridAction *proxy = [[JSB_CCGridAction alloc] initWithJSObject:obj class:[CCGridAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCGridAction* (o)
JSBool JSB_CCGridAction_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGridAction* ret_val;

	ret_val = [CCGridAction actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGridBase* (o)
JSBool JSB_CCGridAction_grid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGridBase* ret_val;

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	ret_val = [real grid ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCGridAction_gridSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	ret_val = [real gridSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: None (None)
JSBool JSB_CCGridAction_initWithDuration_size_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridAction *real = [(CCGridAction*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCGridAction_setGridSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	[real setGridSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCGridAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGridAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGridAction_class->name = name;
	JSB_CCGridAction_class->addProperty = JS_PropertyStub;
	JSB_CCGridAction_class->delProperty = JS_PropertyStub;
	JSB_CCGridAction_class->getProperty = JS_PropertyStub;
	JSB_CCGridAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGridAction_class->enumerate = JS_EnumerateStub;
	JSB_CCGridAction_class->resolve = JS_ResolveStub;
	JSB_CCGridAction_class->convert = JS_ConvertStub;
	JSB_CCGridAction_class->finalize = JSB_CCGridAction_finalize;
	JSB_CCGridAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("grid", JSB_CCGridAction_grid, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGridSize", JSB_CCGridAction_gridSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSize", JSB_CCGridAction_initWithDuration_size_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGridSize", JSB_CCGridAction_setGridSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGridAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationSize", JSB_CCGridAction_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCGridAction_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCGridAction_class, JSB_CCGridAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGridAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGridAction_class, JSB_CCGridAction_object, NULL);
	JSB_CCGridAction *proxy = [[JSB_CCGridAction alloc] initWithJSObject:jsobj class:[CCGridAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTiledGrid3DAction
 */
#pragma mark - CCTiledGrid3DAction

JSClass* JSB_CCTiledGrid3DAction_class = NULL;
JSObject* JSB_CCTiledGrid3DAction_object = NULL;
// Constructor
JSBool JSB_CCTiledGrid3DAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTiledGrid3DAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTiledGrid3DAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTiledGrid3DAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTiledGrid3DAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTiledGrid3DAction *proxy = [[JSB_CCTiledGrid3DAction alloc] initWithJSObject:obj class:[CCTiledGrid3DAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCTiledGrid3DAction* (o)
JSBool JSB_CCTiledGrid3DAction_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTiledGrid3DAction* ret_val;

	ret_val = [CCTiledGrid3DAction actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTiledGrid3DAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTiledGrid3DAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTiledGrid3DAction_class->name = name;
	JSB_CCTiledGrid3DAction_class->addProperty = JS_PropertyStub;
	JSB_CCTiledGrid3DAction_class->delProperty = JS_PropertyStub;
	JSB_CCTiledGrid3DAction_class->getProperty = JS_PropertyStub;
	JSB_CCTiledGrid3DAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTiledGrid3DAction_class->enumerate = JS_EnumerateStub;
	JSB_CCTiledGrid3DAction_class->resolve = JS_ResolveStub;
	JSB_CCTiledGrid3DAction_class->convert = JS_ConvertStub;
	JSB_CCTiledGrid3DAction_class->finalize = JSB_CCTiledGrid3DAction_finalize;
	JSB_CCTiledGrid3DAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("ctor", JSB_CCTiledGrid3DAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationSize", JSB_CCTiledGrid3DAction_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTiledGrid3DAction_object = JS_InitClass(cx, globalObj, JSB_CCGridAction_object, JSB_CCTiledGrid3DAction_class, JSB_CCTiledGrid3DAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTiledGrid3DAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTiledGrid3DAction_class, JSB_CCTiledGrid3DAction_object, NULL);
	JSB_CCTiledGrid3DAction *proxy = [[JSB_CCTiledGrid3DAction alloc] initWithJSObject:jsobj class:[CCTiledGrid3DAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShakyTiles3D
 */
#pragma mark - CCShakyTiles3D

JSClass* JSB_CCShakyTiles3D_class = NULL;
JSObject* JSB_CCShakyTiles3D_object = NULL;
// Constructor
JSBool JSB_CCShakyTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShakyTiles3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShakyTiles3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShakyTiles3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShakyTiles3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShakyTiles3D *proxy = [[JSB_CCShakyTiles3D alloc] initWithJSObject:obj class:[CCShakyTiles3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: CCShakyTiles3D* (o)
JSBool JSB_CCShakyTiles3D_actionWithDuration_size_range_shakeZ__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCShakyTiles3D* ret_val;

	ret_val = [CCShakyTiles3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shakeZ:(BOOL)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: None (None)
JSBool JSB_CCShakyTiles3D_initWithDuration_size_range_shakeZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShakyTiles3D *real = [(CCShakyTiles3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shakeZ:(BOOL)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCShakyTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShakyTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShakyTiles3D_class->name = name;
	JSB_CCShakyTiles3D_class->addProperty = JS_PropertyStub;
	JSB_CCShakyTiles3D_class->delProperty = JS_PropertyStub;
	JSB_CCShakyTiles3D_class->getProperty = JS_PropertyStub;
	JSB_CCShakyTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShakyTiles3D_class->enumerate = JS_EnumerateStub;
	JSB_CCShakyTiles3D_class->resolve = JS_ResolveStub;
	JSB_CCShakyTiles3D_class->convert = JS_ConvertStub;
	JSB_CCShakyTiles3D_class->finalize = JSB_CCShakyTiles3D_finalize;
	JSB_CCShakyTiles3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizeRangeShakeZ", JSB_CCShakyTiles3D_initWithDuration_size_range_shakeZ_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShakyTiles3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCShakyTiles3D_actionWithDuration_size_range_shakeZ__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShakyTiles3D_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCShakyTiles3D_class, JSB_CCShakyTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShakyTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShakyTiles3D_class, JSB_CCShakyTiles3D_object, NULL);
	JSB_CCShakyTiles3D *proxy = [[JSB_CCShakyTiles3D alloc] initWithJSObject:jsobj class:[CCShakyTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpBy
 */
#pragma mark - CCJumpBy

JSClass* JSB_CCJumpBy_class = NULL;
JSObject* JSB_CCJumpBy_object = NULL;
// Constructor
JSBool JSB_CCJumpBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCJumpBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCJumpBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCJumpBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCJumpBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCJumpBy *proxy = [[JSB_CCJumpBy alloc] initWithJSObject:obj class:[CCJumpBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: CCJumpBy* (o)
JSBool JSB_CCJumpBy_actionWithDuration_position_height_jumps__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCJumpBy* ret_val;

	ret_val = [CCJumpBy actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: None (None)
JSBool JSB_CCJumpBy_initWithDuration_position_height_jumps_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCJumpBy *real = [(CCJumpBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCJumpBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCJumpBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCJumpBy_class->name = name;
	JSB_CCJumpBy_class->addProperty = JS_PropertyStub;
	JSB_CCJumpBy_class->delProperty = JS_PropertyStub;
	JSB_CCJumpBy_class->getProperty = JS_PropertyStub;
	JSB_CCJumpBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCJumpBy_class->enumerate = JS_EnumerateStub;
	JSB_CCJumpBy_class->resolve = JS_ResolveStub;
	JSB_CCJumpBy_class->convert = JS_ConvertStub;
	JSB_CCJumpBy_class->finalize = JSB_CCJumpBy_finalize;
	JSB_CCJumpBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPositionHeightJumps", JSB_CCJumpBy_initWithDuration_position_height_jumps_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCJumpBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCJumpBy_actionWithDuration_position_height_jumps__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCJumpBy_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCJumpBy_class, JSB_CCJumpBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCJumpBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCJumpBy_class, JSB_CCJumpBy_object, NULL);
	JSB_CCJumpBy *proxy = [[JSB_CCJumpBy alloc] initWithJSObject:jsobj class:[CCJumpBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCNodeRGBA
 */
#pragma mark - CCNodeRGBA

JSClass* JSB_CCNodeRGBA_class = NULL;
JSObject* JSB_CCNodeRGBA_object = NULL;
// Constructor
JSBool JSB_CCNodeRGBA_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCNodeRGBA createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCNodeRGBA_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCNodeRGBA)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCNodeRGBA_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCNodeRGBA *proxy = [[JSB_CCNodeRGBA alloc] initWithJSObject:obj class:[CCNodeRGBA class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCNodeRGBA_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCNodeRGBA_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCNodeRGBA_displayedColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real displayedColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCNodeRGBA_displayedOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real displayedOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNodeRGBA_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNodeRGBA_isCascadeColorEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real isCascadeColorEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCNodeRGBA_isCascadeOpacityEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	ret_val = [real isCascadeOpacityEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_setCascadeColorEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real setCascadeColorEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_setCascadeOpacityEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real setCascadeOpacityEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_updateDisplayedColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real updateDisplayedColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCNodeRGBA_updateDisplayedOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCNodeRGBA *real = (CCNodeRGBA*) [proxy realObj];
	[real updateDisplayedOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNodeRGBA* (o)
JSBool JSB_CCNodeRGBA_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNodeRGBA* ret_val;

	ret_val = [CCNodeRGBA node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCNodeRGBA_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCNodeRGBA_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCNodeRGBA_class->name = name;
	JSB_CCNodeRGBA_class->addProperty = JS_PropertyStub;
	JSB_CCNodeRGBA_class->delProperty = JS_PropertyStub;
	JSB_CCNodeRGBA_class->getProperty = JS_PropertyStub;
	JSB_CCNodeRGBA_class->setProperty = JS_StrictPropertyStub;
	JSB_CCNodeRGBA_class->enumerate = JS_EnumerateStub;
	JSB_CCNodeRGBA_class->resolve = JS_ResolveStub;
	JSB_CCNodeRGBA_class->convert = JS_ConvertStub;
	JSB_CCNodeRGBA_class->finalize = JSB_CCNodeRGBA_finalize;
	JSB_CCNodeRGBA_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getOpacity", JSB_CCNodeRGBA_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getColor", JSB_CCNodeRGBA_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedColor", JSB_CCNodeRGBA_displayedColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedOpacity", JSB_CCNodeRGBA_displayedOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCNodeRGBA_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeColorEnabled", JSB_CCNodeRGBA_isCascadeColorEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeOpacityEnabled", JSB_CCNodeRGBA_isCascadeOpacityEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeColorEnabled", JSB_CCNodeRGBA_setCascadeColorEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeOpacityEnabled", JSB_CCNodeRGBA_setCascadeOpacityEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCNodeRGBA_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCNodeRGBA_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCNodeRGBA_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedColor", JSB_CCNodeRGBA_updateDisplayedColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedOpacity", JSB_CCNodeRGBA_updateDisplayedOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCNodeRGBA_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCNodeRGBA_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCNodeRGBA_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCNodeRGBA_class, JSB_CCNodeRGBA_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCNodeRGBA

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCNodeRGBA_class, JSB_CCNodeRGBA_object, NULL);
	JSB_CCNodeRGBA *proxy = [[JSB_CCNodeRGBA alloc] initWithJSObject:jsobj class:[CCNodeRGBA class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSprite
 */
#pragma mark - CCSprite

JSClass* JSB_CCSprite_class = NULL;
JSObject* JSB_CCSprite_object = NULL;
// Constructor
JSBool JSB_CCSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSprite createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSprite_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSprite)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSprite_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSprite *proxy = [[JSB_CCSprite alloc] initWithJSObject:obj class:[CCSprite class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCSprite_atlasIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real atlasIndex ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteBatchNode* (o)
JSBool JSB_CCSprite_batchNode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSpriteBatchNode* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real batchNode ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCSprite_dirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real dirty ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrame* (o)
JSBool JSB_CCSprite_displayFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSpriteFrame* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real displayFrame ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCSprite_flipX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real flipX ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCSprite_flipY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real flipY ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: None (None)
JSBool JSB_CCSprite_initWithFile_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else if( argc == 2 ) {
		CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: None (None)
JSBool JSB_CCSprite_initWithSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithSpriteFrame:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCSprite_initWithSpriteFrameName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithSpriteFrameName:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: None (None)
JSBool JSB_CCSprite_initWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else if( argc == 2 ) {
		CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL
// Ret value: None (None)
JSBool JSB_CCSprite_initWithTexture_rect_rotated_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:arg0 rect:(CGRect)arg1 rotated:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: BOOL (b)
JSBool JSB_CCSprite_isFrameDisplayed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real isFrameDisplayed:arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCSprite_offsetPosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real offsetPosition ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCSprite_setAtlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setAtlasIndex:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteBatchNode*
// Ret value: void (None)
JSBool JSB_CCSprite_setBatchNode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setBatchNode:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCSprite_setDirty_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDirty:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCSprite_setDisplayFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDisplayFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, int
// Ret value: void (None)
JSBool JSB_CCSprite_setDisplayFrameWithAnimationName_index_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; int32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDisplayFrameWithAnimationName:(NSString*)arg0 index:(int)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCSprite_setFlipX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setFlipX:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCSprite_setFlipY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setFlipY:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSB_CCSprite_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureAtlas:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect, BOOL, CGSize
// Ret value: void (None)
JSBool JSB_CCSprite_setTextureRect_rotated_untrimmedSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; JSBool arg1; CGSize arg2; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureRect:(CGRect)arg0  ];
	}
	else if( argc == 3 ) {
		CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureRect:(CGRect)arg0 rotated:(BOOL)arg1 untrimmedSize:(CGSize)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCSprite_setVertexRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setVertexRect:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: CCSprite* (o)
JSBool JSB_CCSprite_spriteWithFile_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSprite* ret_val;

	if( argc == 0 ) {
		ret_val = [CCSprite node ];
	}
	else if( argc == 1 ) {
		ret_val = [CCSprite spriteWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSprite spriteWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: CCSprite* (o)
JSBool JSB_CCSprite_spriteWithSpriteFrame__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSprite* ret_val;

	ret_val = [CCSprite spriteWithSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCSprite* (o)
JSBool JSB_CCSprite_spriteWithSpriteFrameName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSprite* ret_val;

	ret_val = [CCSprite spriteWithSpriteFrameName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: CCSprite* (o)
JSBool JSB_CCSprite_spriteWithTexture_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSprite* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSprite spriteWithTexture:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSprite spriteWithTexture:arg0 rect:(CGRect)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCSprite_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSB_CCSprite_textureRect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGRect ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureRect ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGRect( cx, (CGRect)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCSprite_textureRectRotated(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureRectRotated ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCSprite_updateTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real updateTransform ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCSprite_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCSprite_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSprite_class->name = name;
	JSB_CCSprite_class->addProperty = JS_PropertyStub;
	JSB_CCSprite_class->delProperty = JS_PropertyStub;
	JSB_CCSprite_class->getProperty = JS_PropertyStub;
	JSB_CCSprite_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSprite_class->enumerate = JS_EnumerateStub;
	JSB_CCSprite_class->resolve = JS_ResolveStub;
	JSB_CCSprite_class->convert = JS_ConvertStub;
	JSB_CCSprite_class->finalize = JSB_CCSprite_finalize;
	JSB_CCSprite_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAtlasIndex", JSB_CCSprite_atlasIndex, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getBatchNode", JSB_CCSprite_batchNode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDirty", JSB_CCSprite_dirty, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("displayFrame", JSB_CCSprite_displayFrame, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFlippedX", JSB_CCSprite_flipX, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFlippedY", JSB_CCSprite_flipY, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCSprite_initWithFile_rect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrame", JSB_CCSprite_initWithSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrameName", JSB_CCSprite_initWithSpriteFrameName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTexture", JSB_CCSprite_initWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureRectRotated", JSB_CCSprite_initWithTexture_rect_rotated_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFrameDisplayed", JSB_CCSprite_isFrameDisplayed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOffsetPosition", JSB_CCSprite_offsetPosition, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAtlasIndex", JSB_CCSprite_setAtlasIndex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBatchNode", JSB_CCSprite_setBatchNode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCSprite_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDirty", JSB_CCSprite_setDirty_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrame", JSB_CCSprite_setDisplayFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrameWithAnimationNameIndex", JSB_CCSprite_setDisplayFrameWithAnimationName_index_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFlipX", JSB_CCSprite_setFlipX_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFlipY", JSB_CCSprite_setFlipY_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSB_CCSprite_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureRect", JSB_CCSprite_setTextureRect_rotated_untrimmedSize_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVertexRect", JSB_CCSprite_setVertexRect_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSB_CCSprite_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureRect", JSB_CCSprite_textureRect, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureRectRotated", JSB_CCSprite_textureRectRotated, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateTransform", JSB_CCSprite_updateTransform, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCSprite_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCSprite_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSprite_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSprite_spriteWithFile_rect__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrame", JSB_CCSprite_spriteWithSpriteFrame__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrameName", JSB_CCSprite_spriteWithSpriteFrameName__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithTexture", JSB_CCSprite_spriteWithTexture_rect__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSprite_object = JS_InitClass(cx, globalObj, JSB_CCNodeRGBA_object, JSB_CCSprite_class, JSB_CCSprite_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSprite_class, JSB_CCSprite_object, NULL);
	JSB_CCSprite *proxy = [[JSB_CCSprite alloc] initWithJSObject:jsobj class:[CCSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelTTF
 */
#pragma mark - CCLabelTTF

JSClass* JSB_CCLabelTTF_class = NULL;
JSObject* JSB_CCLabelTTF_object = NULL;
// Constructor
JSBool JSB_CCLabelTTF_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLabelTTF createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLabelTTF_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLabelTTF)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLabelTTF_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLabelTTF *proxy = [[JSB_CCLabelTTF alloc] initWithJSObject:obj class:[CCLabelTTF class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCLabelTTF_dimensions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real dimensions ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: Boolean
// Ret value: void (None)
JSBool JSB_CCLabelTTF_disableShadowAndUpdateImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real disableShadowAndUpdateImage:(Boolean)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: Boolean
// Ret value: void (None)
JSBool JSB_CCLabelTTF_disableStrokeAndUpdateImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real disableStrokeAndUpdateImage:(Boolean)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize, float, float, Boolean
// Ret value: void (None)
JSBool JSB_CCLabelTTF_enableShadowWithOffset_opacity_blur_updateImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; double arg1; double arg2; JSBool arg3; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real enableShadowWithOffset:(CGSize)arg0 opacity:(float)arg1 blur:(float)arg2 updateImage:(Boolean)arg3  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B, float, Boolean
// Ret value: void (None)
JSBool JSB_CCLabelTTF_enableStrokeWithColor_size_updateImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; double arg1; JSBool arg2; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real enableStrokeWithColor:(ccColor3B)arg0 size:(float)arg1 updateImage:(Boolean)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCLabelTTF_fontName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real fontName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCLabelTTF_fontSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real fontSize ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextAlignment (i)
JSBool JSB_CCLabelTTF_horizontalAlignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextAlignment ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real horizontalAlignment ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, CCFontDefinition*
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontDefinition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CCFontDefinition* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CCFontDefinition( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontDefinition:(CCFontDefinition*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCLineBreakMode
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_lineBreakMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 lineBreakMode:(CCLineBreakMode)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCVerticalTextAlignment
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode
// Ret value: None (None)
JSBool JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 7, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; int32_t arg6; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg6 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5 lineBreakMode:(CCLineBreakMode)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, CCFontDefinition*
// Ret value: CCLabelTTF* (o)
JSBool JSB_CCLabelTTF_labelWithString_fontDefinition__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CCFontDefinition* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CCFontDefinition( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontDefinition:(CCFontDefinition*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCLineBreakMode
// Ret value: CCLabelTTF* (o)
JSBool JSB_CCLabelTTF_labelWithString_fontName_fontSize_dimensions_hAlignment_lineBreakMode__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 lineBreakMode:(CCLineBreakMode)arg5  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode
// Ret value: CCLabelTTF* (o)
JSBool JSB_CCLabelTTF_labelWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 7 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; int32_t arg6; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	}
	if (argc >= 5) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	}
	if (argc >= 6) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	}
	if (argc >= 7) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg6 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLabelTTF* ret_val;

	if( argc == 0 ) {
		ret_val = [CCLabelTTF node ];
	}
	else if( argc == 3 ) {
		ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];
	}
	else if( argc == 5 ) {
		ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4  ];
	}
	else if( argc == 6 ) {
		ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5  ];
	}
	else if( argc == 7 ) {
		ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5 lineBreakMode:(CCLineBreakMode)arg6  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setDimensions_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setDimensions:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCFontDefinition*
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setFontDefinition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CCFontDefinition* arg0; 

	ok &= JSB_jsval_to_CCFontDefinition( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontDefinition:(CCFontDefinition*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B, Boolean
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setFontFillColor_updateImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; JSBool arg1; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontFillColor:(ccColor3B)arg0 updateImage:(Boolean)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setFontName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setFontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontSize:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextAlignment
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setHorizontalAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setHorizontalAlignment:(CCTextAlignment)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setString:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCVerticalTextAlignment
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setVerticalAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setVerticalAlignment:(CCVerticalTextAlignment)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCVerticalTextAlignment (i)
JSBool JSB_CCLabelTTF_verticalAlignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCVerticalTextAlignment ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real verticalAlignment ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: char*
// Ret value: void (None)
JSBool JSB_CCLabelTTF_setCString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	const char* arg0; 

	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setCString:(char*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCLabelTTF_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real string ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_CCLabelTTF_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLabelTTF_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLabelTTF_class->name = name;
	JSB_CCLabelTTF_class->addProperty = JS_PropertyStub;
	JSB_CCLabelTTF_class->delProperty = JS_PropertyStub;
	JSB_CCLabelTTF_class->getProperty = JS_PropertyStub;
	JSB_CCLabelTTF_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLabelTTF_class->enumerate = JS_EnumerateStub;
	JSB_CCLabelTTF_class->resolve = JS_ResolveStub;
	JSB_CCLabelTTF_class->convert = JS_ConvertStub;
	JSB_CCLabelTTF_class->finalize = JSB_CCLabelTTF_finalize;
	JSB_CCLabelTTF_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDimensions", JSB_CCLabelTTF_dimensions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("disableShadowAndUpdateImage", JSB_CCLabelTTF_disableShadowAndUpdateImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("disableStrokeAndUpdateImage", JSB_CCLabelTTF_disableStrokeAndUpdateImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableShadowWithOffsetOpacityBlurUpdateImage", JSB_CCLabelTTF_enableShadowWithOffset_opacity_blur_updateImage_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("enableStrokeWithColorSizeUpdateImage", JSB_CCLabelTTF_enableStrokeWithColor_size_updateImage_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFontName", JSB_CCLabelTTF_fontName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFontSize", JSB_CCLabelTTF_fontSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getHorizontalAlignment", JSB_CCLabelTTF_horizontalAlignment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontDefinition", JSB_CCLabelTTF_initWithString_fontDefinition_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSize", JSB_CCLabelTTF_initWithString_fontName_fontSize_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignment", JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignmentLineBreakMode", JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_lineBreakMode_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignmentVAlignment", JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignmentVAlignmentLineBreakMode", JSB_CCLabelTTF_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode_, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDimensions", JSB_CCLabelTTF_setDimensions_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontDefinition", JSB_CCLabelTTF_setFontDefinition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontFillColorUpdateImage", JSB_CCLabelTTF_setFontFillColor_updateImage_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSB_CCLabelTTF_setFontName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSB_CCLabelTTF_setFontSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setHorizontalAlignment", JSB_CCLabelTTF_setHorizontalAlignment_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setString", JSB_CCLabelTTF_setString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVerticalAlignment", JSB_CCLabelTTF_setVerticalAlignment_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVerticalAlignment", JSB_CCLabelTTF_verticalAlignment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCString", JSB_CCLabelTTF_setCString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getString", JSB_CCLabelTTF_string, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLabelTTF_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("createWithFontDefinition", JSB_CCLabelTTF_labelWithString_fontDefinition__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("labelWithStringFontNameFontSizeDimensionsHAlignmentLineBreakMode", JSB_CCLabelTTF_labelWithString_fontName_fontSize_dimensions_hAlignment_lineBreakMode__static, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCLabelTTF_labelWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode__static, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLabelTTF_object = JS_InitClass(cx, globalObj, JSB_CCSprite_object, JSB_CCLabelTTF_class, JSB_CCLabelTTF_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLabelTTF

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLabelTTF_class, JSB_CCLabelTTF_object, NULL);
	JSB_CCLabelTTF *proxy = [[JSB_CCLabelTTF alloc] initWithJSObject:jsobj class:[CCLabelTTF class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionScene
 */
#pragma mark - CCTransitionScene

JSClass* JSB_CCTransitionScene_class = NULL;
JSObject* JSB_CCTransitionScene_object = NULL;
// Constructor
JSBool JSB_CCTransitionScene_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionScene createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionScene_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionScene)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionScene_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionScene *proxy = [[JSB_CCTransitionScene alloc] initWithJSObject:obj class:[CCTransitionScene class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionScene_finish(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionScene *real = (CCTransitionScene*) [proxy realObj];
	[real finish ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionScene_hideOutShowIn(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionScene *real = (CCTransitionScene*) [proxy realObj];
	[real hideOutShowIn ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: None (None)
JSBool JSB_CCTransitionScene_initWithDuration_scene_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTransitionScene *real = [(CCTransitionScene*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionScene* (o)
JSBool JSB_CCTransitionScene_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionScene* ret_val;

	ret_val = [CCTransitionScene transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionScene* (o)
JSBool JSB_CCTransitionScene_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionScene* ret_val;

	ret_val = [CCTransitionScene node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionScene_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionScene_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionScene_class->name = name;
	JSB_CCTransitionScene_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionScene_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionScene_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionScene_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionScene_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionScene_class->resolve = JS_ResolveStub;
	JSB_CCTransitionScene_class->convert = JS_ConvertStub;
	JSB_CCTransitionScene_class->finalize = JSB_CCTransitionScene_finalize;
	JSB_CCTransitionScene_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("finish", JSB_CCTransitionScene_finish, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("hideOutShowIn", JSB_CCTransitionScene_hideOutShowIn, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationScene", JSB_CCTransitionScene_initWithDuration_scene_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionScene_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionScene_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionScene_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionScene_object = JS_InitClass(cx, globalObj, JSB_CCScene_object, JSB_CCTransitionScene_class, JSB_CCTransitionScene_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionScene

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionScene_class, JSB_CCTransitionScene_object, NULL);
	JSB_CCTransitionScene *proxy = [[JSB_CCTransitionScene alloc] initWithJSObject:jsobj class:[CCTransitionScene class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgress
 */
#pragma mark - CCTransitionProgress

JSClass* JSB_CCTransitionProgress_class = NULL;
JSObject* JSB_CCTransitionProgress_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgress_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgress createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgress_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgress)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgress_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgress *proxy = [[JSB_CCTransitionProgress alloc] initWithJSObject:obj class:[CCTransitionProgress class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgress_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgress *real = (CCTransitionProgress*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgress* (o)
JSBool JSB_CCTransitionProgress_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgress* ret_val;

	ret_val = [CCTransitionProgress transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgress* (o)
JSBool JSB_CCTransitionProgress_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgress* ret_val;

	ret_val = [CCTransitionProgress node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgress_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgress_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgress_class->name = name;
	JSB_CCTransitionProgress_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgress_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgress_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgress_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgress_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgress_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgress_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgress_class->finalize = JSB_CCTransitionProgress_finalize;
	JSB_CCTransitionProgress_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgress_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgress_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgress_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgress_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgress_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionProgress_class, JSB_CCTransitionProgress_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgress

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgress_class, JSB_CCTransitionProgress_object, NULL);
	JSB_CCTransitionProgress *proxy = [[JSB_CCTransitionProgress alloc] initWithJSObject:jsobj class:[CCTransitionProgress class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressRadialCCW
 */
#pragma mark - CCTransitionProgressRadialCCW

JSClass* JSB_CCTransitionProgressRadialCCW_class = NULL;
JSObject* JSB_CCTransitionProgressRadialCCW_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressRadialCCW_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressRadialCCW createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressRadialCCW_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressRadialCCW)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressRadialCCW_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressRadialCCW *proxy = [[JSB_CCTransitionProgressRadialCCW alloc] initWithJSObject:obj class:[CCTransitionProgressRadialCCW class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressRadialCCW *real = (CCTransitionProgressRadialCCW*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressRadialCCW* (o)
JSBool JSB_CCTransitionProgressRadialCCW_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressRadialCCW* ret_val;

	ret_val = [CCTransitionProgressRadialCCW transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressRadialCCW* (o)
JSBool JSB_CCTransitionProgressRadialCCW_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressRadialCCW* ret_val;

	ret_val = [CCTransitionProgressRadialCCW node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressRadialCCW_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressRadialCCW_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressRadialCCW_class->name = name;
	JSB_CCTransitionProgressRadialCCW_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCCW_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCCW_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCCW_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressRadialCCW_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressRadialCCW_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressRadialCCW_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressRadialCCW_class->finalize = JSB_CCTransitionProgressRadialCCW_finalize;
	JSB_CCTransitionProgressRadialCCW_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressRadialCCW_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressRadialCCW_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressRadialCCW_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressRadialCCW_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressRadialCCW_class, JSB_CCTransitionProgressRadialCCW_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressRadialCCW

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressRadialCCW_class, JSB_CCTransitionProgressRadialCCW_object, NULL);
	JSB_CCTransitionProgressRadialCCW *proxy = [[JSB_CCTransitionProgressRadialCCW alloc] initWithJSObject:jsobj class:[CCTransitionProgressRadialCCW class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShaderCache
 */
#pragma mark - CCShaderCache

JSClass* JSB_CCShaderCache_class = NULL;
JSObject* JSB_CCShaderCache_object = NULL;
// Constructor
JSBool JSB_CCShaderCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShaderCache createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShaderCache_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShaderCache)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShaderCache_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShaderCache *proxy = [[JSB_CCShaderCache alloc] initWithJSObject:obj class:[CCShaderCache class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCGLProgram*, NSString*
// Ret value: void (None)
JSBool JSB_CCShaderCache_addProgram_forKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	[real addProgram:arg0 forKey:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCShaderCache_loadDefaultShaders(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	[real loadDefaultShaders ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCGLProgram* (o)
JSBool JSB_CCShaderCache_programForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGLProgram* ret_val;

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	ret_val = [real programForKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCShaderCache_purgeSharedShaderCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[CCShaderCache purgeSharedShaderCache ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShaderCache* (o)
JSBool JSB_CCShaderCache_sharedShaderCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCShaderCache* ret_val;

	ret_val = [CCShaderCache sharedShaderCache ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCShaderCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShaderCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShaderCache_class->name = name;
	JSB_CCShaderCache_class->addProperty = JS_PropertyStub;
	JSB_CCShaderCache_class->delProperty = JS_PropertyStub;
	JSB_CCShaderCache_class->getProperty = JS_PropertyStub;
	JSB_CCShaderCache_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShaderCache_class->enumerate = JS_EnumerateStub;
	JSB_CCShaderCache_class->resolve = JS_ResolveStub;
	JSB_CCShaderCache_class->convert = JS_ConvertStub;
	JSB_CCShaderCache_class->finalize = JSB_CCShaderCache_finalize;
	JSB_CCShaderCache_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addProgram", JSB_CCShaderCache_addProgram_forKey_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("loadDefaultShaders", JSB_CCShaderCache_loadDefaultShaders, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProgram", JSB_CCShaderCache_programForKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShaderCache_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedShaderCache", JSB_CCShaderCache_purgeSharedShaderCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSB_CCShaderCache_sharedShaderCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShaderCache_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCShaderCache_class, JSB_CCShaderCache_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShaderCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShaderCache_class, JSB_CCShaderCache_object, NULL);
	JSB_CCShaderCache *proxy = [[JSB_CCShaderCache alloc] initWithJSObject:jsobj class:[CCShaderCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeTR
 */
#pragma mark - CCTransitionFadeTR

JSClass* JSB_CCTransitionFadeTR_class = NULL;
JSObject* JSB_CCTransitionFadeTR_object = NULL;
// Constructor
JSBool JSB_CCTransitionFadeTR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFadeTR createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFadeTR_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFadeTR)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFadeTR_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFadeTR *proxy = [[JSB_CCTransitionFadeTR alloc] initWithJSObject:obj class:[CCTransitionFadeTR class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionFadeTR_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionFadeTR *real = (CCTransitionFadeTR*) [proxy realObj];
	ret_val = [real actionWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionFadeTR_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionFadeTR *real = (CCTransitionFadeTR*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeTR* (o)
JSBool JSB_CCTransitionFadeTR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFadeTR* ret_val;

	ret_val = [CCTransitionFadeTR transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeTR* (o)
JSBool JSB_CCTransitionFadeTR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFadeTR* ret_val;

	ret_val = [CCTransitionFadeTR node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFadeTR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFadeTR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFadeTR_class->name = name;
	JSB_CCTransitionFadeTR_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFadeTR_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFadeTR_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFadeTR_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFadeTR_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFadeTR_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFadeTR_class->convert = JS_ConvertStub;
	JSB_CCTransitionFadeTR_class->finalize = JSB_CCTransitionFadeTR_finalize;
	JSB_CCTransitionFadeTR_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSB_CCTransitionFadeTR_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionFadeTR_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFadeTR_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFadeTR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFadeTR_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFadeTR_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionFadeTR_class, JSB_CCTransitionFadeTR_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFadeTR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFadeTR_class, JSB_CCTransitionFadeTR_object, NULL);
	JSB_CCTransitionFadeTR *proxy = [[JSB_CCTransitionFadeTR alloc] initWithJSObject:jsobj class:[CCTransitionFadeTR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSceneOriented
 */
#pragma mark - CCTransitionSceneOriented

JSClass* JSB_CCTransitionSceneOriented_class = NULL;
JSObject* JSB_CCTransitionSceneOriented_object = NULL;
// Constructor
JSBool JSB_CCTransitionSceneOriented_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSceneOriented createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSceneOriented_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSceneOriented)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSceneOriented_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSceneOriented *proxy = [[JSB_CCTransitionSceneOriented alloc] initWithJSObject:obj class:[CCTransitionSceneOriented class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: None (None)
JSBool JSB_CCTransitionSceneOriented_initWithDuration_scene_orientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTransitionSceneOriented *real = [(CCTransitionSceneOriented*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSB_CCTransitionSceneOriented_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSB_CCTransitionSceneOriented_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSB_CCTransitionSceneOriented_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSceneOriented_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSceneOriented_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSceneOriented_class->name = name;
	JSB_CCTransitionSceneOriented_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSceneOriented_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSceneOriented_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSceneOriented_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSceneOriented_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSceneOriented_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSceneOriented_class->convert = JS_ConvertStub;
	JSB_CCTransitionSceneOriented_class->finalize = JSB_CCTransitionSceneOriented_finalize;
	JSB_CCTransitionSceneOriented_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSceneOrientation", JSB_CCTransitionSceneOriented_initWithDuration_scene_orientation_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSceneOriented_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSB_CCTransitionSceneOriented_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCTransitionSceneOriented_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSceneOriented_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSceneOriented_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionSceneOriented_class, JSB_CCTransitionSceneOriented_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSceneOriented

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSceneOriented_class, JSB_CCTransitionSceneOriented_object, NULL);
	JSB_CCTransitionSceneOriented *proxy = [[JSB_CCTransitionSceneOriented alloc] initWithJSObject:jsobj class:[CCTransitionSceneOriented class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScaleTo
 */
#pragma mark - CCScaleTo

JSClass* JSB_CCScaleTo_class = NULL;
JSObject* JSB_CCScaleTo_object = NULL;
// Constructor
JSBool JSB_CCScaleTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCScaleTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCScaleTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCScaleTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCScaleTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCScaleTo *proxy = [[JSB_CCScaleTo alloc] initWithJSObject:obj class:[CCScaleTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCScaleTo* (o)
JSBool JSB_CCScaleTo_actionWithDuration_scaleX_scaleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCScaleTo* ret_val;

	if( argc == 2 ) {
		ret_val = [CCScaleTo actionWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCScaleTo actionWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSB_CCScaleTo_initWithDuration_scale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScaleTo *real = [(CCScaleTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCScaleTo_initWithDuration_scaleX_scaleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScaleTo *real = [(CCScaleTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCScaleTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCScaleTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCScaleTo_class->name = name;
	JSB_CCScaleTo_class->addProperty = JS_PropertyStub;
	JSB_CCScaleTo_class->delProperty = JS_PropertyStub;
	JSB_CCScaleTo_class->getProperty = JS_PropertyStub;
	JSB_CCScaleTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCScaleTo_class->enumerate = JS_EnumerateStub;
	JSB_CCScaleTo_class->resolve = JS_ResolveStub;
	JSB_CCScaleTo_class->convert = JS_ConvertStub;
	JSB_CCScaleTo_class->finalize = JSB_CCScaleTo_finalize;
	JSB_CCScaleTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationScale", JSB_CCScaleTo_initWithDuration_scale_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationScaleXScaleY", JSB_CCScaleTo_initWithDuration_scaleX_scaleY_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCScaleTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCScaleTo_actionWithDuration_scaleX_scaleY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCScaleTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCScaleTo_class, JSB_CCScaleTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCScaleTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCScaleTo_class, JSB_CCScaleTo_object, NULL);
	JSB_CCScaleTo *proxy = [[JSB_CCScaleTo alloc] initWithJSObject:jsobj class:[CCScaleTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScaleBy
 */
#pragma mark - CCScaleBy

JSClass* JSB_CCScaleBy_class = NULL;
JSObject* JSB_CCScaleBy_object = NULL;
// Constructor
JSBool JSB_CCScaleBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCScaleBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCScaleBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCScaleBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCScaleBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCScaleBy *proxy = [[JSB_CCScaleBy alloc] initWithJSObject:obj class:[CCScaleBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCScaleBy_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScaleBy *real = (CCScaleBy*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCScaleBy* (o)
JSBool JSB_CCScaleBy_actionWithDuration_scaleX_scaleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCScaleBy* ret_val;

	if( argc == 2 ) {
		ret_val = [CCScaleBy actionWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCScaleBy actionWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCScaleBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCScaleBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCScaleBy_class->name = name;
	JSB_CCScaleBy_class->addProperty = JS_PropertyStub;
	JSB_CCScaleBy_class->delProperty = JS_PropertyStub;
	JSB_CCScaleBy_class->getProperty = JS_PropertyStub;
	JSB_CCScaleBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCScaleBy_class->enumerate = JS_EnumerateStub;
	JSB_CCScaleBy_class->resolve = JS_ResolveStub;
	JSB_CCScaleBy_class->convert = JS_ConvertStub;
	JSB_CCScaleBy_class->finalize = JSB_CCScaleBy_finalize;
	JSB_CCScaleBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCScaleBy_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCScaleBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCScaleBy_actionWithDuration_scaleX_scaleY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCScaleBy_object = JS_InitClass(cx, globalObj, JSB_CCScaleTo_object, JSB_CCScaleBy_class, JSB_CCScaleBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCScaleBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCScaleBy_class, JSB_CCScaleBy_object, NULL);
	JSB_CCScaleBy *proxy = [[JSB_CCScaleBy alloc] initWithJSObject:jsobj class:[CCScaleBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionPageTurn
 */
#pragma mark - CCTransitionPageTurn

JSClass* JSB_CCTransitionPageTurn_class = NULL;
JSObject* JSB_CCTransitionPageTurn_object = NULL;
// Constructor
JSBool JSB_CCTransitionPageTurn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionPageTurn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionPageTurn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionPageTurn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionPageTurn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionPageTurn *proxy = [[JSB_CCTransitionPageTurn alloc] initWithJSObject:obj class:[CCTransitionPageTurn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionPageTurn_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionPageTurn *real = (CCTransitionPageTurn*) [proxy realObj];
	ret_val = [real actionWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, BOOL
// Ret value: None (None)
JSBool JSB_CCTransitionPageTurn_initWithDuration_scene_backwards_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; JSBool arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTransitionPageTurn *real = [(CCTransitionPageTurn*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:arg1 backwards:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, BOOL
// Ret value: CCTransitionPageTurn* (o)
JSBool JSB_CCTransitionPageTurn_transitionWithDuration_scene_backwards__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; JSBool arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionPageTurn* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionPageTurn transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionPageTurn transitionWithDuration:(ccTime)arg0 scene:arg1 backwards:(BOOL)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionPageTurn* (o)
JSBool JSB_CCTransitionPageTurn_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionPageTurn* ret_val;

	ret_val = [CCTransitionPageTurn node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionPageTurn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionPageTurn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionPageTurn_class->name = name;
	JSB_CCTransitionPageTurn_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionPageTurn_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionPageTurn_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionPageTurn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionPageTurn_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionPageTurn_class->resolve = JS_ResolveStub;
	JSB_CCTransitionPageTurn_class->convert = JS_ConvertStub;
	JSB_CCTransitionPageTurn_class->finalize = JSB_CCTransitionPageTurn_finalize;
	JSB_CCTransitionPageTurn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSB_CCTransitionPageTurn_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSceneBackwards", JSB_CCTransitionPageTurn_initWithDuration_scene_backwards_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionPageTurn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionPageTurn_transitionWithDuration_scene_backwards__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionPageTurn_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionPageTurn_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionPageTurn_class, JSB_CCTransitionPageTurn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionPageTurn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionPageTurn_class, JSB_CCTransitionPageTurn_object, NULL);
	JSB_CCTransitionPageTurn *proxy = [[JSB_CCTransitionPageTurn alloc] initWithJSObject:jsobj class:[CCTransitionPageTurn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionRotoZoom
 */
#pragma mark - CCTransitionRotoZoom

JSClass* JSB_CCTransitionRotoZoom_class = NULL;
JSObject* JSB_CCTransitionRotoZoom_object = NULL;
// Constructor
JSBool JSB_CCTransitionRotoZoom_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionRotoZoom createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionRotoZoom_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionRotoZoom)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionRotoZoom_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionRotoZoom *proxy = [[JSB_CCTransitionRotoZoom alloc] initWithJSObject:obj class:[CCTransitionRotoZoom class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionRotoZoom_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionRotoZoom *real = [(CCTransitionRotoZoom*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionRotoZoom* (o)
JSBool JSB_CCTransitionRotoZoom_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionRotoZoom* ret_val;

	ret_val = [CCTransitionRotoZoom transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionRotoZoom* (o)
JSBool JSB_CCTransitionRotoZoom_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionRotoZoom* ret_val;

	ret_val = [CCTransitionRotoZoom node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionRotoZoom_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionRotoZoom_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionRotoZoom_class->name = name;
	JSB_CCTransitionRotoZoom_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionRotoZoom_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionRotoZoom_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionRotoZoom_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionRotoZoom_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionRotoZoom_class->resolve = JS_ResolveStub;
	JSB_CCTransitionRotoZoom_class->convert = JS_ConvertStub;
	JSB_CCTransitionRotoZoom_class->finalize = JSB_CCTransitionRotoZoom_finalize;
	JSB_CCTransitionRotoZoom_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionRotoZoom_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionRotoZoom_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionRotoZoom_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionRotoZoom_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionRotoZoom_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionRotoZoom_class, JSB_CCTransitionRotoZoom_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionRotoZoom

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionRotoZoom_class, JSB_CCTransitionRotoZoom_object, NULL);
	JSB_CCTransitionRotoZoom *proxy = [[JSB_CCTransitionRotoZoom alloc] initWithJSObject:jsobj class:[CCTransitionRotoZoom class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeDown
 */
#pragma mark - CCTransitionFadeDown

JSClass* JSB_CCTransitionFadeDown_class = NULL;
JSObject* JSB_CCTransitionFadeDown_object = NULL;
// Constructor
JSBool JSB_CCTransitionFadeDown_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFadeDown createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFadeDown_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFadeDown)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFadeDown_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFadeDown *proxy = [[JSB_CCTransitionFadeDown alloc] initWithJSObject:obj class:[CCTransitionFadeDown class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionFadeDown_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionFadeDown *real = (CCTransitionFadeDown*) [proxy realObj];
	ret_val = [real actionWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeDown* (o)
JSBool JSB_CCTransitionFadeDown_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFadeDown* ret_val;

	ret_val = [CCTransitionFadeDown transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeDown* (o)
JSBool JSB_CCTransitionFadeDown_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFadeDown* ret_val;

	ret_val = [CCTransitionFadeDown node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFadeDown_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFadeDown_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFadeDown_class->name = name;
	JSB_CCTransitionFadeDown_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFadeDown_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFadeDown_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFadeDown_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFadeDown_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFadeDown_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFadeDown_class->convert = JS_ConvertStub;
	JSB_CCTransitionFadeDown_class->finalize = JSB_CCTransitionFadeDown_finalize;
	JSB_CCTransitionFadeDown_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSB_CCTransitionFadeDown_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFadeDown_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFadeDown_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFadeDown_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFadeDown_object = JS_InitClass(cx, globalObj, JSB_CCTransitionFadeTR_object, JSB_CCTransitionFadeDown_class, JSB_CCTransitionFadeDown_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFadeDown

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFadeDown_class, JSB_CCTransitionFadeDown_object, NULL);
	JSB_CCTransitionFadeDown *proxy = [[JSB_CCTransitionFadeDown alloc] initWithJSObject:jsobj class:[CCTransitionFadeDown class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDelayTime
 */
#pragma mark - CCDelayTime

JSClass* JSB_CCDelayTime_class = NULL;
JSObject* JSB_CCDelayTime_object = NULL;
// Constructor
JSBool JSB_CCDelayTime_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDelayTime createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDelayTime_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDelayTime)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDelayTime_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDelayTime *proxy = [[JSB_CCDelayTime alloc] initWithJSObject:obj class:[CCDelayTime class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCDelayTime_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDelayTime *real = (CCDelayTime*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCDelayTime* (o)
JSBool JSB_CCDelayTime_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCDelayTime* ret_val;

	ret_val = [CCDelayTime actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCDelayTime_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDelayTime_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDelayTime_class->name = name;
	JSB_CCDelayTime_class->addProperty = JS_PropertyStub;
	JSB_CCDelayTime_class->delProperty = JS_PropertyStub;
	JSB_CCDelayTime_class->getProperty = JS_PropertyStub;
	JSB_CCDelayTime_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDelayTime_class->enumerate = JS_EnumerateStub;
	JSB_CCDelayTime_class->resolve = JS_ResolveStub;
	JSB_CCDelayTime_class->convert = JS_ConvertStub;
	JSB_CCDelayTime_class->finalize = JSB_CCDelayTime_finalize;
	JSB_CCDelayTime_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCDelayTime_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDelayTime_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCDelayTime_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDelayTime_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCDelayTime_class, JSB_CCDelayTime_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDelayTime

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDelayTime_class, JSB_CCDelayTime_object, NULL);
	JSB_CCDelayTime *proxy = [[JSB_CCDelayTime alloc] initWithJSObject:jsobj class:[CCDelayTime class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseRateAction
 */
#pragma mark - CCEaseRateAction

JSClass* JSB_CCEaseRateAction_class = NULL;
JSObject* JSB_CCEaseRateAction_object = NULL;
// Constructor
JSBool JSB_CCEaseRateAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseRateAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseRateAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseRateAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseRateAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseRateAction *proxy = [[JSB_CCEaseRateAction alloc] initWithJSObject:obj class:[CCEaseRateAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseRateAction* (o)
JSBool JSB_CCEaseRateAction_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseRateAction* ret_val;

	ret_val = [CCEaseRateAction actionWithAction:arg0 rate:(float)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: None (None)
JSBool JSB_CCEaseRateAction_initWithAction_rate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseRateAction *real = [(CCEaseRateAction*)[proxy.klass alloc] initWithAction:arg0 rate:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCEaseRateAction_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCEaseRateAction *real = (CCEaseRateAction*) [proxy realObj];
	ret_val = [real rate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCEaseRateAction_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseRateAction *real = (CCEaseRateAction*) [proxy realObj];
	[real setRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCEaseRateAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseRateAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseRateAction_class->name = name;
	JSB_CCEaseRateAction_class->addProperty = JS_PropertyStub;
	JSB_CCEaseRateAction_class->delProperty = JS_PropertyStub;
	JSB_CCEaseRateAction_class->getProperty = JS_PropertyStub;
	JSB_CCEaseRateAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseRateAction_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseRateAction_class->resolve = JS_ResolveStub;
	JSB_CCEaseRateAction_class->convert = JS_ConvertStub;
	JSB_CCEaseRateAction_class->finalize = JSB_CCEaseRateAction_finalize;
	JSB_CCEaseRateAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionRate", JSB_CCEaseRateAction_initWithAction_rate_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRate", JSB_CCEaseRateAction_rate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_CCEaseRateAction_setRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseRateAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionRate", JSB_CCEaseRateAction_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseRateAction_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseRateAction_class, JSB_CCEaseRateAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseRateAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseRateAction_class, JSB_CCEaseRateAction_object, NULL);
	JSB_CCEaseRateAction *proxy = [[JSB_CCEaseRateAction alloc] initWithJSObject:jsobj class:[CCEaseRateAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseInOut
 */
#pragma mark - CCEaseInOut

JSClass* JSB_CCEaseInOut_class = NULL;
JSObject* JSB_CCEaseInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseInOut *proxy = [[JSB_CCEaseInOut alloc] initWithJSObject:obj class:[CCEaseInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseInOut *real = (CCEaseInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseInOut* (o)
JSBool JSB_CCEaseInOut_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseInOut* ret_val;

	ret_val = [CCEaseInOut actionWithAction:arg0 rate:(float)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseInOut_class->name = name;
	JSB_CCEaseInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseInOut_class->finalize = JSB_CCEaseInOut_finalize;
	JSB_CCEaseInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseInOut_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseInOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseRateAction_object, JSB_CCEaseInOut_class, JSB_CCEaseInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseInOut_class, JSB_CCEaseInOut_object, NULL);
	JSB_CCEaseInOut *proxy = [[JSB_CCEaseInOut alloc] initWithJSObject:jsobj class:[CCEaseInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSplitCols
 */
#pragma mark - CCTransitionSplitCols

JSClass* JSB_CCTransitionSplitCols_class = NULL;
JSObject* JSB_CCTransitionSplitCols_object = NULL;
// Constructor
JSBool JSB_CCTransitionSplitCols_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSplitCols createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSplitCols_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSplitCols)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSplitCols_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSplitCols *proxy = [[JSB_CCTransitionSplitCols alloc] initWithJSObject:obj class:[CCTransitionSplitCols class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionSplitCols_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSplitCols *real = (CCTransitionSplitCols*) [proxy realObj];
	ret_val = [real action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionSplitCols_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionSplitCols *real = (CCTransitionSplitCols*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSplitCols* (o)
JSBool JSB_CCTransitionSplitCols_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSplitCols* ret_val;

	ret_val = [CCTransitionSplitCols transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSplitCols* (o)
JSBool JSB_CCTransitionSplitCols_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSplitCols* ret_val;

	ret_val = [CCTransitionSplitCols node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSplitCols_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSplitCols_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSplitCols_class->name = name;
	JSB_CCTransitionSplitCols_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSplitCols_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSplitCols_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSplitCols_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSplitCols_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSplitCols_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSplitCols_class->convert = JS_ConvertStub;
	JSB_CCTransitionSplitCols_class->finalize = JSB_CCTransitionSplitCols_finalize;
	JSB_CCTransitionSplitCols_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSB_CCTransitionSplitCols_action, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionSplitCols_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSplitCols_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSplitCols_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSplitCols_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSplitCols_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionSplitCols_class, JSB_CCTransitionSplitCols_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSplitCols

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSplitCols_class, JSB_CCTransitionSplitCols_object, NULL);
	JSB_CCTransitionSplitCols *proxy = [[JSB_CCTransitionSplitCols alloc] initWithJSObject:jsobj class:[CCTransitionSplitCols class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCardinalSplineTo
 */
#pragma mark - CCCardinalSplineTo

JSClass* JSB_CCCardinalSplineTo_class = NULL;
JSObject* JSB_CCCardinalSplineTo_object = NULL;
// Constructor
JSBool JSB_CCCardinalSplineTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCardinalSplineTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCardinalSplineTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCardinalSplineTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCardinalSplineTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCardinalSplineTo *proxy = [[JSB_CCCardinalSplineTo alloc] initWithJSObject:obj class:[CCCardinalSplineTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: None (None)
JSBool JSB_CCCardinalSplineTo_initWithDuration_points_tension_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCardinalSplineTo *real = [(CCCardinalSplineTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:arg1 tension:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCPointArray* (o)
JSBool JSB_CCCardinalSplineTo_points(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCPointArray* ret_val;

	CCCardinalSplineTo *real = (CCCardinalSplineTo*) [proxy realObj];
	ret_val = [real points ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCPointArray*
// Ret value: void (None)
JSBool JSB_CCCardinalSplineTo_setPoints_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCardinalSplineTo *real = (CCCardinalSplineTo*) [proxy realObj];
	[real setPoints:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCCardinalSplineTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCardinalSplineTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCardinalSplineTo_class->name = name;
	JSB_CCCardinalSplineTo_class->addProperty = JS_PropertyStub;
	JSB_CCCardinalSplineTo_class->delProperty = JS_PropertyStub;
	JSB_CCCardinalSplineTo_class->getProperty = JS_PropertyStub;
	JSB_CCCardinalSplineTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCardinalSplineTo_class->enumerate = JS_EnumerateStub;
	JSB_CCCardinalSplineTo_class->resolve = JS_ResolveStub;
	JSB_CCCardinalSplineTo_class->convert = JS_ConvertStub;
	JSB_CCCardinalSplineTo_class->finalize = JSB_CCCardinalSplineTo_finalize;
	JSB_CCCardinalSplineTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPointsTension", JSB_CCCardinalSplineTo_initWithDuration_points_tension_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("points", JSB_CCCardinalSplineTo_points, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPoints", JSB_CCCardinalSplineTo_setPoints_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCardinalSplineTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCCardinalSplineTo_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCardinalSplineTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCCardinalSplineTo_class, JSB_CCCardinalSplineTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCardinalSplineTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCardinalSplineTo_class, JSB_CCCardinalSplineTo_object, NULL);
	JSB_CCCardinalSplineTo *proxy = [[JSB_CCCardinalSplineTo alloc] initWithJSObject:jsobj class:[CCCardinalSplineTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCardinalSplineBy
 */
#pragma mark - CCCardinalSplineBy

JSClass* JSB_CCCardinalSplineBy_class = NULL;
JSObject* JSB_CCCardinalSplineBy_object = NULL;
// Constructor
JSBool JSB_CCCardinalSplineBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCardinalSplineBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCardinalSplineBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCardinalSplineBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCardinalSplineBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCardinalSplineBy *proxy = [[JSB_CCCardinalSplineBy alloc] initWithJSObject:obj class:[CCCardinalSplineBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCCardinalSplineBy_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCardinalSplineBy *real = (CCCardinalSplineBy*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCCardinalSplineBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCardinalSplineBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCardinalSplineBy_class->name = name;
	JSB_CCCardinalSplineBy_class->addProperty = JS_PropertyStub;
	JSB_CCCardinalSplineBy_class->delProperty = JS_PropertyStub;
	JSB_CCCardinalSplineBy_class->getProperty = JS_PropertyStub;
	JSB_CCCardinalSplineBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCardinalSplineBy_class->enumerate = JS_EnumerateStub;
	JSB_CCCardinalSplineBy_class->resolve = JS_ResolveStub;
	JSB_CCCardinalSplineBy_class->convert = JS_ConvertStub;
	JSB_CCCardinalSplineBy_class->finalize = JSB_CCCardinalSplineBy_finalize;
	JSB_CCCardinalSplineBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCCardinalSplineBy_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCardinalSplineBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCCardinalSplineBy_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCardinalSplineBy_object = JS_InitClass(cx, globalObj, JSB_CCCardinalSplineTo_object, JSB_CCCardinalSplineBy_class, JSB_CCCardinalSplineBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCardinalSplineBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCardinalSplineBy_class, JSB_CCCardinalSplineBy_object, NULL);
	JSB_CCCardinalSplineBy *proxy = [[JSB_CCCardinalSplineBy alloc] initWithJSObject:jsobj class:[CCCardinalSplineBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCatmullRomBy
 */
#pragma mark - CCCatmullRomBy

JSClass* JSB_CCCatmullRomBy_class = NULL;
JSObject* JSB_CCCatmullRomBy_object = NULL;
// Constructor
JSBool JSB_CCCatmullRomBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCatmullRomBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCatmullRomBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCatmullRomBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCatmullRomBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCatmullRomBy *proxy = [[JSB_CCCatmullRomBy alloc] initWithJSObject:obj class:[CCCatmullRomBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*
// Ret value: None (None)
JSBool JSB_CCCatmullRomBy_initWithDuration_points_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCatmullRomBy *real = [(CCCatmullRomBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCCatmullRomBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCatmullRomBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCatmullRomBy_class->name = name;
	JSB_CCCatmullRomBy_class->addProperty = JS_PropertyStub;
	JSB_CCCatmullRomBy_class->delProperty = JS_PropertyStub;
	JSB_CCCatmullRomBy_class->getProperty = JS_PropertyStub;
	JSB_CCCatmullRomBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCatmullRomBy_class->enumerate = JS_EnumerateStub;
	JSB_CCCatmullRomBy_class->resolve = JS_ResolveStub;
	JSB_CCCatmullRomBy_class->convert = JS_ConvertStub;
	JSB_CCCatmullRomBy_class->finalize = JSB_CCCatmullRomBy_finalize;
	JSB_CCCatmullRomBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPoints", JSB_CCCatmullRomBy_initWithDuration_points_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCatmullRomBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCCatmullRomBy_actionWithDuration_points__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCatmullRomBy_object = JS_InitClass(cx, globalObj, JSB_CCCardinalSplineBy_object, JSB_CCCatmullRomBy_class, JSB_CCCatmullRomBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCatmullRomBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCatmullRomBy_class, JSB_CCCatmullRomBy_object, NULL);
	JSB_CCCatmullRomBy *proxy = [[JSB_CCCatmullRomBy alloc] initWithJSObject:jsobj class:[CCCatmullRomBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipAngular
 */
#pragma mark - CCTransitionFlipAngular

JSClass* JSB_CCTransitionFlipAngular_class = NULL;
JSObject* JSB_CCTransitionFlipAngular_object = NULL;
// Constructor
JSBool JSB_CCTransitionFlipAngular_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFlipAngular createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFlipAngular_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFlipAngular)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFlipAngular_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFlipAngular *proxy = [[JSB_CCTransitionFlipAngular alloc] initWithJSObject:obj class:[CCTransitionFlipAngular class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionFlipAngular_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionFlipAngular *real = [(CCTransitionFlipAngular*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipAngular* (o)
JSBool JSB_CCTransitionFlipAngular_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFlipAngular* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionFlipAngular transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionFlipAngular transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipAngular* (o)
JSBool JSB_CCTransitionFlipAngular_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFlipAngular* ret_val;

	ret_val = [CCTransitionFlipAngular node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFlipAngular_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFlipAngular_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFlipAngular_class->name = name;
	JSB_CCTransitionFlipAngular_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFlipAngular_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFlipAngular_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFlipAngular_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFlipAngular_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFlipAngular_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFlipAngular_class->convert = JS_ConvertStub;
	JSB_CCTransitionFlipAngular_class->finalize = JSB_CCTransitionFlipAngular_finalize;
	JSB_CCTransitionFlipAngular_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionFlipAngular_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFlipAngular_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFlipAngular_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFlipAngular_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFlipAngular_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionFlipAngular_class, JSB_CCTransitionFlipAngular_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFlipAngular

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFlipAngular_class, JSB_CCTransitionFlipAngular_object, NULL);
	JSB_CCTransitionFlipAngular *proxy = [[JSB_CCTransitionFlipAngular alloc] initWithJSObject:jsobj class:[CCTransitionFlipAngular class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCHide
 */
#pragma mark - CCHide

JSClass* JSB_CCHide_class = NULL;
JSObject* JSB_CCHide_object = NULL;
// Constructor
JSBool JSB_CCHide_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCHide createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCHide_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCHide)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCHide_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCHide *proxy = [[JSB_CCHide alloc] initWithJSObject:obj class:[CCHide class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCHide_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCHide *real = (CCHide*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCHide* (o)
JSBool JSB_CCHide_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCHide* ret_val;

	ret_val = [CCHide action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCHide_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCHide_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCHide_class->name = name;
	JSB_CCHide_class->addProperty = JS_PropertyStub;
	JSB_CCHide_class->delProperty = JS_PropertyStub;
	JSB_CCHide_class->getProperty = JS_PropertyStub;
	JSB_CCHide_class->setProperty = JS_StrictPropertyStub;
	JSB_CCHide_class->enumerate = JS_EnumerateStub;
	JSB_CCHide_class->resolve = JS_ResolveStub;
	JSB_CCHide_class->convert = JS_ConvertStub;
	JSB_CCHide_class->finalize = JSB_CCHide_finalize;
	JSB_CCHide_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCHide_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCHide_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCHide_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCHide_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCHide_class, JSB_CCHide_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCHide

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCHide_class, JSB_CCHide_object, NULL);
	JSB_CCHide *proxy = [[JSB_CCHide alloc] initWithJSObject:jsobj class:[CCHide class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOutTRTiles
 */
#pragma mark - CCFadeOutTRTiles

JSClass* JSB_CCFadeOutTRTiles_class = NULL;
JSObject* JSB_CCFadeOutTRTiles_object = NULL;
// Constructor
JSBool JSB_CCFadeOutTRTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeOutTRTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeOutTRTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeOutTRTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeOutTRTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeOutTRTiles *proxy = [[JSB_CCFadeOutTRTiles alloc] initWithJSObject:obj class:[CCFadeOutTRTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize, ccTime
// Ret value: float (d)
JSBool JSB_CCFadeOutTRTiles_testFunc_time_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; double arg1; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	float ret_val;

	CCFadeOutTRTiles *real = (CCFadeOutTRTiles*) [proxy realObj];
	ret_val = [real testFunc:(CGSize)arg0 time:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCFadeOutTRTiles* (o)
JSBool JSB_CCFadeOutTRTiles_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeOutTRTiles* ret_val;

	ret_val = [CCFadeOutTRTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeOutTRTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeOutTRTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeOutTRTiles_class->name = name;
	JSB_CCFadeOutTRTiles_class->addProperty = JS_PropertyStub;
	JSB_CCFadeOutTRTiles_class->delProperty = JS_PropertyStub;
	JSB_CCFadeOutTRTiles_class->getProperty = JS_PropertyStub;
	JSB_CCFadeOutTRTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeOutTRTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeOutTRTiles_class->resolve = JS_ResolveStub;
	JSB_CCFadeOutTRTiles_class->convert = JS_ConvertStub;
	JSB_CCFadeOutTRTiles_class->finalize = JSB_CCFadeOutTRTiles_finalize;
	JSB_CCFadeOutTRTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("testFuncTime", JSB_CCFadeOutTRTiles_testFunc_time_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeOutTRTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeOutTRTiles_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeOutTRTiles_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCFadeOutTRTiles_class, JSB_CCFadeOutTRTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeOutTRTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeOutTRTiles_class, JSB_CCFadeOutTRTiles_object, NULL);
	JSB_CCFadeOutTRTiles *proxy = [[JSB_CCFadeOutTRTiles alloc] initWithJSObject:jsobj class:[CCFadeOutTRTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOutUpTiles
 */
#pragma mark - CCFadeOutUpTiles

JSClass* JSB_CCFadeOutUpTiles_class = NULL;
JSObject* JSB_CCFadeOutUpTiles_object = NULL;
// Constructor
JSBool JSB_CCFadeOutUpTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeOutUpTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeOutUpTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeOutUpTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeOutUpTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeOutUpTiles *proxy = [[JSB_CCFadeOutUpTiles alloc] initWithJSObject:obj class:[CCFadeOutUpTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize, ccTime
// Ret value: float (d)
JSBool JSB_CCFadeOutUpTiles_testFunc_time_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; double arg1; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	float ret_val;

	CCFadeOutUpTiles *real = (CCFadeOutUpTiles*) [proxy realObj];
	ret_val = [real testFunc:(CGSize)arg0 time:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCFadeOutUpTiles* (o)
JSBool JSB_CCFadeOutUpTiles_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeOutUpTiles* ret_val;

	ret_val = [CCFadeOutUpTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeOutUpTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeOutUpTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeOutUpTiles_class->name = name;
	JSB_CCFadeOutUpTiles_class->addProperty = JS_PropertyStub;
	JSB_CCFadeOutUpTiles_class->delProperty = JS_PropertyStub;
	JSB_CCFadeOutUpTiles_class->getProperty = JS_PropertyStub;
	JSB_CCFadeOutUpTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeOutUpTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeOutUpTiles_class->resolve = JS_ResolveStub;
	JSB_CCFadeOutUpTiles_class->convert = JS_ConvertStub;
	JSB_CCFadeOutUpTiles_class->finalize = JSB_CCFadeOutUpTiles_finalize;
	JSB_CCFadeOutUpTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("testFuncTime", JSB_CCFadeOutUpTiles_testFunc_time_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeOutUpTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeOutUpTiles_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeOutUpTiles_object = JS_InitClass(cx, globalObj, JSB_CCFadeOutTRTiles_object, JSB_CCFadeOutUpTiles_class, JSB_CCFadeOutUpTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeOutUpTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeOutUpTiles_class, JSB_CCFadeOutUpTiles_object, NULL);
	JSB_CCFadeOutUpTiles *proxy = [[JSB_CCFadeOutUpTiles alloc] initWithJSObject:jsobj class:[CCFadeOutUpTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOutDownTiles
 */
#pragma mark - CCFadeOutDownTiles

JSClass* JSB_CCFadeOutDownTiles_class = NULL;
JSObject* JSB_CCFadeOutDownTiles_object = NULL;
// Constructor
JSBool JSB_CCFadeOutDownTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeOutDownTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeOutDownTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeOutDownTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeOutDownTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeOutDownTiles *proxy = [[JSB_CCFadeOutDownTiles alloc] initWithJSObject:obj class:[CCFadeOutDownTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize, ccTime
// Ret value: float (d)
JSBool JSB_CCFadeOutDownTiles_testFunc_time_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; double arg1; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	float ret_val;

	CCFadeOutDownTiles *real = (CCFadeOutDownTiles*) [proxy realObj];
	ret_val = [real testFunc:(CGSize)arg0 time:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCFadeOutDownTiles* (o)
JSBool JSB_CCFadeOutDownTiles_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeOutDownTiles* ret_val;

	ret_val = [CCFadeOutDownTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeOutDownTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeOutDownTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeOutDownTiles_class->name = name;
	JSB_CCFadeOutDownTiles_class->addProperty = JS_PropertyStub;
	JSB_CCFadeOutDownTiles_class->delProperty = JS_PropertyStub;
	JSB_CCFadeOutDownTiles_class->getProperty = JS_PropertyStub;
	JSB_CCFadeOutDownTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeOutDownTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeOutDownTiles_class->resolve = JS_ResolveStub;
	JSB_CCFadeOutDownTiles_class->convert = JS_ConvertStub;
	JSB_CCFadeOutDownTiles_class->finalize = JSB_CCFadeOutDownTiles_finalize;
	JSB_CCFadeOutDownTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("testFuncTime", JSB_CCFadeOutDownTiles_testFunc_time_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeOutDownTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeOutDownTiles_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeOutDownTiles_object = JS_InitClass(cx, globalObj, JSB_CCFadeOutUpTiles_object, JSB_CCFadeOutDownTiles_class, JSB_CCFadeOutDownTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeOutDownTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeOutDownTiles_class, JSB_CCFadeOutDownTiles_object, NULL);
	JSB_CCFadeOutDownTiles *proxy = [[JSB_CCFadeOutDownTiles alloc] initWithJSObject:jsobj class:[CCFadeOutDownTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackIn
 */
#pragma mark - CCEaseBackIn

JSClass* JSB_CCEaseBackIn_class = NULL;
JSObject* JSB_CCEaseBackIn_object = NULL;
// Constructor
JSBool JSB_CCEaseBackIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBackIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBackIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBackIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBackIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBackIn *proxy = [[JSB_CCEaseBackIn alloc] initWithJSObject:obj class:[CCEaseBackIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBackIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBackIn *real = (CCEaseBackIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackIn* (o)
JSBool JSB_CCEaseBackIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBackIn* ret_val;

	ret_val = [CCEaseBackIn actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBackIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBackIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBackIn_class->name = name;
	JSB_CCEaseBackIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBackIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBackIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBackIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBackIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBackIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseBackIn_class->convert = JS_ConvertStub;
	JSB_CCEaseBackIn_class->finalize = JSB_CCEaseBackIn_finalize;
	JSB_CCEaseBackIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBackIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBackIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBackIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBackIn_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseBackIn_class, JSB_CCEaseBackIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBackIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBackIn_class, JSB_CCEaseBackIn_object, NULL);
	JSB_CCEaseBackIn *proxy = [[JSB_CCEaseBackIn alloc] initWithJSObject:jsobj class:[CCEaseBackIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteBatchNode
 */
#pragma mark - CCSpriteBatchNode

JSClass* JSB_CCSpriteBatchNode_class = NULL;
JSObject* JSB_CCSpriteBatchNode_object = NULL;
// Constructor
JSBool JSB_CCSpriteBatchNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSpriteBatchNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSpriteBatchNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSpriteBatchNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSpriteBatchNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSpriteBatchNode *proxy = [[JSB_CCSpriteBatchNode alloc] initWithJSObject:obj class:[CCSpriteBatchNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger, NSInteger
// Ret value: NSObject* (o)
JSBool JSB_CCSpriteBatchNode_addSpriteWithoutQuad_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; int32_t arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSObject* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real addSpriteWithoutQuad:arg0 z:(NSUInteger)arg1 tag:(NSInteger)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_appendChild_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real appendChild:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*, NSInteger
// Ret value: NSUInteger (u)
JSBool JSB_CCSpriteBatchNode_atlasIndexForChild_atZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSUInteger ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real atlasIndexForChild:arg0 atZ:(NSInteger)arg1  ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCSpriteBatchNode* (o)
JSBool JSB_CCSpriteBatchNode_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpriteBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCSpriteBatchNode* (o)
JSBool JSB_CCSpriteBatchNode_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpriteBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithTexture:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithTexture:arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCArray* (array)
JSBool JSB_CCSpriteBatchNode_descendants(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCArray* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real descendants ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_increaseAtlasCapacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real increaseAtlasCapacity ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCSpriteBatchNode_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = [(CCSpriteBatchNode*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCSpriteBatchNode_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = [(CCSpriteBatchNode*)[proxy.klass alloc] initWithTexture:arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_insertChild_inAtlasAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real insertChild:arg0 inAtlasAtIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_insertQuadFromSprite_quadIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real insertQuadFromSprite:arg0 quadIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: NSUInteger (u)
JSBool JSB_CCSpriteBatchNode_rebuildIndexInOrder_atlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSUInteger ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real rebuildIndexInOrder:arg0 atlasIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: CCSprite*, BOOL
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeChild:arg0  ];
	}
	else if( argc == 2 ) {
		CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeChild:arg0 cleanup:(BOOL)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, BOOL
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_removeChildAtIndex_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; JSBool arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeChildAtIndex:(NSUInteger)arg0 cleanup:(BOOL)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_removeSpriteFromAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeSpriteFromAtlas:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_reorderBatch_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real reorderBatch:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real setTextureAtlas:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCSpriteBatchNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_updateQuadFromSprite_quadIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real updateQuadFromSprite:arg0 quadIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCSpriteBatchNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCSpriteBatchNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCSpriteBatchNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSpriteBatchNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSpriteBatchNode_class->name = name;
	JSB_CCSpriteBatchNode_class->addProperty = JS_PropertyStub;
	JSB_CCSpriteBatchNode_class->delProperty = JS_PropertyStub;
	JSB_CCSpriteBatchNode_class->getProperty = JS_PropertyStub;
	JSB_CCSpriteBatchNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSpriteBatchNode_class->enumerate = JS_EnumerateStub;
	JSB_CCSpriteBatchNode_class->resolve = JS_ResolveStub;
	JSB_CCSpriteBatchNode_class->convert = JS_ConvertStub;
	JSB_CCSpriteBatchNode_class->finalize = JSB_CCSpriteBatchNode_finalize;
	JSB_CCSpriteBatchNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addSpriteWithoutQuadZTag", JSB_CCSpriteBatchNode_addSpriteWithoutQuad_z_tag_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("appendChild", JSB_CCSpriteBatchNode_appendChild_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("atlasIndexForChildAtZ", JSB_CCSpriteBatchNode_atlasIndexForChild_atZ_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDescendants", JSB_CCSpriteBatchNode_descendants, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("increaseAtlasCapacity", JSB_CCSpriteBatchNode_increaseAtlasCapacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCSpriteBatchNode_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTexture", JSB_CCSpriteBatchNode_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("insertChildInAtlasAtIndex", JSB_CCSpriteBatchNode_insertChild_inAtlasAtIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("insertQuadFromSpriteQuadIndex", JSB_CCSpriteBatchNode_insertQuadFromSprite_quadIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("rebuildIndexInOrderAtlasIndex", JSB_CCSpriteBatchNode_rebuildIndexInOrder_atlasIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeChild", JSB_CCSpriteBatchNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeChildAtIndex", JSB_CCSpriteBatchNode_removeChildAtIndex_cleanup_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFromAtlas", JSB_CCSpriteBatchNode_removeSpriteFromAtlas_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reorderBatch", JSB_CCSpriteBatchNode_reorderBatch_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCSpriteBatchNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSB_CCSpriteBatchNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSB_CCSpriteBatchNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateQuadFromSpriteQuadIndex", JSB_CCSpriteBatchNode_updateQuadFromSprite_quadIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCSpriteBatchNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCSpriteBatchNode_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSpriteBatchNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSpriteBatchNode_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithTexture", JSB_CCSpriteBatchNode_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSpriteBatchNode_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCSpriteBatchNode_class, JSB_CCSpriteBatchNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSpriteBatchNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSpriteBatchNode_class, JSB_CCSpriteBatchNode_object, NULL);
	JSB_CCSpriteBatchNode *proxy = [[JSB_CCSpriteBatchNode alloc] initWithJSObject:jsobj class:[CCSpriteBatchNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXLayer
 */
#pragma mark - CCTMXLayer

JSClass* JSB_CCTMXLayer_class = NULL;
JSObject* JSB_CCTMXLayer_object = NULL;
// Constructor
JSBool JSB_CCTMXLayer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTMXLayer createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTMXLayer_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTMXLayer)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTMXLayer_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTMXLayer *proxy = [[JSB_CCTMXLayer alloc] initWithJSObject:obj class:[CCTMXLayer class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSB_CCTMXLayer_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real addChild:arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*, CCTMXLayerInfo*, CCTMXMapInfo*
// Ret value: None (None)
JSBool JSB_CCTMXLayer_initWithTilesetInfo_layerInfo_mapInfo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = [(CCTMXLayer*)[proxy.klass alloc] initWithTilesetInfo:arg0 layerInfo:arg1 mapInfo:arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTMXLayer_layerName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTMXLayer_layerOrientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerOrientation ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXLayer_layerSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*, CCTMXLayerInfo*, CCTMXMapInfo*
// Ret value: CCTMXLayer* (o)
JSBool JSB_CCTMXLayer_layerWithTilesetInfo_layerInfo_mapInfo__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer layerWithTilesetInfo:arg0 layerInfo:arg1 mapInfo:arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXLayer_mapTileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real mapTileSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint (N/A)
JSBool JSB_CCTMXLayer_positionAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CGPoint ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real positionAt:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXLayer_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real properties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSObject* (o)
JSBool JSB_CCTMXLayer_propertyNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSObject* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real propertyNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTMXLayer_releaseMap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real releaseMap ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCTMXLayer_removeTileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real removeTileAt:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setLayerName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setLayerOrientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerOrientation:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setLayerSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setMapTileSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setMapTileSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: uint32_t, CGPoint, ccTMXTileFlags
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setTileGID_at_withFlags_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; CGPoint arg1; int32_t arg2; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 2 ) {
		CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileGID:(uint32_t)arg0 at:(CGPoint)arg1  ];
	}
	else if( argc == 3 ) {
		CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileGID:(uint32_t)arg0 at:(CGPoint)arg1 withFlags:(ccTMXTileFlags)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setTileset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileset:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTMXLayer_setupTiles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setupTiles ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CCSprite* (o)
JSBool JSB_CCTMXLayer_tileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSprite* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileAt:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: uint32_t (u)
JSBool JSB_CCTMXLayer_tileGIDAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	uint32_t ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileGIDAt:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTMXTilesetInfo* (o)
JSBool JSB_CCTMXLayer_tileset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTMXTilesetInfo* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileset ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTMXLayer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTMXLayer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTMXLayer_class->name = name;
	JSB_CCTMXLayer_class->addProperty = JS_PropertyStub;
	JSB_CCTMXLayer_class->delProperty = JS_PropertyStub;
	JSB_CCTMXLayer_class->getProperty = JS_PropertyStub;
	JSB_CCTMXLayer_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTMXLayer_class->enumerate = JS_EnumerateStub;
	JSB_CCTMXLayer_class->resolve = JS_ResolveStub;
	JSB_CCTMXLayer_class->convert = JS_ConvertStub;
	JSB_CCTMXLayer_class->finalize = JSB_CCTMXLayer_finalize;
	JSB_CCTMXLayer_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChildZTag", JSB_CCTMXLayer_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTilesetInfoLayerInfoMapInfo", JSB_CCTMXLayer_initWithTilesetInfo_layerInfo_mapInfo_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLayerName", JSB_CCTMXLayer_layerName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLayerOrientation", JSB_CCTMXLayer_layerOrientation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLayerSize", JSB_CCTMXLayer_layerSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMapTileSize", JSB_CCTMXLayer_mapTileSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("positionAt", JSB_CCTMXLayer_positionAt_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSB_CCTMXLayer_properties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperty", JSB_CCTMXLayer_propertyNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("releaseMap", JSB_CCTMXLayer_releaseMap, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeTileAt", JSB_CCTMXLayer_removeTileAt_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLayerName", JSB_CCTMXLayer_setLayerName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLayerOrientation", JSB_CCTMXLayer_setLayerOrientation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLayerSize", JSB_CCTMXLayer_setLayerSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMapTileSize", JSB_CCTMXLayer_setMapTileSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSB_CCTMXLayer_setProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTileGID", JSB_CCTMXLayer_setTileGID_at_withFlags_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTileset", JSB_CCTMXLayer_setTileset_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setupTiles", JSB_CCTMXLayer_setupTiles, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileAt", JSB_CCTMXLayer_tileAt_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileGIDAt", JSB_CCTMXLayer_tileGIDAt_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileset", JSB_CCTMXLayer_tileset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileFlagsAt", JSB_CCTMXLayer_getTileFlagsAt, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTMXLayer_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("layerWithTilesetInfoLayerInfoMapInfo", JSB_CCTMXLayer_layerWithTilesetInfo_layerInfo_mapInfo__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTMXLayer_object = JS_InitClass(cx, globalObj, JSB_CCSpriteBatchNode_object, JSB_CCTMXLayer_class, JSB_CCTMXLayer_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTMXLayer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTMXLayer_class, JSB_CCTMXLayer_object, NULL);
	JSB_CCTMXLayer *proxy = [[JSB_CCTMXLayer alloc] initWithJSObject:jsobj class:[CCTMXLayer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTexture2D
 */
#pragma mark - CCTexture2D

JSClass* JSB_CCTexture2D_class = NULL;
JSObject* JSB_CCTexture2D_object = NULL;
// Constructor
JSBool JSB_CCTexture2D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTexture2D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTexture2D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTexture2D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTexture2D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTexture2D *proxy = [[JSB_CCTexture2D alloc] initWithJSObject:obj class:[CCTexture2D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCTexture2D_PVRImagesHavePremultipliedAlpha__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[CCTexture2D PVRImagesHavePremultipliedAlpha:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTexture2D_bitsPerPixelForFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real bitsPerPixelForFormat ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2DPixelFormat
// Ret value: NSUInteger (u)
JSBool JSB_CCTexture2D_bitsPerPixelForFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSUInteger ret_val;

	ret_val = [CCTexture2D bitsPerPixelForFormat:(CCTexture2DPixelFormat)arg0  ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTexture2D_contentSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real contentSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTexture2D_contentSizeInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real contentSizeInPixels ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSB_CCTexture2D_defaultAlphaPixelFormat_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	ret_val = [CCTexture2D defaultAlphaPixelFormat ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCTexture2D_drawAtPoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real drawAtPoint:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCTexture2D_drawInRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real drawInRect:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTexture2D_generateMipmap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real generateMipmap ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTexture2D_hasPremultipliedAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real hasPremultipliedAlpha ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCTexture2D_initWithPVRFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithPVRFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, CCFontDefinition*
// Ret value: None (None)
JSBool JSB_CCTexture2D_initWithString_fontDef_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CCFontDefinition* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CCFontDefinition( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontDef:(CCFontDefinition*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat
// Ret value: None (None)
JSBool JSB_CCTexture2D_initWithString_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCVerticalTextAlignment
// Ret value: None (None)
JSBool JSB_CCTexture2D_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode
// Ret value: None (None)
JSBool JSB_CCTexture2D_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 7, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; CGSize arg3; int32_t arg4; int32_t arg5; int32_t arg6; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg6 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2 dimensions:(CGSize)arg3 hAlignment:(CCTextAlignment)arg4 vAlignment:(CCVerticalTextAlignment)arg5 lineBreakMode:(CCLineBreakMode)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLfloat (d)
JSBool JSB_CCTexture2D_maxS(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLfloat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real maxS ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLfloat (d)
JSBool JSB_CCTexture2D_maxT(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLfloat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real maxT ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint (u)
JSBool JSB_CCTexture2D_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLuint ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real name ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSB_CCTexture2D_pixelFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelFormat ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTexture2D_pixelsHigh(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelsHigh ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTexture2D_pixelsWide(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelsWide ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTexture2D_setAliasTexParameters(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setAliasTexParameters ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTexture2D_setAntiAliasTexParameters(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setAntiAliasTexParameters ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2DPixelFormat
// Ret value: void (None)
JSBool JSB_CCTexture2D_setDefaultAlphaPixelFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[CCTexture2D setDefaultAlphaPixelFormat:(CCTexture2DPixelFormat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSB_CCTexture2D_setMaxS_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setMaxS:(GLfloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSB_CCTexture2D_setMaxT_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setMaxT:(GLfloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccResolutionType
// Ret value: void (None)
JSBool JSB_CCTexture2D_setResolutionType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setResolutionType:(ccResolutionType)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSB_CCTexture2D_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setShaderProgram:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSB_CCTexture2D_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTexture2D_stringForFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real stringForFormat ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_CCTexture2D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTexture2D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTexture2D_class->name = name;
	JSB_CCTexture2D_class->addProperty = JS_PropertyStub;
	JSB_CCTexture2D_class->delProperty = JS_PropertyStub;
	JSB_CCTexture2D_class->getProperty = JS_PropertyStub;
	JSB_CCTexture2D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTexture2D_class->enumerate = JS_EnumerateStub;
	JSB_CCTexture2D_class->resolve = JS_ResolveStub;
	JSB_CCTexture2D_class->convert = JS_ConvertStub;
	JSB_CCTexture2D_class->finalize = JSB_CCTexture2D_finalize;
	JSB_CCTexture2D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("bitsPerPixelForFormat", JSB_CCTexture2D_bitsPerPixelForFormat, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("contentSize", JSB_CCTexture2D_contentSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getContentSizeInPixels", JSB_CCTexture2D_contentSizeInPixels, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawAtPoint", JSB_CCTexture2D_drawAtPoint_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawInRect", JSB_CCTexture2D_drawInRect_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("generateMipmap", JSB_CCTexture2D_generateMipmap, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getHasPremultipliedAlpha", JSB_CCTexture2D_hasPremultipliedAlpha, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithPVRFile", JSB_CCTexture2D_initWithPVRFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontDef", JSB_CCTexture2D_initWithString_fontDef_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSize", JSB_CCTexture2D_initWithString_fontName_fontSize_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignmentVAlignment", JSB_CCTexture2D_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSizeDimensionsHAlignmentVAlignmentLineBreakMode", JSB_CCTexture2D_initWithString_fontName_fontSize_dimensions_hAlignment_vAlignment_lineBreakMode_, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxS", JSB_CCTexture2D_maxS, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxT", JSB_CCTexture2D_maxT, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getName", JSB_CCTexture2D_name, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPixelFormat", JSB_CCTexture2D_pixelFormat, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPixelsHigh", JSB_CCTexture2D_pixelsHigh, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPixelsWide", JSB_CCTexture2D_pixelsWide, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAliasTexParameters", JSB_CCTexture2D_setAliasTexParameters, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAntiAliasTexParameters", JSB_CCTexture2D_setAntiAliasTexParameters, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMaxS", JSB_CCTexture2D_setMaxS_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMaxT", JSB_CCTexture2D_setMaxT_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setResolutionType", JSB_CCTexture2D_setResolutionType_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSB_CCTexture2D_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexParameters", JSB_CCTexture2D_setTexParameters_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSB_CCTexture2D_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("stringForFormat", JSB_CCTexture2D_stringForFormat, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTexture2D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("PVRImagesHavePremultipliedAlpha", JSB_CCTexture2D_PVRImagesHavePremultipliedAlpha__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("bitsPerPixelForFormat", JSB_CCTexture2D_bitsPerPixelForFormat__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDefaultAlphaPixelFormat", JSB_CCTexture2D_defaultAlphaPixelFormat_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDefaultAlphaPixelFormat", JSB_CCTexture2D_setDefaultAlphaPixelFormat__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTexture2D_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTexture2D_class, JSB_CCTexture2D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTexture2D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTexture2D_class, JSB_CCTexture2D_object, NULL);
	JSB_CCTexture2D *proxy = [[JSB_CCTexture2D alloc] initWithJSObject:jsobj class:[CCTexture2D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAccelDeccelAmplitude
 */
#pragma mark - CCAccelDeccelAmplitude

JSClass* JSB_CCAccelDeccelAmplitude_class = NULL;
JSObject* JSB_CCAccelDeccelAmplitude_object = NULL;
// Constructor
JSBool JSB_CCAccelDeccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAccelDeccelAmplitude createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAccelDeccelAmplitude_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAccelDeccelAmplitude)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAccelDeccelAmplitude_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAccelDeccelAmplitude *proxy = [[JSB_CCAccelDeccelAmplitude alloc] initWithJSObject:obj class:[CCAccelDeccelAmplitude class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: CCAccelDeccelAmplitude* (o)
JSBool JSB_CCAccelDeccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAccelDeccelAmplitude* ret_val;

	ret_val = [CCAccelDeccelAmplitude actionWithAction:arg0 duration:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSB_CCAccelDeccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAccelDeccelAmplitude *real = [(CCAccelDeccelAmplitude*)[proxy.klass alloc] initWithAction:arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAccelDeccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAccelDeccelAmplitude *real = (CCAccelDeccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCAccelDeccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAccelDeccelAmplitude *real = (CCAccelDeccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCAccelDeccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAccelDeccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAccelDeccelAmplitude_class->name = name;
	JSB_CCAccelDeccelAmplitude_class->addProperty = JS_PropertyStub;
	JSB_CCAccelDeccelAmplitude_class->delProperty = JS_PropertyStub;
	JSB_CCAccelDeccelAmplitude_class->getProperty = JS_PropertyStub;
	JSB_CCAccelDeccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAccelDeccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSB_CCAccelDeccelAmplitude_class->resolve = JS_ResolveStub;
	JSB_CCAccelDeccelAmplitude_class->convert = JS_ConvertStub;
	JSB_CCAccelDeccelAmplitude_class->finalize = JSB_CCAccelDeccelAmplitude_finalize;
	JSB_CCAccelDeccelAmplitude_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSB_CCAccelDeccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRate", JSB_CCAccelDeccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_CCAccelDeccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAccelDeccelAmplitude_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSB_CCAccelDeccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAccelDeccelAmplitude_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCAccelDeccelAmplitude_class, JSB_CCAccelDeccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAccelDeccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAccelDeccelAmplitude_class, JSB_CCAccelDeccelAmplitude_object, NULL);
	JSB_CCAccelDeccelAmplitude *proxy = [[JSB_CCAccelDeccelAmplitude alloc] initWithJSObject:jsobj class:[CCAccelDeccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpTiles3D
 */
#pragma mark - CCJumpTiles3D

JSClass* JSB_CCJumpTiles3D_class = NULL;
JSObject* JSB_CCJumpTiles3D_object = NULL;
// Constructor
JSBool JSB_CCJumpTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCJumpTiles3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCJumpTiles3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCJumpTiles3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCJumpTiles3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCJumpTiles3D *proxy = [[JSB_CCJumpTiles3D alloc] initWithJSObject:obj class:[CCJumpTiles3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: CCJumpTiles3D* (o)
JSBool JSB_CCJumpTiles3D_actionWithDuration_size_jumps_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCJumpTiles3D* ret_val;

	ret_val = [CCJumpTiles3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 jumps:(NSUInteger)arg2 amplitude:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCJumpTiles3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCJumpTiles3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: None (None)
JSBool JSB_CCJumpTiles3D_initWithDuration_size_jumps_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCJumpTiles3D *real = [(CCJumpTiles3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 jumps:(NSUInteger)arg2 amplitude:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCJumpTiles3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCJumpTiles3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCJumpTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCJumpTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCJumpTiles3D_class->name = name;
	JSB_CCJumpTiles3D_class->addProperty = JS_PropertyStub;
	JSB_CCJumpTiles3D_class->delProperty = JS_PropertyStub;
	JSB_CCJumpTiles3D_class->getProperty = JS_PropertyStub;
	JSB_CCJumpTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCJumpTiles3D_class->enumerate = JS_EnumerateStub;
	JSB_CCJumpTiles3D_class->resolve = JS_ResolveStub;
	JSB_CCJumpTiles3D_class->convert = JS_ConvertStub;
	JSB_CCJumpTiles3D_class->finalize = JSB_CCJumpTiles3D_finalize;
	JSB_CCJumpTiles3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCJumpTiles3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCJumpTiles3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizeJumpsAmplitude", JSB_CCJumpTiles3D_initWithDuration_size_jumps_amplitude_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCJumpTiles3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCJumpTiles3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCJumpTiles3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCJumpTiles3D_actionWithDuration_size_jumps_amplitude__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCJumpTiles3D_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCJumpTiles3D_class, JSB_CCJumpTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCJumpTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCJumpTiles3D_class, JSB_CCJumpTiles3D_object, NULL);
	JSB_CCJumpTiles3D *proxy = [[JSB_CCJumpTiles3D alloc] initWithJSObject:jsobj class:[CCJumpTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrid3DAction
 */
#pragma mark - CCGrid3DAction

JSClass* JSB_CCGrid3DAction_class = NULL;
JSObject* JSB_CCGrid3DAction_object = NULL;
// Constructor
JSBool JSB_CCGrid3DAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGrid3DAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGrid3DAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGrid3DAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGrid3DAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGrid3DAction *proxy = [[JSB_CCGrid3DAction alloc] initWithJSObject:obj class:[CCGrid3DAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSB_CCGrid3DAction_originalVertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccVertex3F ret_val;

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	ret_val = [real originalVertex:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 3, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: CGPoint, ccVertex3F
// Ret value: void (None)
JSBool JSB_CCGrid3DAction_setVertex_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; ccVertex3F arg1; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JSB_jsval_to_struct( cx, *argvp++, &arg1, sizeof(ccVertex3F) );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	[real setVertex:(CGPoint)arg0 vertex:(ccVertex3F)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSB_CCGrid3DAction_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccVertex3F ret_val;

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	ret_val = [real vertex:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 3, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCGrid3DAction* (o)
JSBool JSB_CCGrid3DAction_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGrid3DAction* ret_val;

	ret_val = [CCGrid3DAction actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCGrid3DAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGrid3DAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGrid3DAction_class->name = name;
	JSB_CCGrid3DAction_class->addProperty = JS_PropertyStub;
	JSB_CCGrid3DAction_class->delProperty = JS_PropertyStub;
	JSB_CCGrid3DAction_class->getProperty = JS_PropertyStub;
	JSB_CCGrid3DAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGrid3DAction_class->enumerate = JS_EnumerateStub;
	JSB_CCGrid3DAction_class->resolve = JS_ResolveStub;
	JSB_CCGrid3DAction_class->convert = JS_ConvertStub;
	JSB_CCGrid3DAction_class->finalize = JSB_CCGrid3DAction_finalize;
	JSB_CCGrid3DAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("originalVertex", JSB_CCGrid3DAction_originalVertex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVertexVertex", JSB_CCGrid3DAction_setVertex_vertex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("vertex", JSB_CCGrid3DAction_vertex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGrid3DAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationSize", JSB_CCGrid3DAction_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCGrid3DAction_object = JS_InitClass(cx, globalObj, JSB_CCGridAction_object, JSB_CCGrid3DAction_class, JSB_CCGrid3DAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGrid3DAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGrid3DAction_class, JSB_CCGrid3DAction_object, NULL);
	JSB_CCGrid3DAction *proxy = [[JSB_CCGrid3DAction alloc] initWithJSObject:jsobj class:[CCGrid3DAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItem
 */
#pragma mark - CCMenuItem

JSClass* JSB_CCMenuItem_class = NULL;
JSObject* JSB_CCMenuItem_object = NULL;
// Constructor
JSBool JSB_CCMenuItem_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItem createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItem_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItem)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItem_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItem *proxy = [[JSB_CCMenuItem alloc] initWithJSObject:obj class:[CCMenuItem class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenuItem_activate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real activate ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSB_CCMenuItem_activeArea(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGRect ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real activeArea ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGRect( cx, (CGRect)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenuItem_cleanup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real cleanup ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: None (None)
JSBool JSB_CCMenuItem_initWithBlock_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= JSB_jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItem *real = [(CCMenuItem*)[proxy.klass alloc] initWithBlock:(void (^)(id))arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItem_isEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real isEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItem_isSelected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real isSelected ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItem* (o)
JSBool JSB_CCMenuItem_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= JSB_jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItem* ret_val;

	ret_val = [CCMenuItem itemWithBlock:(void (^)(id))arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItem_releaseBlockAtCleanup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real releaseBlockAtCleanup ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenuItem_selected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real selected ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCMenuItem_setActiveArea_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real setActiveArea:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItem_setIsEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real setIsEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItem_setReleaseBlockAtCleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real setReleaseBlockAtCleanup:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMenuItem_unselected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real unselected ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItem_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItem_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItem_class->name = name;
	JSB_CCMenuItem_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItem_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItem_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItem_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItem_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItem_class->resolve = JS_ResolveStub;
	JSB_CCMenuItem_class->convert = JS_ConvertStub;
	JSB_CCMenuItem_class->finalize = JSB_CCMenuItem_finalize;
	JSB_CCMenuItem_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("activate", JSB_CCMenuItem_activate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getActiveArea", JSB_CCMenuItem_activeArea, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("cleanup", JSB_CCMenuItem_cleanup, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithBlock", JSB_CCMenuItem_initWithBlock_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isEnabled", JSB_CCMenuItem_isEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsSelected", JSB_CCMenuItem_isSelected, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getReleaseBlockAtCleanup", JSB_CCMenuItem_releaseBlockAtCleanup, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("selected", JSB_CCMenuItem_selected, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setActiveArea", JSB_CCMenuItem_setActiveArea_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCallback", JSB_CCMenuItem_setBlock_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEnabled", JSB_CCMenuItem_setIsEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setReleaseBlockAtCleanup", JSB_CCMenuItem_setReleaseBlockAtCleanup_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unselected", JSB_CCMenuItem_unselected, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItem_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithBlock", JSB_CCMenuItem_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItem_object = JS_InitClass(cx, globalObj, JSB_CCNodeRGBA_object, JSB_CCMenuItem_class, JSB_CCMenuItem_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItem

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItem_class, JSB_CCMenuItem_object, NULL);
	JSB_CCMenuItem *proxy = [[JSB_CCMenuItem alloc] initWithJSObject:jsobj class:[CCMenuItem class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemSprite
 */
#pragma mark - CCMenuItemSprite

JSClass* JSB_CCMenuItemSprite_class = NULL;
JSObject* JSB_CCMenuItemSprite_object = NULL;
// Constructor
JSBool JSB_CCMenuItemSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItemSprite createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItemSprite_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItemSprite)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItemSprite_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItemSprite *proxy = [[JSB_CCMenuItemSprite alloc] initWithJSObject:obj class:[CCMenuItemSprite class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCMenuItemSprite_disabledImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real disabledImage ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*
// Ret value: CCMenuItemSprite* (o)
JSBool JSB_CCMenuItemSprite_itemWithNormalSprite_selectedSprite__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItemSprite* ret_val;

	ret_val = [CCMenuItemSprite itemWithNormalSprite:arg0 selectedSprite:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCMenuItemSprite_normalImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real normalImage ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCMenuItemSprite_selectedImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real selectedImage ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setDisabledImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setDisabledImage:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setNormalImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setNormalImage:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setSelectedImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setSelectedImage:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCMenuItemSprite_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCMenuItemSprite_displayedColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real displayedColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCMenuItemSprite_displayedOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real displayedOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemSprite_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemSprite_isCascadeColorEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real isCascadeColorEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemSprite_isCascadeOpacityEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real isCascadeOpacityEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCMenuItemSprite_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setCascadeColorEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setCascadeColorEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setCascadeOpacityEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setCascadeOpacityEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_updateDisplayedColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real updateDisplayedColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCMenuItemSprite_updateDisplayedOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real updateDisplayedOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItemSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItemSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItemSprite_class->name = name;
	JSB_CCMenuItemSprite_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItemSprite_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItemSprite_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItemSprite_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItemSprite_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItemSprite_class->resolve = JS_ResolveStub;
	JSB_CCMenuItemSprite_class->convert = JS_ConvertStub;
	JSB_CCMenuItemSprite_class->finalize = JSB_CCMenuItemSprite_finalize;
	JSB_CCMenuItemSprite_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDisabledImage", JSB_CCMenuItemSprite_disabledImage, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCMenuItemSprite_initWithNormalSprite_selectedSprite_disabledSprite_block_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNormalImage", JSB_CCMenuItemSprite_normalImage, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSelectedImage", JSB_CCMenuItemSprite_selectedImage, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisabledImage", JSB_CCMenuItemSprite_setDisabledImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setNormalImage", JSB_CCMenuItemSprite_setNormalImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSelectedImage", JSB_CCMenuItemSprite_setSelectedImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getColor", JSB_CCMenuItemSprite_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedColor", JSB_CCMenuItemSprite_displayedColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedOpacity", JSB_CCMenuItemSprite_displayedOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCMenuItemSprite_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeColorEnabled", JSB_CCMenuItemSprite_isCascadeColorEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeOpacityEnabled", JSB_CCMenuItemSprite_isCascadeOpacityEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSB_CCMenuItemSprite_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeColorEnabled", JSB_CCMenuItemSprite_setCascadeColorEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeOpacityEnabled", JSB_CCMenuItemSprite_setCascadeOpacityEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCMenuItemSprite_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCMenuItemSprite_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCMenuItemSprite_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedColor", JSB_CCMenuItemSprite_updateDisplayedColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedOpacity", JSB_CCMenuItemSprite_updateDisplayedOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItemSprite_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithNormalSpriteSelectedSprite", JSB_CCMenuItemSprite_itemWithNormalSprite_selectedSprite__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCMenuItemSprite_itemWithNormalSprite_selectedSprite_disabledSprite_block__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItemSprite_object = JS_InitClass(cx, globalObj, JSB_CCMenuItem_object, JSB_CCMenuItemSprite_class, JSB_CCMenuItemSprite_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItemSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItemSprite_class, JSB_CCMenuItemSprite_object, NULL);
	JSB_CCMenuItemSprite *proxy = [[JSB_CCMenuItemSprite alloc] initWithJSObject:jsobj class:[CCMenuItemSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemImage
 */
#pragma mark - CCMenuItemImage

JSClass* JSB_CCMenuItemImage_class = NULL;
JSObject* JSB_CCMenuItemImage_object = NULL;
// Constructor
JSBool JSB_CCMenuItemImage_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItemImage createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItemImage_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItemImage)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItemImage_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItemImage *proxy = [[JSB_CCMenuItemImage alloc] initWithJSObject:obj class:[CCMenuItemImage class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCMenuItemImage* (o)
JSBool JSB_CCMenuItemImage_itemWithNormalImage_selectedImage__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalImage:(NSString*)arg0 selectedImage:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, NSString*
// Ret value: CCMenuItemImage* (o)
JSBool JSB_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; NSString* arg2; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalImage:(NSString*)arg0 selectedImage:(NSString*)arg1 disabledImage:(NSString*)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCMenuItemImage_setDisabledSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setDisabledSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCMenuItemImage_setNormalSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setNormalSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCMenuItemImage_setSelectedSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setSelectedSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItemImage_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItemImage_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItemImage_class->name = name;
	JSB_CCMenuItemImage_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItemImage_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItemImage_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItemImage_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItemImage_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItemImage_class->resolve = JS_ResolveStub;
	JSB_CCMenuItemImage_class->convert = JS_ConvertStub;
	JSB_CCMenuItemImage_class->finalize = JSB_CCMenuItemImage_finalize;
	JSB_CCMenuItemImage_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCMenuItemImage_initWithNormalImage_selectedImage_disabledImage_block_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisabledSpriteFrame", JSB_CCMenuItemImage_setDisabledSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setNormalSpriteFrame", JSB_CCMenuItemImage_setNormalSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSelectedSpriteFrame", JSB_CCMenuItemImage_setSelectedSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItemImage_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithNormalImageSelectedImage", JSB_CCMenuItemImage_itemWithNormalImage_selectedImage__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("itemWithNormalImageSelectedImageDisabledImage", JSB_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage_block__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItemImage_object = JS_InitClass(cx, globalObj, JSB_CCMenuItemSprite_object, JSB_CCMenuItemImage_class, JSB_CCMenuItemImage_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItemImage

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItemImage_class, JSB_CCMenuItemImage_object, NULL);
	JSB_CCMenuItemImage *proxy = [[JSB_CCMenuItemImage alloc] initWithJSObject:jsobj class:[CCMenuItemImage class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleBatchNode
 */
#pragma mark - CCParticleBatchNode

JSClass* JSB_CCParticleBatchNode_class = NULL;
JSObject* JSB_CCParticleBatchNode_object = NULL;
// Constructor
JSBool JSB_CCParticleBatchNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleBatchNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleBatchNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleBatchNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleBatchNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleBatchNode *proxy = [[JSB_CCParticleBatchNode alloc] initWithJSObject:obj class:[CCParticleBatchNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCParticleSystem*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real addChild:arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCParticleBatchNode* (o)
JSBool JSB_CCParticleBatchNode_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCParticleBatchNode batchNodeWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCParticleBatchNode batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCParticleBatchNode* (o)
JSBool JSB_CCParticleBatchNode_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCParticleBatchNode batchNodeWithTexture:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCParticleBatchNode batchNodeWithTexture:arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_disableParticle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real disableParticle:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCParticleBatchNode_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = [(CCParticleBatchNode*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCParticleBatchNode_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = [(CCParticleBatchNode*)[proxy.klass alloc] initWithTexture:arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCParticleSystem*, NSUInteger
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_insertChild_inAtlasAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real insertChild:arg0 inAtlasAtIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCParticleSystem*, BOOL
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real removeChild:arg0  ];
	}
	else if( argc == 2 ) {
		CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real removeChild:arg0 cleanup:(BOOL)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real setTextureAtlas:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCParticleBatchNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCParticleBatchNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCParticleBatchNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleBatchNode* (o)
JSBool JSB_CCParticleBatchNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleBatchNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleBatchNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleBatchNode_class->name = name;
	JSB_CCParticleBatchNode_class->addProperty = JS_PropertyStub;
	JSB_CCParticleBatchNode_class->delProperty = JS_PropertyStub;
	JSB_CCParticleBatchNode_class->getProperty = JS_PropertyStub;
	JSB_CCParticleBatchNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleBatchNode_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleBatchNode_class->resolve = JS_ResolveStub;
	JSB_CCParticleBatchNode_class->convert = JS_ConvertStub;
	JSB_CCParticleBatchNode_class->finalize = JSB_CCParticleBatchNode_finalize;
	JSB_CCParticleBatchNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChildZTag", JSB_CCParticleBatchNode_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("disableParticle", JSB_CCParticleBatchNode_disableParticle_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCParticleBatchNode_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTexture", JSB_CCParticleBatchNode_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("insertChildInAtlasAtIndex", JSB_CCParticleBatchNode_insertChild_inAtlasAtIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeChild", JSB_CCParticleBatchNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCParticleBatchNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSB_CCParticleBatchNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSB_CCParticleBatchNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCParticleBatchNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCParticleBatchNode_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleBatchNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCParticleBatchNode_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithTexture", JSB_CCParticleBatchNode_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCParticleBatchNode_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleBatchNode_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCParticleBatchNode_class, JSB_CCParticleBatchNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleBatchNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleBatchNode_class, JSB_CCParticleBatchNode_object, NULL);
	JSB_CCParticleBatchNode *proxy = [[JSB_CCParticleBatchNode alloc] initWithJSObject:jsobj class:[CCParticleBatchNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionCrossFade
 */
#pragma mark - CCTransitionCrossFade

JSClass* JSB_CCTransitionCrossFade_class = NULL;
JSObject* JSB_CCTransitionCrossFade_object = NULL;
// Constructor
JSBool JSB_CCTransitionCrossFade_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionCrossFade createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionCrossFade_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionCrossFade)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionCrossFade_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionCrossFade *proxy = [[JSB_CCTransitionCrossFade alloc] initWithJSObject:obj class:[CCTransitionCrossFade class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionCrossFade_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionCrossFade *real = [(CCTransitionCrossFade*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionCrossFade* (o)
JSBool JSB_CCTransitionCrossFade_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionCrossFade* ret_val;

	ret_val = [CCTransitionCrossFade transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionCrossFade* (o)
JSBool JSB_CCTransitionCrossFade_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionCrossFade* ret_val;

	ret_val = [CCTransitionCrossFade node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionCrossFade_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionCrossFade_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionCrossFade_class->name = name;
	JSB_CCTransitionCrossFade_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionCrossFade_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionCrossFade_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionCrossFade_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionCrossFade_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionCrossFade_class->resolve = JS_ResolveStub;
	JSB_CCTransitionCrossFade_class->convert = JS_ConvertStub;
	JSB_CCTransitionCrossFade_class->finalize = JSB_CCTransitionCrossFade_finalize;
	JSB_CCTransitionCrossFade_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionCrossFade_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionCrossFade_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionCrossFade_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionCrossFade_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionCrossFade_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionCrossFade_class, JSB_CCTransitionCrossFade_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionCrossFade

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionCrossFade_class, JSB_CCTransitionCrossFade_object, NULL);
	JSB_CCTransitionCrossFade *proxy = [[JSB_CCTransitionCrossFade alloc] initWithJSObject:jsobj class:[CCTransitionCrossFade class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPageTurn3D
 */
#pragma mark - CCPageTurn3D

JSClass* JSB_CCPageTurn3D_class = NULL;
JSObject* JSB_CCPageTurn3D_object = NULL;
// Constructor
JSBool JSB_CCPageTurn3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCPageTurn3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCPageTurn3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCPageTurn3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCPageTurn3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCPageTurn3D *proxy = [[JSB_CCPageTurn3D alloc] initWithJSObject:obj class:[CCPageTurn3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCPageTurn3D_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCPageTurn3D *real = (CCPageTurn3D*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCPageTurn3D* (o)
JSBool JSB_CCPageTurn3D_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPageTurn3D* ret_val;

	ret_val = [CCPageTurn3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCPageTurn3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCPageTurn3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCPageTurn3D_class->name = name;
	JSB_CCPageTurn3D_class->addProperty = JS_PropertyStub;
	JSB_CCPageTurn3D_class->delProperty = JS_PropertyStub;
	JSB_CCPageTurn3D_class->getProperty = JS_PropertyStub;
	JSB_CCPageTurn3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCPageTurn3D_class->enumerate = JS_EnumerateStub;
	JSB_CCPageTurn3D_class->resolve = JS_ResolveStub;
	JSB_CCPageTurn3D_class->convert = JS_ConvertStub;
	JSB_CCPageTurn3D_class->finalize = JSB_CCPageTurn3D_finalize;
	JSB_CCPageTurn3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCPageTurn3D_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCPageTurn3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCPageTurn3D_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCPageTurn3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCPageTurn3D_class, JSB_CCPageTurn3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCPageTurn3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCPageTurn3D_class, JSB_CCPageTurn3D_object, NULL);
	JSB_CCPageTurn3D *proxy = [[JSB_CCPageTurn3D alloc] initWithJSObject:jsobj class:[CCPageTurn3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBMFontConfiguration
 */
#pragma mark - CCBMFontConfiguration

JSClass* JSB_CCBMFontConfiguration_class = NULL;
JSObject* JSB_CCBMFontConfiguration_object = NULL;
// Constructor
JSBool JSB_CCBMFontConfiguration_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCBMFontConfiguration createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCBMFontConfiguration_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCBMFontConfiguration)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCBMFontConfiguration_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCBMFontConfiguration *proxy = [[JSB_CCBMFontConfiguration alloc] initWithJSObject:obj class:[CCBMFontConfiguration class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCBMFontConfiguration_atlasName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCBMFontConfiguration *real = (CCBMFontConfiguration*) [proxy realObj];
	ret_val = [real atlasName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCBMFontConfiguration* (o)
JSBool JSB_CCBMFontConfiguration_configurationWithFNTFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCBMFontConfiguration* ret_val;

	ret_val = [CCBMFontConfiguration configurationWithFNTFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCBMFontConfiguration_initWithFNTfile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCBMFontConfiguration *real = [(CCBMFontConfiguration*)[proxy.klass alloc] initWithFNTfile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCBMFontConfiguration_setAtlasName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCBMFontConfiguration *real = (CCBMFontConfiguration*) [proxy realObj];
	[real setAtlasName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCBMFontConfiguration_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCBMFontConfiguration_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCBMFontConfiguration_class->name = name;
	JSB_CCBMFontConfiguration_class->addProperty = JS_PropertyStub;
	JSB_CCBMFontConfiguration_class->delProperty = JS_PropertyStub;
	JSB_CCBMFontConfiguration_class->getProperty = JS_PropertyStub;
	JSB_CCBMFontConfiguration_class->setProperty = JS_StrictPropertyStub;
	JSB_CCBMFontConfiguration_class->enumerate = JS_EnumerateStub;
	JSB_CCBMFontConfiguration_class->resolve = JS_ResolveStub;
	JSB_CCBMFontConfiguration_class->convert = JS_ConvertStub;
	JSB_CCBMFontConfiguration_class->finalize = JSB_CCBMFontConfiguration_finalize;
	JSB_CCBMFontConfiguration_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAtlasName", JSB_CCBMFontConfiguration_atlasName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithFNTfile", JSB_CCBMFontConfiguration_initWithFNTfile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAtlasName", JSB_CCBMFontConfiguration_setAtlasName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCBMFontConfiguration_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("configurationWithFNTFile", JSB_CCBMFontConfiguration_configurationWithFNTFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCBMFontConfiguration_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCBMFontConfiguration_class, JSB_CCBMFontConfiguration_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCBMFontConfiguration

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCBMFontConfiguration_class, JSB_CCBMFontConfiguration_object, NULL);
	JSB_CCBMFontConfiguration *proxy = [[JSB_CCBMFontConfiguration alloc] initWithJSObject:jsobj class:[CCBMFontConfiguration class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticIn
 */
#pragma mark - CCEaseElasticIn

JSClass* JSB_CCEaseElasticIn_class = NULL;
JSObject* JSB_CCEaseElasticIn_object = NULL;
// Constructor
JSBool JSB_CCEaseElasticIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseElasticIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseElasticIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseElasticIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseElasticIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseElasticIn *proxy = [[JSB_CCEaseElasticIn alloc] initWithJSObject:obj class:[CCEaseElasticIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseElasticIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseElasticIn *real = (CCEaseElasticIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticIn* (o)
JSBool JSB_CCEaseElasticIn_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseElasticIn* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticIn actionWithAction:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticIn actionWithAction:arg0 period:(float)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseElasticIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseElasticIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseElasticIn_class->name = name;
	JSB_CCEaseElasticIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseElasticIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseElasticIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseElasticIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseElasticIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseElasticIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseElasticIn_class->convert = JS_ConvertStub;
	JSB_CCEaseElasticIn_class->finalize = JSB_CCEaseElasticIn_finalize;
	JSB_CCEaseElasticIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseElasticIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseElasticIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseElasticIn_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseElasticIn_object = JS_InitClass(cx, globalObj, JSB_CCEaseElastic_object, JSB_CCEaseElasticIn_class, JSB_CCEaseElasticIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseElasticIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseElasticIn_class, JSB_CCEaseElasticIn_object, NULL);
	JSB_CCEaseElasticIn *proxy = [[JSB_CCEaseElasticIn alloc] initWithJSObject:jsobj class:[CCEaseElasticIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpeed
 */
#pragma mark - CCSpeed

JSClass* JSB_CCSpeed_class = NULL;
JSObject* JSB_CCSpeed_object = NULL;
// Constructor
JSBool JSB_CCSpeed_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSpeed createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSpeed_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSpeed)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSpeed_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSpeed *proxy = [[JSB_CCSpeed alloc] initWithJSObject:obj class:[CCSpeed class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, CGFloat
// Ret value: CCSpeed* (o)
JSBool JSB_CCSpeed_actionWithAction_speed__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpeed* ret_val;

	ret_val = [CCSpeed actionWithAction:arg0 speed:(CGFloat)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, CGFloat
// Ret value: None (None)
JSBool JSB_CCSpeed_initWithAction_speed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpeed *real = [(CCSpeed*)[proxy.klass alloc] initWithAction:arg0 speed:(CGFloat)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCSpeed_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	ret_val = [real innerAction ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: void (None)
JSBool JSB_CCSpeed_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	[real setInnerAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGFloat
// Ret value: void (None)
JSBool JSB_CCSpeed_setSpeed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	[real setSpeed:(CGFloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGFloat (d)
JSBool JSB_CCSpeed_speed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGFloat ret_val;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	ret_val = [real speed ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

void JSB_CCSpeed_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSpeed_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSpeed_class->name = name;
	JSB_CCSpeed_class->addProperty = JS_PropertyStub;
	JSB_CCSpeed_class->delProperty = JS_PropertyStub;
	JSB_CCSpeed_class->getProperty = JS_PropertyStub;
	JSB_CCSpeed_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSpeed_class->enumerate = JS_EnumerateStub;
	JSB_CCSpeed_class->resolve = JS_ResolveStub;
	JSB_CCSpeed_class->convert = JS_ConvertStub;
	JSB_CCSpeed_class->finalize = JSB_CCSpeed_finalize;
	JSB_CCSpeed_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionSpeed", JSB_CCSpeed_initWithAction_speed_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSB_CCSpeed_innerAction, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSB_CCSpeed_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSpeed", JSB_CCSpeed_setSpeed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpeed", JSB_CCSpeed_speed, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSpeed_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSpeed_actionWithAction_speed__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSpeed_object = JS_InitClass(cx, globalObj, JSB_CCAction_object, JSB_CCSpeed_class, JSB_CCSpeed_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSpeed

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSpeed_class, JSB_CCSpeed_object, NULL);
	JSB_CCSpeed *proxy = [[JSB_CCSpeed alloc] initWithJSObject:jsobj class:[CCSpeed class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRotateTo
 */
#pragma mark - CCRotateTo

JSClass* JSB_CCRotateTo_class = NULL;
JSObject* JSB_CCRotateTo_object = NULL;
// Constructor
JSBool JSB_CCRotateTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRotateTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRotateTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRotateTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRotateTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRotateTo *proxy = [[JSB_CCRotateTo alloc] initWithJSObject:obj class:[CCRotateTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCRotateTo* (o)
JSBool JSB_CCRotateTo_actionWithDuration_angleX_angleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRotateTo* ret_val;

	if( argc == 2 ) {
		ret_val = [CCRotateTo actionWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCRotateTo actionWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSB_CCRotateTo_initWithDuration_angle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRotateTo *real = [(CCRotateTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCRotateTo_initWithDuration_angleX_angleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRotateTo *real = [(CCRotateTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCRotateTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRotateTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRotateTo_class->name = name;
	JSB_CCRotateTo_class->addProperty = JS_PropertyStub;
	JSB_CCRotateTo_class->delProperty = JS_PropertyStub;
	JSB_CCRotateTo_class->getProperty = JS_PropertyStub;
	JSB_CCRotateTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRotateTo_class->enumerate = JS_EnumerateStub;
	JSB_CCRotateTo_class->resolve = JS_ResolveStub;
	JSB_CCRotateTo_class->convert = JS_ConvertStub;
	JSB_CCRotateTo_class->finalize = JSB_CCRotateTo_finalize;
	JSB_CCRotateTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationAngle", JSB_CCRotateTo_initWithDuration_angle_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationAngleXAngleY", JSB_CCRotateTo_initWithDuration_angleX_angleY_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRotateTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRotateTo_actionWithDuration_angleX_angleY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRotateTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCRotateTo_class, JSB_CCRotateTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRotateTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRotateTo_class, JSB_CCRotateTo_object, NULL);
	JSB_CCRotateTo *proxy = [[JSB_CCRotateTo alloc] initWithJSObject:jsobj class:[CCRotateTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionCamera
 */
#pragma mark - CCActionCamera

JSClass* JSB_CCActionCamera_class = NULL;
JSObject* JSB_CCActionCamera_object = NULL;
// Constructor
JSBool JSB_CCActionCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionCamera createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionCamera_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionCamera)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionCamera_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionCamera *proxy = [[JSB_CCActionCamera alloc] initWithJSObject:obj class:[CCActionCamera class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCActionCamera_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionCamera *real = (CCActionCamera*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCActionCamera* (o)
JSBool JSB_CCActionCamera_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionCamera* ret_val;

	ret_val = [CCActionCamera actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCActionCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionCamera_class->name = name;
	JSB_CCActionCamera_class->addProperty = JS_PropertyStub;
	JSB_CCActionCamera_class->delProperty = JS_PropertyStub;
	JSB_CCActionCamera_class->getProperty = JS_PropertyStub;
	JSB_CCActionCamera_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionCamera_class->enumerate = JS_EnumerateStub;
	JSB_CCActionCamera_class->resolve = JS_ResolveStub;
	JSB_CCActionCamera_class->convert = JS_ConvertStub;
	JSB_CCActionCamera_class->finalize = JSB_CCActionCamera_finalize;
	JSB_CCActionCamera_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCActionCamera_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionCamera_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSB_CCActionCamera_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCActionCamera_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCActionCamera_class, JSB_CCActionCamera_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionCamera_class, JSB_CCActionCamera_object, NULL);
	JSB_CCActionCamera *proxy = [[JSB_CCActionCamera alloc] initWithJSObject:jsobj class:[CCActionCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleGalaxy
 */
#pragma mark - CCParticleGalaxy

JSClass* JSB_CCParticleGalaxy_class = NULL;
JSObject* JSB_CCParticleGalaxy_object = NULL;
// Constructor
JSBool JSB_CCParticleGalaxy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleGalaxy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleGalaxy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleGalaxy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleGalaxy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleGalaxy *proxy = [[JSB_CCParticleGalaxy alloc] initWithJSObject:obj class:[CCParticleGalaxy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleGalaxy_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleGalaxy *real = [(CCParticleGalaxy*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleGalaxy* (o)
JSBool JSB_CCParticleGalaxy_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleGalaxy* (o)
JSBool JSB_CCParticleGalaxy_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleGalaxy* (o)
JSBool JSB_CCParticleGalaxy_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleGalaxy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleGalaxy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleGalaxy_class->name = name;
	JSB_CCParticleGalaxy_class->addProperty = JS_PropertyStub;
	JSB_CCParticleGalaxy_class->delProperty = JS_PropertyStub;
	JSB_CCParticleGalaxy_class->getProperty = JS_PropertyStub;
	JSB_CCParticleGalaxy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleGalaxy_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleGalaxy_class->resolve = JS_ResolveStub;
	JSB_CCParticleGalaxy_class->convert = JS_ConvertStub;
	JSB_CCParticleGalaxy_class->finalize = JSB_CCParticleGalaxy_finalize;
	JSB_CCParticleGalaxy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleGalaxy_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleGalaxy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleGalaxy_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleGalaxy_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleGalaxy_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleGalaxy_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleGalaxy_class, JSB_CCParticleGalaxy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleGalaxy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleGalaxy_class, JSB_CCParticleGalaxy_object, NULL);
	JSB_CCParticleGalaxy *proxy = [[JSB_CCParticleGalaxy alloc] initWithJSObject:jsobj class:[CCParticleGalaxy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMotionStreak
 */
#pragma mark - CCMotionStreak

JSClass* JSB_CCMotionStreak_class = NULL;
JSObject* JSB_CCMotionStreak_object = NULL;
// Constructor
JSBool JSB_CCMotionStreak_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMotionStreak createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMotionStreak_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMotionStreak)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMotionStreak_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMotionStreak *proxy = [[JSB_CCMotionStreak alloc] initWithJSObject:obj class:[CCMotionStreak class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, CCTexture2D*
// Ret value: None (None)
JSBool JSB_CCMotionStreak_initWithFade_minSeg_width_color_texture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; id arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg3 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMotionStreak *real = [(CCMotionStreak*)[proxy.klass alloc] initWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 texture:arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, NSString*
// Ret value: None (None)
JSBool JSB_CCMotionStreak_initWithFade_minSeg_width_color_textureFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; NSString* arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg3 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMotionStreak *real = [(CCMotionStreak*)[proxy.klass alloc] initWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 textureFilename:(NSString*)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMotionStreak_isFastMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real isFastMode ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCMotionStreak_reset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real reset ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMotionStreak_setFastMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setFastMode:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCMotionStreak_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, CCTexture2D*
// Ret value: CCMotionStreak* (o)
JSBool JSB_CCMotionStreak_streakWithFade_minSeg_width_color_texture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; id arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg3 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMotionStreak* ret_val;

	ret_val = [CCMotionStreak streakWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 texture:arg4  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, NSString*
// Ret value: CCMotionStreak* (o)
JSBool JSB_CCMotionStreak_streakWithFade_minSeg_width_color_textureFilename__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; NSString* arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg3 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMotionStreak* ret_val;

	ret_val = [CCMotionStreak streakWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 textureFilename:(NSString*)arg4  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCMotionStreak_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMotionStreak_tintWithColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real tintWithColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMotionStreak_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMotionStreak_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMotionStreak_class->name = name;
	JSB_CCMotionStreak_class->addProperty = JS_PropertyStub;
	JSB_CCMotionStreak_class->delProperty = JS_PropertyStub;
	JSB_CCMotionStreak_class->getProperty = JS_PropertyStub;
	JSB_CCMotionStreak_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMotionStreak_class->enumerate = JS_EnumerateStub;
	JSB_CCMotionStreak_class->resolve = JS_ResolveStub;
	JSB_CCMotionStreak_class->convert = JS_ConvertStub;
	JSB_CCMotionStreak_class->finalize = JSB_CCMotionStreak_finalize;
	JSB_CCMotionStreak_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithFadeMinSegWidthColorTexture", JSB_CCMotionStreak_initWithFade_minSeg_width_color_texture_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithFadeMinSegWidthColorTextureFilename", JSB_CCMotionStreak_initWithFade_minSeg_width_color_textureFilename_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isFastMode", JSB_CCMotionStreak_isFastMode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reset", JSB_CCMotionStreak_reset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCMotionStreak_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFastMode", JSB_CCMotionStreak_setFastMode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCMotionStreak_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCMotionStreak_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("tintWithColor", JSB_CCMotionStreak_tintWithColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMotionStreak_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("streakWithFadeMinSegWidthColorTexture", JSB_CCMotionStreak_streakWithFade_minSeg_width_color_texture__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("streakWithFadeMinSegWidthColorTextureFilename", JSB_CCMotionStreak_streakWithFade_minSeg_width_color_textureFilename__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMotionStreak_object = JS_InitClass(cx, globalObj, JSB_CCNodeRGBA_object, JSB_CCMotionStreak_class, JSB_CCMotionStreak_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMotionStreak

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMotionStreak_class, JSB_CCMotionStreak_object, NULL);
	JSB_CCMotionStreak *proxy = [[JSB_CCMotionStreak alloc] initWithJSObject:jsobj class:[CCMotionStreak class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShow
 */
#pragma mark - CCShow

JSClass* JSB_CCShow_class = NULL;
JSObject* JSB_CCShow_object = NULL;
// Constructor
JSBool JSB_CCShow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShow createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShow_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShow)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShow_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShow *proxy = [[JSB_CCShow alloc] initWithJSObject:obj class:[CCShow class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCShow_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShow *real = (CCShow*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShow* (o)
JSBool JSB_CCShow_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCShow* ret_val;

	ret_val = [CCShow action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCShow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShow_class->name = name;
	JSB_CCShow_class->addProperty = JS_PropertyStub;
	JSB_CCShow_class->delProperty = JS_PropertyStub;
	JSB_CCShow_class->getProperty = JS_PropertyStub;
	JSB_CCShow_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShow_class->enumerate = JS_EnumerateStub;
	JSB_CCShow_class->resolve = JS_ResolveStub;
	JSB_CCShow_class->convert = JS_ConvertStub;
	JSB_CCShow_class->finalize = JSB_CCShow_finalize;
	JSB_CCShow_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCShow_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShow_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCShow_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShow_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCShow_class, JSB_CCShow_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShow_class, JSB_CCShow_object, NULL);
	JSB_CCShow *proxy = [[JSB_CCShow alloc] initWithJSObject:jsobj class:[CCShow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAccelAmplitude
 */
#pragma mark - CCAccelAmplitude

JSClass* JSB_CCAccelAmplitude_class = NULL;
JSObject* JSB_CCAccelAmplitude_object = NULL;
// Constructor
JSBool JSB_CCAccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAccelAmplitude createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAccelAmplitude_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAccelAmplitude)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAccelAmplitude_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAccelAmplitude *proxy = [[JSB_CCAccelAmplitude alloc] initWithJSObject:obj class:[CCAccelAmplitude class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: CCAccelAmplitude* (o)
JSBool JSB_CCAccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAccelAmplitude* ret_val;

	ret_val = [CCAccelAmplitude actionWithAction:arg0 duration:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSB_CCAccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAccelAmplitude *real = [(CCAccelAmplitude*)[proxy.klass alloc] initWithAction:arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAccelAmplitude *real = (CCAccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCAccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAccelAmplitude *real = (CCAccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCAccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAccelAmplitude_class->name = name;
	JSB_CCAccelAmplitude_class->addProperty = JS_PropertyStub;
	JSB_CCAccelAmplitude_class->delProperty = JS_PropertyStub;
	JSB_CCAccelAmplitude_class->getProperty = JS_PropertyStub;
	JSB_CCAccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSB_CCAccelAmplitude_class->resolve = JS_ResolveStub;
	JSB_CCAccelAmplitude_class->convert = JS_ConvertStub;
	JSB_CCAccelAmplitude_class->finalize = JSB_CCAccelAmplitude_finalize;
	JSB_CCAccelAmplitude_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSB_CCAccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRate", JSB_CCAccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_CCAccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAccelAmplitude_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSB_CCAccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAccelAmplitude_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCAccelAmplitude_class, JSB_CCAccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAccelAmplitude_class, JSB_CCAccelAmplitude_object, NULL);
	JSB_CCAccelAmplitude *proxy = [[JSB_CCAccelAmplitude alloc] initWithJSObject:jsobj class:[CCAccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGridBase
 */
#pragma mark - CCGridBase

JSClass* JSB_CCGridBase_class = NULL;
JSObject* JSB_CCGridBase_object = NULL;
// Constructor
JSBool JSB_CCGridBase_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGridBase createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGridBase_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGridBase)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGridBase_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGridBase *proxy = [[JSB_CCGridBase alloc] initWithJSObject:obj class:[CCGridBase class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCGridBase_active(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real active ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCGridBase_afterDraw_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real afterDraw:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGridBase_beforeDraw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real beforeDraw ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGridBase_blit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real blit ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGridBase_calculateVertexPoints(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real calculateVertexPoints ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGrabber* (o)
JSBool JSB_CCGridBase_grabber(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGrabber* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real grabber ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCGridBase_gridSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real gridSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: CGSize, CCTexture2D*, BOOL
// Ret value: CCGridBase* (o)
JSBool JSB_CCGridBase_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; id arg1; JSBool arg2; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGridBase* ret_val;

	if( argc == 1 ) {
		ret_val = [CCGridBase gridWithSize:(CGSize)arg0  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCGridBase gridWithSize:(CGSize)arg0 texture:arg1 flippedTexture:(BOOL)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: None (None)
JSBool JSB_CCGridBase_initWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = [(CCGridBase*)[proxy.klass alloc] initWithSize:(CGSize)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CGSize, CCTexture2D*, BOOL
// Ret value: None (None)
JSBool JSB_CCGridBase_initWithSize_texture_flippedTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; id arg1; JSBool arg2; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = [(CCGridBase*)[proxy.klass alloc] initWithSize:(CGSize)arg0 texture:arg1 flippedTexture:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCGridBase_isTextureFlipped(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real isTextureFlipped ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGridBase_reuse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real reuse ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCGridBase_reuseGrid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real reuseGrid ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCGridBase_setActive_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setActive:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCGrabber*
// Ret value: void (None)
JSBool JSB_CCGridBase_setGrabber_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setGrabber:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCGridBase_setIsTextureFlipped_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setIsTextureFlipped:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSB_CCGridBase_setReuseGrid_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setReuseGrid:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSB_CCGridBase_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setShaderProgram:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCGridBase_setStep_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setStep:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCGridBase_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSB_CCGridBase_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCGridBase_step(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real step ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCGridBase_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCGridBase_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGridBase_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGridBase_class->name = name;
	JSB_CCGridBase_class->addProperty = JS_PropertyStub;
	JSB_CCGridBase_class->delProperty = JS_PropertyStub;
	JSB_CCGridBase_class->getProperty = JS_PropertyStub;
	JSB_CCGridBase_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGridBase_class->enumerate = JS_EnumerateStub;
	JSB_CCGridBase_class->resolve = JS_ResolveStub;
	JSB_CCGridBase_class->convert = JS_ConvertStub;
	JSB_CCGridBase_class->finalize = JSB_CCGridBase_finalize;
	JSB_CCGridBase_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActive", JSB_CCGridBase_active, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("afterDraw", JSB_CCGridBase_afterDraw_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("beforeDraw", JSB_CCGridBase_beforeDraw, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("blit", JSB_CCGridBase_blit, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("calculateVertexPoints", JSB_CCGridBase_calculateVertexPoints, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGrabber", JSB_CCGridBase_grabber, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getGridSize", JSB_CCGridBase_gridSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSize", JSB_CCGridBase_initWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSizeTextureFlippedTexture", JSB_CCGridBase_initWithSize_texture_flippedTexture_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIsTextureFlipped", JSB_CCGridBase_isTextureFlipped, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("reuse", JSB_CCGridBase_reuse, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getReuseGrid", JSB_CCGridBase_reuseGrid, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setActive", JSB_CCGridBase_setActive_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setGrabber", JSB_CCGridBase_setGrabber_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setIsTextureFlipped", JSB_CCGridBase_setIsTextureFlipped_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setReuseGrid", JSB_CCGridBase_setReuseGrid_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSB_CCGridBase_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStep", JSB_CCGridBase_setStep_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCGridBase_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSB_CCGridBase_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStep", JSB_CCGridBase_step, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCGridBase_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGridBase_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCGridBase_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCGridBase_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCGridBase_class, JSB_CCGridBase_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGridBase

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGridBase_class, JSB_CCGridBase_object, NULL);
	JSB_CCGridBase *proxy = [[JSB_CCGridBase alloc] initWithJSObject:jsobj class:[CCGridBase class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTiledGrid3D
 */
#pragma mark - CCTiledGrid3D

JSClass* JSB_CCTiledGrid3D_class = NULL;
JSObject* JSB_CCTiledGrid3D_object = NULL;
// Constructor
JSBool JSB_CCTiledGrid3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTiledGrid3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTiledGrid3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTiledGrid3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTiledGrid3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTiledGrid3D *proxy = [[JSB_CCTiledGrid3D alloc] initWithJSObject:obj class:[CCTiledGrid3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCTiledGrid3D* (o)
JSBool JSB_CCTiledGrid3D_gridWithSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTiledGrid3D* ret_val;

	ret_val = [CCTiledGrid3D gridWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGSize, CCTexture2D*, BOOL
// Ret value: CCTiledGrid3D* (o)
JSBool JSB_CCTiledGrid3D_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; id arg1; JSBool arg2; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTiledGrid3D* ret_val;

	ret_val = [CCTiledGrid3D gridWithSize:(CGSize)arg0 texture:arg1 flippedTexture:(BOOL)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTiledGrid3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTiledGrid3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTiledGrid3D_class->name = name;
	JSB_CCTiledGrid3D_class->addProperty = JS_PropertyStub;
	JSB_CCTiledGrid3D_class->delProperty = JS_PropertyStub;
	JSB_CCTiledGrid3D_class->getProperty = JS_PropertyStub;
	JSB_CCTiledGrid3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTiledGrid3D_class->enumerate = JS_EnumerateStub;
	JSB_CCTiledGrid3D_class->resolve = JS_ResolveStub;
	JSB_CCTiledGrid3D_class->convert = JS_ConvertStub;
	JSB_CCTiledGrid3D_class->finalize = JSB_CCTiledGrid3D_finalize;
	JSB_CCTiledGrid3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("ctor", JSB_CCTiledGrid3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("gridWithSize", JSB_CCTiledGrid3D_gridWithSize__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("gridWithSizeTextureFlippedTexture", JSB_CCTiledGrid3D_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTiledGrid3D_object = JS_InitClass(cx, globalObj, JSB_CCGridBase_object, JSB_CCTiledGrid3D_class, JSB_CCTiledGrid3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTiledGrid3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTiledGrid3D_class, JSB_CCTiledGrid3D_object, NULL);
	JSB_CCTiledGrid3D *proxy = [[JSB_CCTiledGrid3D alloc] initWithJSObject:jsobj class:[CCTiledGrid3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounce
 */
#pragma mark - CCEaseBounce

JSClass* JSB_CCEaseBounce_class = NULL;
JSObject* JSB_CCEaseBounce_object = NULL;
// Constructor
JSBool JSB_CCEaseBounce_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBounce createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBounce_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBounce)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBounce_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBounce *proxy = [[JSB_CCEaseBounce alloc] initWithJSObject:obj class:[CCEaseBounce class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: ccTime (d)
JSBool JSB_CCEaseBounce_bounceTime_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccTime ret_val;

	CCEaseBounce *real = (CCEaseBounce*) [proxy realObj];
	ret_val = [real bounceTime:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounce* (o)
JSBool JSB_CCEaseBounce_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBounce* ret_val;

	ret_val = [CCEaseBounce actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBounce_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBounce_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBounce_class->name = name;
	JSB_CCEaseBounce_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBounce_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBounce_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBounce_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBounce_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBounce_class->resolve = JS_ResolveStub;
	JSB_CCEaseBounce_class->convert = JS_ConvertStub;
	JSB_CCEaseBounce_class->finalize = JSB_CCEaseBounce_finalize;
	JSB_CCEaseBounce_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("bounceTime", JSB_CCEaseBounce_bounceTime_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBounce_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBounce_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBounce_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseBounce_class, JSB_CCEaseBounce_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBounce

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBounce_class, JSB_CCEaseBounce_object, NULL);
	JSB_CCEaseBounce *proxy = [[JSB_CCEaseBounce alloc] initWithJSObject:jsobj class:[CCEaseBounce class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceOut
 */
#pragma mark - CCEaseBounceOut

JSClass* JSB_CCEaseBounceOut_class = NULL;
JSObject* JSB_CCEaseBounceOut_object = NULL;
// Constructor
JSBool JSB_CCEaseBounceOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBounceOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBounceOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBounceOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBounceOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBounceOut *proxy = [[JSB_CCEaseBounceOut alloc] initWithJSObject:obj class:[CCEaseBounceOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBounceOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBounceOut *real = (CCEaseBounceOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceOut* (o)
JSBool JSB_CCEaseBounceOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBounceOut* ret_val;

	ret_val = [CCEaseBounceOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBounceOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBounceOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBounceOut_class->name = name;
	JSB_CCEaseBounceOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBounceOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBounceOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBounceOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBounceOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBounceOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseBounceOut_class->convert = JS_ConvertStub;
	JSB_CCEaseBounceOut_class->finalize = JSB_CCEaseBounceOut_finalize;
	JSB_CCEaseBounceOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBounceOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBounceOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBounceOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBounceOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseBounce_object, JSB_CCEaseBounceOut_class, JSB_CCEaseBounceOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBounceOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBounceOut_class, JSB_CCEaseBounceOut_object, NULL);
	JSB_CCEaseBounceOut *proxy = [[JSB_CCEaseBounceOut alloc] initWithJSObject:jsobj class:[CCEaseBounceOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOut
 */
#pragma mark - CCFadeOut

JSClass* JSB_CCFadeOut_class = NULL;
JSObject* JSB_CCFadeOut_object = NULL;
// Constructor
JSBool JSB_CCFadeOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeOut *proxy = [[JSB_CCFadeOut alloc] initWithJSObject:obj class:[CCFadeOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCFadeOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFadeOut *real = (CCFadeOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFadeOut* (o)
JSBool JSB_CCFadeOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeOut* ret_val;

	ret_val = [CCFadeOut actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeOut_class->name = name;
	JSB_CCFadeOut_class->addProperty = JS_PropertyStub;
	JSB_CCFadeOut_class->delProperty = JS_PropertyStub;
	JSB_CCFadeOut_class->getProperty = JS_PropertyStub;
	JSB_CCFadeOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeOut_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeOut_class->resolve = JS_ResolveStub;
	JSB_CCFadeOut_class->convert = JS_ConvertStub;
	JSB_CCFadeOut_class->finalize = JSB_CCFadeOut_finalize;
	JSB_CCFadeOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCFadeOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeOut_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCFadeOut_class, JSB_CCFadeOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeOut_class, JSB_CCFadeOut_object, NULL);
	JSB_CCFadeOut *proxy = [[JSB_CCFadeOut alloc] initWithJSObject:jsobj class:[CCFadeOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimationCache
 */
#pragma mark - CCAnimationCache

JSClass* JSB_CCAnimationCache_class = NULL;
JSObject* JSB_CCAnimationCache_object = NULL;
// Constructor
JSBool JSB_CCAnimationCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAnimationCache createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAnimationCache_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAnimationCache)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAnimationCache_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAnimationCache *proxy = [[JSB_CCAnimationCache alloc] initWithJSObject:obj class:[CCAnimationCache class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAnimation*, NSString*
// Ret value: void (None)
JSBool JSB_CCAnimationCache_addAnimation_name_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real addAnimation:arg0 name:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSDictionary*
// Ret value: void (None)
JSBool JSB_CCAnimationCache_addAnimationsWithDictionary_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real addAnimationsWithDictionary:(NSDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCAnimationCache_addAnimationsWithFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real addAnimationsWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCAnimation* (o)
JSBool JSB_CCAnimationCache_animationByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAnimation* ret_val;

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	ret_val = [real animationByName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCAnimationCache_purgeSharedAnimationCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[CCAnimationCache purgeSharedAnimationCache ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCAnimationCache_removeAnimationByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real removeAnimationByName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAnimationCache* (o)
JSBool JSB_CCAnimationCache_sharedAnimationCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCAnimationCache* ret_val;

	ret_val = [CCAnimationCache sharedAnimationCache ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCAnimationCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAnimationCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAnimationCache_class->name = name;
	JSB_CCAnimationCache_class->addProperty = JS_PropertyStub;
	JSB_CCAnimationCache_class->delProperty = JS_PropertyStub;
	JSB_CCAnimationCache_class->getProperty = JS_PropertyStub;
	JSB_CCAnimationCache_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAnimationCache_class->enumerate = JS_EnumerateStub;
	JSB_CCAnimationCache_class->resolve = JS_ResolveStub;
	JSB_CCAnimationCache_class->convert = JS_ConvertStub;
	JSB_CCAnimationCache_class->finalize = JSB_CCAnimationCache_finalize;
	JSB_CCAnimationCache_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAnimation", JSB_CCAnimationCache_addAnimation_name_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addAnimationsWithDictionary", JSB_CCAnimationCache_addAnimationsWithDictionary_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addAnimations", JSB_CCAnimationCache_addAnimationsWithFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAnimation", JSB_CCAnimationCache_animationByName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAnimation", JSB_CCAnimationCache_removeAnimationByName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAnimationCache_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedAnimationCache", JSB_CCAnimationCache_purgeSharedAnimationCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSB_CCAnimationCache_sharedAnimationCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAnimationCache_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCAnimationCache_class, JSB_CCAnimationCache_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAnimationCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAnimationCache_class, JSB_CCAnimationCache_object, NULL);
	JSB_CCAnimationCache *proxy = [[JSB_CCAnimationCache alloc] initWithJSObject:jsobj class:[CCAnimationCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRepeatForever
 */
#pragma mark - CCRepeatForever

JSClass* JSB_CCRepeatForever_class = NULL;
JSObject* JSB_CCRepeatForever_object = NULL;
// Constructor
JSBool JSB_CCRepeatForever_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRepeatForever createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRepeatForever_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRepeatForever)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRepeatForever_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRepeatForever *proxy = [[JSB_CCRepeatForever alloc] initWithJSObject:obj class:[CCRepeatForever class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCRepeatForever* (o)
JSBool JSB_CCRepeatForever_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRepeatForever* ret_val;

	ret_val = [CCRepeatForever actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: None (None)
JSBool JSB_CCRepeatForever_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRepeatForever *real = [(CCRepeatForever*)[proxy.klass alloc] initWithAction:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCRepeatForever_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCRepeatForever *real = (CCRepeatForever*) [proxy realObj];
	ret_val = [real innerAction ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: void (None)
JSBool JSB_CCRepeatForever_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRepeatForever *real = (CCRepeatForever*) [proxy realObj];
	[real setInnerAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCRepeatForever_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRepeatForever_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRepeatForever_class->name = name;
	JSB_CCRepeatForever_class->addProperty = JS_PropertyStub;
	JSB_CCRepeatForever_class->delProperty = JS_PropertyStub;
	JSB_CCRepeatForever_class->getProperty = JS_PropertyStub;
	JSB_CCRepeatForever_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRepeatForever_class->enumerate = JS_EnumerateStub;
	JSB_CCRepeatForever_class->resolve = JS_ResolveStub;
	JSB_CCRepeatForever_class->convert = JS_ConvertStub;
	JSB_CCRepeatForever_class->finalize = JSB_CCRepeatForever_finalize;
	JSB_CCRepeatForever_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSB_CCRepeatForever_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSB_CCRepeatForever_innerAction, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSB_CCRepeatForever_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRepeatForever_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRepeatForever_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRepeatForever_object = JS_InitClass(cx, globalObj, JSB_CCAction_object, JSB_CCRepeatForever_class, JSB_CCRepeatForever_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRepeatForever

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRepeatForever_class, JSB_CCRepeatForever_object, NULL);
	JSB_CCRepeatForever *proxy = [[JSB_CCRepeatForever alloc] initWithJSObject:jsobj class:[CCRepeatForever class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOutBLTiles
 */
#pragma mark - CCFadeOutBLTiles

JSClass* JSB_CCFadeOutBLTiles_class = NULL;
JSObject* JSB_CCFadeOutBLTiles_object = NULL;
// Constructor
JSBool JSB_CCFadeOutBLTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeOutBLTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeOutBLTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeOutBLTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeOutBLTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeOutBLTiles *proxy = [[JSB_CCFadeOutBLTiles alloc] initWithJSObject:obj class:[CCFadeOutBLTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize, ccTime
// Ret value: float (d)
JSBool JSB_CCFadeOutBLTiles_testFunc_time_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; double arg1; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	float ret_val;

	CCFadeOutBLTiles *real = (CCFadeOutBLTiles*) [proxy realObj];
	ret_val = [real testFunc:(CGSize)arg0 time:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize
// Ret value: CCFadeOutBLTiles* (o)
JSBool JSB_CCFadeOutBLTiles_actionWithDuration_size__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeOutBLTiles* ret_val;

	ret_val = [CCFadeOutBLTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeOutBLTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeOutBLTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeOutBLTiles_class->name = name;
	JSB_CCFadeOutBLTiles_class->addProperty = JS_PropertyStub;
	JSB_CCFadeOutBLTiles_class->delProperty = JS_PropertyStub;
	JSB_CCFadeOutBLTiles_class->getProperty = JS_PropertyStub;
	JSB_CCFadeOutBLTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeOutBLTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeOutBLTiles_class->resolve = JS_ResolveStub;
	JSB_CCFadeOutBLTiles_class->convert = JS_ConvertStub;
	JSB_CCFadeOutBLTiles_class->finalize = JSB_CCFadeOutBLTiles_finalize;
	JSB_CCFadeOutBLTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("testFuncTime", JSB_CCFadeOutBLTiles_testFunc_time_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeOutBLTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeOutBLTiles_actionWithDuration_size__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeOutBLTiles_object = JS_InitClass(cx, globalObj, JSB_CCFadeOutTRTiles_object, JSB_CCFadeOutBLTiles_class, JSB_CCFadeOutBLTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeOutBLTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeOutBLTiles_class, JSB_CCFadeOutBLTiles_object, NULL);
	JSB_CCFadeOutBLTiles *proxy = [[JSB_CCFadeOutBLTiles alloc] initWithJSObject:jsobj class:[CCFadeOutBLTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSun
 */
#pragma mark - CCParticleSun

JSClass* JSB_CCParticleSun_class = NULL;
JSObject* JSB_CCParticleSun_object = NULL;
// Constructor
JSBool JSB_CCParticleSun_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSun createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSun_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSun)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSun_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSun *proxy = [[JSB_CCParticleSun alloc] initWithJSObject:obj class:[CCParticleSun class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleSun_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSun *real = [(CCParticleSun*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSun* (o)
JSBool JSB_CCParticleSun_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSun* (o)
JSBool JSB_CCParticleSun_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSun* (o)
JSBool JSB_CCParticleSun_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleSun_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSun_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSun_class->name = name;
	JSB_CCParticleSun_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSun_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSun_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSun_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSun_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSun_class->resolve = JS_ResolveStub;
	JSB_CCParticleSun_class->convert = JS_ConvertStub;
	JSB_CCParticleSun_class->finalize = JSB_CCParticleSun_finalize;
	JSB_CCParticleSun_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleSun_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSun_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleSun_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleSun_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleSun_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSun_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleSun_class, JSB_CCParticleSun_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSun

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSun_class, JSB_CCParticleSun_object, NULL);
	JSB_CCParticleSun *proxy = [[JSB_CCParticleSun alloc] initWithJSObject:jsobj class:[CCParticleSun class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressVertical
 */
#pragma mark - CCTransitionProgressVertical

JSClass* JSB_CCTransitionProgressVertical_class = NULL;
JSObject* JSB_CCTransitionProgressVertical_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressVertical_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressVertical createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressVertical_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressVertical)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressVertical_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressVertical *proxy = [[JSB_CCTransitionProgressVertical alloc] initWithJSObject:obj class:[CCTransitionProgressVertical class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressVertical *real = (CCTransitionProgressVertical*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressVertical* (o)
JSBool JSB_CCTransitionProgressVertical_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressVertical* ret_val;

	ret_val = [CCTransitionProgressVertical transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressVertical* (o)
JSBool JSB_CCTransitionProgressVertical_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressVertical* ret_val;

	ret_val = [CCTransitionProgressVertical node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressVertical_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressVertical_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressVertical_class->name = name;
	JSB_CCTransitionProgressVertical_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressVertical_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressVertical_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressVertical_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressVertical_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressVertical_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressVertical_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressVertical_class->finalize = JSB_CCTransitionProgressVertical_finalize;
	JSB_CCTransitionProgressVertical_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressVertical_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressVertical_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressVertical_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressVertical_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressVertical_class, JSB_CCTransitionProgressVertical_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressVertical

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressVertical_class, JSB_CCTransitionProgressVertical_object, NULL);
	JSB_CCTransitionProgressVertical *proxy = [[JSB_CCTransitionProgressVertical alloc] initWithJSObject:jsobj class:[CCTransitionProgressVertical class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFileUtils
 */
#pragma mark - CCFileUtils

JSClass* JSB_CCFileUtils_class = NULL;
JSObject* JSB_CCFileUtils_object = NULL;
// Constructor
JSBool JSB_CCFileUtils_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFileUtils createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFileUtils_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFileUtils)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFileUtils_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFileUtils *proxy = [[JSB_CCFileUtils alloc] initWithJSObject:obj class:[CCFileUtils class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCFileUtils_buildSearchResolutionsOrder(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real buildSearchResolutionsOrder ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCFileUtils_directoriesDict(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real directoriesDict ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCFileUtils_filenameLookup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real filenameLookup ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_fullPathForFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real fullPathForFilename:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_fullPathForFilenameIgnoringResolutions_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real fullPathForFilenameIgnoringResolutions:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_fullPathFromRelativePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real fullPathFromRelativePath:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_fullPathFromRelativePathIgnoringResolutions_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real fullPathFromRelativePathIgnoringResolutions:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCFileUtils_isEnablediPhoneResourcesOniPad(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real isEnablediPhoneResourcesOniPad ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCFileUtils_loadFilenameLookupDictionaryFromFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real loadFilenameLookupDictionaryFromFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCFileUtils_purgeCachedEntries(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real purgeCachedEntries ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_removeSuffixFromFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real removeSuffixFromFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCFileUtils_searchMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real searchMode ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSArray* (array)
JSBool JSB_CCFileUtils_searchPath(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSArray* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real searchPath ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSArray* (array)
JSBool JSB_CCFileUtils_searchResolutionsOrder(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSArray* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real searchResolutionsOrder ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCFileUtils_setDirectoriesDict_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setDirectoriesDict:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCFileUtils_setEnableFallbackSuffixes_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setEnableFallbackSuffixes:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCFileUtils_setEnableiPhoneResourcesOniPad_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setEnableiPhoneResourcesOniPad:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCFileUtils_setFilenameLookup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setFilenameLookup:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSB_CCFileUtils_setSearchMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setSearchMode:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_CCFileUtils_setSearchPath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setSearchPath:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: void (None)
JSBool JSB_CCFileUtils_setSearchResolutionsOrder_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setSearchResolutionsOrder:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCFileUtils_setSuffixesDict_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setSuffixesDict:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFileUtils* (o)
JSBool JSB_CCFileUtils_sharedFileUtils_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCFileUtils* ret_val;

	ret_val = [CCFileUtils sharedFileUtils ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSB_CCFileUtils_standarizePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real standarizePath:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCFileUtils_suffixesDict(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real suffixesDict ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

void JSB_CCFileUtils_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFileUtils_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFileUtils_class->name = name;
	JSB_CCFileUtils_class->addProperty = JS_PropertyStub;
	JSB_CCFileUtils_class->delProperty = JS_PropertyStub;
	JSB_CCFileUtils_class->getProperty = JS_PropertyStub;
	JSB_CCFileUtils_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFileUtils_class->enumerate = JS_EnumerateStub;
	JSB_CCFileUtils_class->resolve = JS_ResolveStub;
	JSB_CCFileUtils_class->convert = JS_ConvertStub;
	JSB_CCFileUtils_class->finalize = JSB_CCFileUtils_finalize;
	JSB_CCFileUtils_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("buildSearchResolutionsOrder", JSB_CCFileUtils_buildSearchResolutionsOrder, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDirectoriesDict", JSB_CCFileUtils_directoriesDict, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFilenameLookup", JSB_CCFileUtils_filenameLookup, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fullPathForFilename", JSB_CCFileUtils_fullPathForFilename_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fullPathForFilenameIgnoringResolutions", JSB_CCFileUtils_fullPathForFilenameIgnoringResolutions_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fullPathFromRelativePath", JSB_CCFileUtils_fullPathFromRelativePath_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fullPathFromRelativePathIgnoringResolutions", JSB_CCFileUtils_fullPathFromRelativePathIgnoringResolutions_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isEnablediPhoneResourcesOniPad", JSB_CCFileUtils_isEnablediPhoneResourcesOniPad, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("loadFilenameLookup", JSB_CCFileUtils_loadFilenameLookupDictionaryFromFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("purgeCachedEntries", JSB_CCFileUtils_purgeCachedEntries, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSuffixFromFile", JSB_CCFileUtils_removeSuffixFromFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSearchMode", JSB_CCFileUtils_searchMode, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSearchPath", JSB_CCFileUtils_searchPath, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSearchResolutionsOrder", JSB_CCFileUtils_searchResolutionsOrder, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDirectoriesDict", JSB_CCFileUtils_setDirectoriesDict_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEnableFallbackSuffixes", JSB_CCFileUtils_setEnableFallbackSuffixes_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setEnableiPhoneResourcesOniPad", JSB_CCFileUtils_setEnableiPhoneResourcesOniPad_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFilenameLookup", JSB_CCFileUtils_setFilenameLookup_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSearchMode", JSB_CCFileUtils_setSearchMode_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSearchPath", JSB_CCFileUtils_setSearchPath_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSearchResolutionsOrder", JSB_CCFileUtils_setSearchResolutionsOrder_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSuffixesDict", JSB_CCFileUtils_setSuffixesDict_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("standarizePath", JSB_CCFileUtils_standarizePath_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSuffixesDict", JSB_CCFileUtils_suffixesDict, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFileUtils_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("getInstance", JSB_CCFileUtils_sharedFileUtils_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFileUtils_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCFileUtils_class, JSB_CCFileUtils_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFileUtils

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFileUtils_class, JSB_CCFileUtils_object, NULL);
	JSB_CCFileUtils *proxy = [[JSB_CCFileUtils alloc] initWithJSObject:jsobj class:[CCFileUtils class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSpiral
 */
#pragma mark - CCParticleSpiral

JSClass* JSB_CCParticleSpiral_class = NULL;
JSObject* JSB_CCParticleSpiral_object = NULL;
// Constructor
JSBool JSB_CCParticleSpiral_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSpiral createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSpiral_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSpiral)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSpiral_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSpiral *proxy = [[JSB_CCParticleSpiral alloc] initWithJSObject:obj class:[CCParticleSpiral class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleSpiral_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSpiral *real = [(CCParticleSpiral*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSpiral* (o)
JSBool JSB_CCParticleSpiral_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSpiral* (o)
JSBool JSB_CCParticleSpiral_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSpiral* (o)
JSBool JSB_CCParticleSpiral_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleSpiral_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSpiral_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSpiral_class->name = name;
	JSB_CCParticleSpiral_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSpiral_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSpiral_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSpiral_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSpiral_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSpiral_class->resolve = JS_ResolveStub;
	JSB_CCParticleSpiral_class->convert = JS_ConvertStub;
	JSB_CCParticleSpiral_class->finalize = JSB_CCParticleSpiral_finalize;
	JSB_CCParticleSpiral_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleSpiral_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSpiral_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleSpiral_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleSpiral_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleSpiral_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSpiral_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleSpiral_class, JSB_CCParticleSpiral_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSpiral

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSpiral_class, JSB_CCParticleSpiral_object, NULL);
	JSB_CCParticleSpiral *proxy = [[JSB_CCParticleSpiral alloc] initWithJSObject:jsobj class:[CCParticleSpiral class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAtlasNode
 */
#pragma mark - CCAtlasNode

JSClass* JSB_CCAtlasNode_class = NULL;
JSObject* JSB_CCAtlasNode_object = NULL;
// Constructor
JSBool JSB_CCAtlasNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAtlasNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAtlasNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAtlasNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAtlasNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAtlasNode *proxy = [[JSB_CCAtlasNode alloc] initWithJSObject:obj class:[CCAtlasNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCAtlasNode* (o)
JSBool JSB_CCAtlasNode_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAtlasNode* ret_val;

	ret_val = [CCAtlasNode atlasWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCAtlasNode_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSB_CCAtlasNode_initWithTexture_tileWidth_tileHeight_itemsToRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = [(CCAtlasNode*)[proxy.klass alloc] initWithTexture:arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSB_CCAtlasNode_initWithTileFile_tileWidth_tileHeight_itemsToRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = [(CCAtlasNode*)[proxy.klass alloc] initWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCAtlasNode_quadsToDraw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real quadsToDraw ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCAtlasNode_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCAtlasNode_setQuadsToDraw_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setQuadsToDraw:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSB_CCAtlasNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setTextureAtlas:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCAtlasNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCAtlasNode_updateAtlasValues(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real updateAtlasValues ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCAtlasNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCAtlasNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCAtlasNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAtlasNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAtlasNode_class->name = name;
	JSB_CCAtlasNode_class->addProperty = JS_PropertyStub;
	JSB_CCAtlasNode_class->delProperty = JS_PropertyStub;
	JSB_CCAtlasNode_class->getProperty = JS_PropertyStub;
	JSB_CCAtlasNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAtlasNode_class->enumerate = JS_EnumerateStub;
	JSB_CCAtlasNode_class->resolve = JS_ResolveStub;
	JSB_CCAtlasNode_class->convert = JS_ConvertStub;
	JSB_CCAtlasNode_class->finalize = JSB_CCAtlasNode_finalize;
	JSB_CCAtlasNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getColor", JSB_CCAtlasNode_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureTileWidthTileHeightItemsToRender", JSB_CCAtlasNode_initWithTexture_tileWidth_tileHeight_itemsToRender_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTileFileTileWidthTileHeightItemsToRender", JSB_CCAtlasNode_initWithTileFile_tileWidth_tileHeight_itemsToRender_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getQuadsToDraw", JSB_CCAtlasNode_quadsToDraw, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCAtlasNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCAtlasNode_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setQuadsToDraw", JSB_CCAtlasNode_setQuadsToDraw_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSB_CCAtlasNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSB_CCAtlasNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateAtlasValues", JSB_CCAtlasNode_updateAtlasValues, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCAtlasNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCAtlasNode_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAtlasNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("atlasWithTileFileTileWidthTileHeightItemsToRender", JSB_CCAtlasNode_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAtlasNode_object = JS_InitClass(cx, globalObj, JSB_CCNodeRGBA_object, JSB_CCAtlasNode_class, JSB_CCAtlasNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAtlasNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAtlasNode_class, JSB_CCAtlasNode_object, NULL);
	JSB_CCAtlasNode *proxy = [[JSB_CCAtlasNode alloc] initWithJSObject:jsobj class:[CCAtlasNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTileMapAtlas
 */
#pragma mark - CCTileMapAtlas

JSClass* JSB_CCTileMapAtlas_class = NULL;
JSObject* JSB_CCTileMapAtlas_object = NULL;
// Constructor
JSBool JSB_CCTileMapAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTileMapAtlas createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTileMapAtlas_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTileMapAtlas)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTileMapAtlas_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTileMapAtlas *proxy = [[JSB_CCTileMapAtlas alloc] initWithJSObject:obj class:[CCTileMapAtlas class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, int, int
// Ret value: None (None)
JSBool JSB_CCTileMapAtlas_initWithTileFile_mapFile_tileWidth_tileHeight_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTileMapAtlas *real = [(CCTileMapAtlas*)[proxy.klass alloc] initWithTileFile:(NSString*)arg0 mapFile:(NSString*)arg1 tileWidth:(int)arg2 tileHeight:(int)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTileMapAtlas_releaseMap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	[real releaseMap ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B, CGPoint
// Ret value: void (None)
JSBool JSB_CCTileMapAtlas_setTile_at_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; CGPoint arg1; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	[real setTile:(ccColor3B)arg0 at:(CGPoint)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: ccColor3B (N/A)
JSBool JSB_CCTileMapAtlas_tileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccColor3B ret_val;

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	ret_val = [real tileAt:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, int, int
// Ret value: CCTileMapAtlas* (o)
JSBool JSB_CCTileMapAtlas_tileMapAtlasWithTileFile_mapFile_tileWidth_tileHeight__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTileMapAtlas* ret_val;

	ret_val = [CCTileMapAtlas tileMapAtlasWithTileFile:(NSString*)arg0 mapFile:(NSString*)arg1 tileWidth:(int)arg2 tileHeight:(int)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTileMapAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTileMapAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTileMapAtlas_class->name = name;
	JSB_CCTileMapAtlas_class->addProperty = JS_PropertyStub;
	JSB_CCTileMapAtlas_class->delProperty = JS_PropertyStub;
	JSB_CCTileMapAtlas_class->getProperty = JS_PropertyStub;
	JSB_CCTileMapAtlas_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTileMapAtlas_class->enumerate = JS_EnumerateStub;
	JSB_CCTileMapAtlas_class->resolve = JS_ResolveStub;
	JSB_CCTileMapAtlas_class->convert = JS_ConvertStub;
	JSB_CCTileMapAtlas_class->finalize = JSB_CCTileMapAtlas_finalize;
	JSB_CCTileMapAtlas_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTileFileMapFileTileWidthTileHeight", JSB_CCTileMapAtlas_initWithTileFile_mapFile_tileWidth_tileHeight_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("releaseMap", JSB_CCTileMapAtlas_releaseMap, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTileAt", JSB_CCTileMapAtlas_setTile_at_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("tileAt", JSB_CCTileMapAtlas_tileAt_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTileMapAtlas_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTileMapAtlas_tileMapAtlasWithTileFile_mapFile_tileWidth_tileHeight__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTileMapAtlas_object = JS_InitClass(cx, globalObj, JSB_CCAtlasNode_object, JSB_CCTileMapAtlas_class, JSB_CCTileMapAtlas_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTileMapAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTileMapAtlas_class, JSB_CCTileMapAtlas_object, NULL);
	JSB_CCTileMapAtlas *proxy = [[JSB_CCTileMapAtlas alloc] initWithJSObject:jsobj class:[CCTileMapAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFlower
 */
#pragma mark - CCParticleFlower

JSClass* JSB_CCParticleFlower_class = NULL;
JSObject* JSB_CCParticleFlower_object = NULL;
// Constructor
JSBool JSB_CCParticleFlower_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleFlower createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleFlower_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleFlower)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleFlower_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleFlower *proxy = [[JSB_CCParticleFlower alloc] initWithJSObject:obj class:[CCParticleFlower class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleFlower_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleFlower *real = [(CCParticleFlower*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFlower* (o)
JSBool JSB_CCParticleFlower_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFlower* (o)
JSBool JSB_CCParticleFlower_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFlower* (o)
JSBool JSB_CCParticleFlower_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleFlower_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleFlower_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleFlower_class->name = name;
	JSB_CCParticleFlower_class->addProperty = JS_PropertyStub;
	JSB_CCParticleFlower_class->delProperty = JS_PropertyStub;
	JSB_CCParticleFlower_class->getProperty = JS_PropertyStub;
	JSB_CCParticleFlower_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleFlower_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleFlower_class->resolve = JS_ResolveStub;
	JSB_CCParticleFlower_class->convert = JS_ConvertStub;
	JSB_CCParticleFlower_class->finalize = JSB_CCParticleFlower_finalize;
	JSB_CCParticleFlower_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleFlower_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleFlower_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleFlower_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleFlower_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleFlower_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleFlower_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleFlower_class, JSB_CCParticleFlower_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleFlower

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleFlower_class, JSB_CCParticleFlower_object, NULL);
	JSB_CCParticleFlower *proxy = [[JSB_CCParticleFlower alloc] initWithJSObject:jsobj class:[CCParticleFlower class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCallBlock
 */
#pragma mark - CCCallBlock

JSClass* JSB_CCCallBlock_class = NULL;
JSObject* JSB_CCCallBlock_object = NULL;
// Constructor
JSBool JSB_CCCallBlock_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCallBlock createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCallBlock_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCallBlock)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCallBlock_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCallBlock *proxy = [[JSB_CCCallBlock alloc] initWithJSObject:obj class:[CCCallBlock class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCCallBlock_execute(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCCallBlock *real = (CCCallBlock*) [proxy realObj];
	[real execute ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCallBlock* (o)
JSBool JSB_CCCallBlock_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCCallBlock* ret_val;

	ret_val = [CCCallBlock action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCCallBlock_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCallBlock_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCallBlock_class->name = name;
	JSB_CCCallBlock_class->addProperty = JS_PropertyStub;
	JSB_CCCallBlock_class->delProperty = JS_PropertyStub;
	JSB_CCCallBlock_class->getProperty = JS_PropertyStub;
	JSB_CCCallBlock_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCallBlock_class->enumerate = JS_EnumerateStub;
	JSB_CCCallBlock_class->resolve = JS_ResolveStub;
	JSB_CCCallBlock_class->convert = JS_ConvertStub;
	JSB_CCCallBlock_class->finalize = JSB_CCCallBlock_finalize;
	JSB_CCCallBlock_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("execute", JSB_CCCallBlock_execute, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCallBlock_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSB_CCCallBlock_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCallBlock_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCCallBlock_class, JSB_CCCallBlock_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCallBlock

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCallBlock_class, JSB_CCCallBlock_object, NULL);
	JSB_CCCallBlock *proxy = [[JSB_CCCallBlock alloc] initWithJSObject:jsobj class:[CCCallBlock class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionShrinkGrow
 */
#pragma mark - CCTransitionShrinkGrow

JSClass* JSB_CCTransitionShrinkGrow_class = NULL;
JSObject* JSB_CCTransitionShrinkGrow_object = NULL;
// Constructor
JSBool JSB_CCTransitionShrinkGrow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionShrinkGrow createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionShrinkGrow_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionShrinkGrow)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionShrinkGrow_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionShrinkGrow *proxy = [[JSB_CCTransitionShrinkGrow alloc] initWithJSObject:obj class:[CCTransitionShrinkGrow class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionShrinkGrow_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionShrinkGrow *real = [(CCTransitionShrinkGrow*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionShrinkGrow_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionShrinkGrow *real = (CCTransitionShrinkGrow*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionShrinkGrow* (o)
JSBool JSB_CCTransitionShrinkGrow_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionShrinkGrow* ret_val;

	ret_val = [CCTransitionShrinkGrow transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionShrinkGrow* (o)
JSBool JSB_CCTransitionShrinkGrow_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionShrinkGrow* ret_val;

	ret_val = [CCTransitionShrinkGrow node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionShrinkGrow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionShrinkGrow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionShrinkGrow_class->name = name;
	JSB_CCTransitionShrinkGrow_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionShrinkGrow_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionShrinkGrow_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionShrinkGrow_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionShrinkGrow_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionShrinkGrow_class->resolve = JS_ResolveStub;
	JSB_CCTransitionShrinkGrow_class->convert = JS_ConvertStub;
	JSB_CCTransitionShrinkGrow_class->finalize = JSB_CCTransitionShrinkGrow_finalize;
	JSB_CCTransitionShrinkGrow_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionShrinkGrow_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionShrinkGrow_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionShrinkGrow_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionShrinkGrow_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionShrinkGrow_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionShrinkGrow_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionShrinkGrow_class, JSB_CCTransitionShrinkGrow_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionShrinkGrow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionShrinkGrow_class, JSB_CCTransitionShrinkGrow_object, NULL);
	JSB_CCTransitionShrinkGrow *proxy = [[JSB_CCTransitionShrinkGrow alloc] initWithJSObject:jsobj class:[CCTransitionShrinkGrow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialInOut
 */
#pragma mark - CCEaseExponentialInOut

JSClass* JSB_CCEaseExponentialInOut_class = NULL;
JSObject* JSB_CCEaseExponentialInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseExponentialInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseExponentialInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseExponentialInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseExponentialInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseExponentialInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseExponentialInOut *proxy = [[JSB_CCEaseExponentialInOut alloc] initWithJSObject:obj class:[CCEaseExponentialInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseExponentialInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseExponentialInOut *real = (CCEaseExponentialInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialInOut* (o)
JSBool JSB_CCEaseExponentialInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseExponentialInOut* ret_val;

	ret_val = [CCEaseExponentialInOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseExponentialInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseExponentialInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseExponentialInOut_class->name = name;
	JSB_CCEaseExponentialInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseExponentialInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseExponentialInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseExponentialInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseExponentialInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseExponentialInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseExponentialInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseExponentialInOut_class->finalize = JSB_CCEaseExponentialInOut_finalize;
	JSB_CCEaseExponentialInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseExponentialInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseExponentialInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseExponentialInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseExponentialInOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseExponentialInOut_class, JSB_CCEaseExponentialInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseExponentialInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseExponentialInOut_class, JSB_CCEaseExponentialInOut_object, NULL);
	JSB_CCEaseExponentialInOut *proxy = [[JSB_CCEaseExponentialInOut alloc] initWithJSObject:jsobj class:[CCEaseExponentialInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleRain
 */
#pragma mark - CCParticleRain

JSClass* JSB_CCParticleRain_class = NULL;
JSObject* JSB_CCParticleRain_object = NULL;
// Constructor
JSBool JSB_CCParticleRain_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleRain createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleRain_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleRain)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleRain_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleRain *proxy = [[JSB_CCParticleRain alloc] initWithJSObject:obj class:[CCParticleRain class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleRain_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleRain *real = [(CCParticleRain*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleRain* (o)
JSBool JSB_CCParticleRain_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleRain* (o)
JSBool JSB_CCParticleRain_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleRain* (o)
JSBool JSB_CCParticleRain_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleRain_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleRain_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleRain_class->name = name;
	JSB_CCParticleRain_class->addProperty = JS_PropertyStub;
	JSB_CCParticleRain_class->delProperty = JS_PropertyStub;
	JSB_CCParticleRain_class->getProperty = JS_PropertyStub;
	JSB_CCParticleRain_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleRain_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleRain_class->resolve = JS_ResolveStub;
	JSB_CCParticleRain_class->convert = JS_ConvertStub;
	JSB_CCParticleRain_class->finalize = JSB_CCParticleRain_finalize;
	JSB_CCParticleRain_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleRain_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleRain_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleRain_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleRain_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleRain_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleRain_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleRain_class, JSB_CCParticleRain_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleRain

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleRain_class, JSB_CCParticleRain_object, NULL);
	JSB_CCParticleRain *proxy = [[JSB_CCParticleRain alloc] initWithJSObject:jsobj class:[CCParticleRain class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemLabel
 */
#pragma mark - CCMenuItemLabel

JSClass* JSB_CCMenuItemLabel_class = NULL;
JSObject* JSB_CCMenuItemLabel_object = NULL;
// Constructor
JSBool JSB_CCMenuItemLabel_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItemLabel createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItemLabel_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItemLabel)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItemLabel_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItemLabel *proxy = [[JSB_CCMenuItemLabel alloc] initWithJSObject:obj class:[CCMenuItemLabel class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCMenuItemLabel_disabledColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real disabledColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCMenuItemLabel_label(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real label ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMenuItemLabel_setDisabledColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setDisabledColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemLabel_setIsEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setIsEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCMenuItemLabel_setLabel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setLabel:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCMenuItemLabel_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setString:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItemLabel_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItemLabel_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItemLabel_class->name = name;
	JSB_CCMenuItemLabel_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItemLabel_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItemLabel_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItemLabel_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItemLabel_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItemLabel_class->resolve = JS_ResolveStub;
	JSB_CCMenuItemLabel_class->convert = JS_ConvertStub;
	JSB_CCMenuItemLabel_class->finalize = JSB_CCMenuItemLabel_finalize;
	JSB_CCMenuItemLabel_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDisabledColor", JSB_CCMenuItemLabel_disabledColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCMenuItemLabel_initWithLabel_block_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLabel", JSB_CCMenuItemLabel_label, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDisabledColor", JSB_CCMenuItemLabel_setDisabledColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setIsEnabled", JSB_CCMenuItemLabel_setIsEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLabel", JSB_CCMenuItemLabel_setLabel_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setString", JSB_CCMenuItemLabel_setString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItemLabel_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCMenuItemLabel_itemWithLabel_block__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItemLabel_object = JS_InitClass(cx, globalObj, JSB_CCMenuItem_object, JSB_CCMenuItemLabel_class, JSB_CCMenuItemLabel_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItemLabel

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItemLabel_class, JSB_CCMenuItemLabel_object, NULL);
	JSB_CCMenuItemLabel *proxy = [[JSB_CCMenuItemLabel alloc] initWithJSObject:jsobj class:[CCMenuItemLabel class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemFont
 */
#pragma mark - CCMenuItemFont

JSClass* JSB_CCMenuItemFont_class = NULL;
JSObject* JSB_CCMenuItemFont_object = NULL;
// Constructor
JSBool JSB_CCMenuItemFont_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItemFont createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItemFont_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItemFont)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItemFont_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItemFont *proxy = [[JSB_CCMenuItemFont alloc] initWithJSObject:obj class:[CCMenuItemFont class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCMenuItemFont_fontName_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	ret_val = [CCMenuItemFont fontName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCMenuItemFont_fontName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	ret_val = [real fontName ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCMenuItemFont_fontSize_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	ret_val = [CCMenuItemFont fontSize ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCMenuItemFont_fontSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	ret_val = [real fontSize ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCMenuItemFont_setFontName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[CCMenuItemFont setFontName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCMenuItemFont_setFontName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	[real setFontName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCMenuItemFont_setFontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	[CCMenuItemFont setFontSize:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCMenuItemFont_setFontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	[real setFontSize:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItemFont_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItemFont_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItemFont_class->name = name;
	JSB_CCMenuItemFont_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItemFont_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItemFont_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItemFont_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItemFont_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItemFont_class->resolve = JS_ResolveStub;
	JSB_CCMenuItemFont_class->convert = JS_ConvertStub;
	JSB_CCMenuItemFont_class->finalize = JSB_CCMenuItemFont_finalize;
	JSB_CCMenuItemFont_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("fontName", JSB_CCMenuItemFont_fontName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fontSize", JSB_CCMenuItemFont_fontSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCMenuItemFont_initWithString_block_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSB_CCMenuItemFont_setFontName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSB_CCMenuItemFont_setFontSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItemFont_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("fontName", JSB_CCMenuItemFont_fontName_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fontSize", JSB_CCMenuItemFont_fontSize_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCMenuItemFont_itemWithString_block__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSB_CCMenuItemFont_setFontName__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSB_CCMenuItemFont_setFontSize__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItemFont_object = JS_InitClass(cx, globalObj, JSB_CCMenuItemLabel_object, JSB_CCMenuItemFont_class, JSB_CCMenuItemFont_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItemFont

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItemFont_class, JSB_CCMenuItemFont_object, NULL);
	JSB_CCMenuItemFont *proxy = [[JSB_CCMenuItemFont alloc] initWithJSObject:jsobj class:[CCMenuItemFont class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTargetedAction
 */
#pragma mark - CCTargetedAction

JSClass* JSB_CCTargetedAction_class = NULL;
JSObject* JSB_CCTargetedAction_object = NULL;
// Constructor
JSBool JSB_CCTargetedAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTargetedAction createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTargetedAction_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTargetedAction)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTargetedAction_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTargetedAction *proxy = [[JSB_CCTargetedAction alloc] initWithJSObject:obj class:[CCTargetedAction class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSObject*, CCFiniteTimeAction*
// Ret value: CCTargetedAction* (o)
JSBool JSB_CCTargetedAction_actionWithTarget_action__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTargetedAction* ret_val;

	ret_val = [CCTargetedAction actionWithTarget:arg0 action:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCTargetedAction_forcedTarget(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCTargetedAction *real = (CCTargetedAction*) [proxy realObj];
	ret_val = [real forcedTarget ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSObject*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSB_CCTargetedAction_initWithTarget_action_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTargetedAction *real = [(CCTargetedAction*)[proxy.klass alloc] initWithTarget:arg0 action:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCTargetedAction_setForcedTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTargetedAction *real = (CCTargetedAction*) [proxy realObj];
	[real setForcedTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCTargetedAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTargetedAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTargetedAction_class->name = name;
	JSB_CCTargetedAction_class->addProperty = JS_PropertyStub;
	JSB_CCTargetedAction_class->delProperty = JS_PropertyStub;
	JSB_CCTargetedAction_class->getProperty = JS_PropertyStub;
	JSB_CCTargetedAction_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTargetedAction_class->enumerate = JS_EnumerateStub;
	JSB_CCTargetedAction_class->resolve = JS_ResolveStub;
	JSB_CCTargetedAction_class->convert = JS_ConvertStub;
	JSB_CCTargetedAction_class->finalize = JSB_CCTargetedAction_finalize;
	JSB_CCTargetedAction_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getForcedTarget", JSB_CCTargetedAction_forcedTarget, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTargetAction", JSB_CCTargetedAction_initWithTarget_action_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setForcedTarget", JSB_CCTargetedAction_setForcedTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTargetedAction_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTargetedAction_actionWithTarget_action__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTargetedAction_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCTargetedAction_class, JSB_CCTargetedAction_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTargetedAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTargetedAction_class, JSB_CCTargetedAction_object, NULL);
	JSB_CCTargetedAction *proxy = [[JSB_CCTargetedAction alloc] initWithJSObject:jsobj class:[CCTargetedAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSkewTo
 */
#pragma mark - CCSkewTo

JSClass* JSB_CCSkewTo_class = NULL;
JSObject* JSB_CCSkewTo_object = NULL;
// Constructor
JSBool JSB_CCSkewTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSkewTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSkewTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSkewTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSkewTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSkewTo *proxy = [[JSB_CCSkewTo alloc] initWithJSObject:obj class:[CCSkewTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCSkewTo* (o)
JSBool JSB_CCSkewTo_actionWithDuration_skewX_skewY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSkewTo* ret_val;

	ret_val = [CCSkewTo actionWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCSkewTo_initWithDuration_skewX_skewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSkewTo *real = [(CCSkewTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCSkewTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSkewTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSkewTo_class->name = name;
	JSB_CCSkewTo_class->addProperty = JS_PropertyStub;
	JSB_CCSkewTo_class->delProperty = JS_PropertyStub;
	JSB_CCSkewTo_class->getProperty = JS_PropertyStub;
	JSB_CCSkewTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSkewTo_class->enumerate = JS_EnumerateStub;
	JSB_CCSkewTo_class->resolve = JS_ResolveStub;
	JSB_CCSkewTo_class->convert = JS_ConvertStub;
	JSB_CCSkewTo_class->finalize = JSB_CCSkewTo_finalize;
	JSB_CCSkewTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSkewXSkewY", JSB_CCSkewTo_initWithDuration_skewX_skewY_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSkewTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSkewTo_actionWithDuration_skewX_skewY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSkewTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCSkewTo_class, JSB_CCSkewTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSkewTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSkewTo_class, JSB_CCSkewTo_object, NULL);
	JSB_CCSkewTo *proxy = [[JSB_CCSkewTo alloc] initWithJSObject:jsobj class:[CCSkewTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSkewBy
 */
#pragma mark - CCSkewBy

JSClass* JSB_CCSkewBy_class = NULL;
JSObject* JSB_CCSkewBy_object = NULL;
// Constructor
JSBool JSB_CCSkewBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSkewBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSkewBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSkewBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSkewBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSkewBy *proxy = [[JSB_CCSkewBy alloc] initWithJSObject:obj class:[CCSkewBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCSkewBy_initWithDuration_skewX_skewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSkewBy *real = [(CCSkewBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCSkewBy* (o)
JSBool JSB_CCSkewBy_actionWithDuration_skewX_skewY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSkewBy* ret_val;

	ret_val = [CCSkewBy actionWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCSkewBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSkewBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSkewBy_class->name = name;
	JSB_CCSkewBy_class->addProperty = JS_PropertyStub;
	JSB_CCSkewBy_class->delProperty = JS_PropertyStub;
	JSB_CCSkewBy_class->getProperty = JS_PropertyStub;
	JSB_CCSkewBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSkewBy_class->enumerate = JS_EnumerateStub;
	JSB_CCSkewBy_class->resolve = JS_ResolveStub;
	JSB_CCSkewBy_class->convert = JS_ConvertStub;
	JSB_CCSkewBy_class->finalize = JSB_CCSkewBy_finalize;
	JSB_CCSkewBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSkewXSkewY", JSB_CCSkewBy_initWithDuration_skewX_skewY_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSkewBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSkewBy_actionWithDuration_skewX_skewY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSkewBy_object = JS_InitClass(cx, globalObj, JSB_CCSkewTo_object, JSB_CCSkewBy_class, JSB_CCSkewBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSkewBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSkewBy_class, JSB_CCSkewBy_object, NULL);
	JSB_CCSkewBy *proxy = [[JSB_CCSkewBy alloc] initWithJSObject:jsobj class:[CCSkewBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFireworks
 */
#pragma mark - CCParticleFireworks

JSClass* JSB_CCParticleFireworks_class = NULL;
JSObject* JSB_CCParticleFireworks_object = NULL;
// Constructor
JSBool JSB_CCParticleFireworks_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleFireworks createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleFireworks_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleFireworks)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleFireworks_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleFireworks *proxy = [[JSB_CCParticleFireworks alloc] initWithJSObject:obj class:[CCParticleFireworks class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleFireworks_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleFireworks *real = [(CCParticleFireworks*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFireworks* (o)
JSBool JSB_CCParticleFireworks_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFireworks* (o)
JSBool JSB_CCParticleFireworks_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFireworks* (o)
JSBool JSB_CCParticleFireworks_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleFireworks_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleFireworks_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleFireworks_class->name = name;
	JSB_CCParticleFireworks_class->addProperty = JS_PropertyStub;
	JSB_CCParticleFireworks_class->delProperty = JS_PropertyStub;
	JSB_CCParticleFireworks_class->getProperty = JS_PropertyStub;
	JSB_CCParticleFireworks_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleFireworks_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleFireworks_class->resolve = JS_ResolveStub;
	JSB_CCParticleFireworks_class->convert = JS_ConvertStub;
	JSB_CCParticleFireworks_class->finalize = JSB_CCParticleFireworks_finalize;
	JSB_CCParticleFireworks_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleFireworks_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleFireworks_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleFireworks_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleFireworks_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleFireworks_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleFireworks_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleFireworks_class, JSB_CCParticleFireworks_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleFireworks

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleFireworks_class, JSB_CCParticleFireworks_object, NULL);
	JSB_CCParticleFireworks *proxy = [[JSB_CCParticleFireworks alloc] initWithJSObject:jsobj class:[CCParticleFireworks class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpawn
 */
#pragma mark - CCSpawn

JSClass* JSB_CCSpawn_class = NULL;
JSObject* JSB_CCSpawn_object = NULL;
// Constructor
JSBool JSB_CCSpawn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSpawn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSpawn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSpawn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSpawn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSpawn *proxy = [[JSB_CCSpawn alloc] initWithJSObject:obj class:[CCSpawn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: CCSpawn* (o)
JSBool JSB_CCSpawn_actionOne_two__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpawn* ret_val;

	ret_val = [CCSpawn actionOne:arg0 two:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCSpawn* (o)
JSBool JSB_CCSpawn_actionWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpawn* ret_val;

	ret_val = [CCSpawn actionWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSB_CCSpawn_initOne_two_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpawn *real = [(CCSpawn*)[proxy.klass alloc] initOne:arg0 two:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCSpawn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSpawn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSpawn_class->name = name;
	JSB_CCSpawn_class->addProperty = JS_PropertyStub;
	JSB_CCSpawn_class->delProperty = JS_PropertyStub;
	JSB_CCSpawn_class->getProperty = JS_PropertyStub;
	JSB_CCSpawn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSpawn_class->enumerate = JS_EnumerateStub;
	JSB_CCSpawn_class->resolve = JS_ResolveStub;
	JSB_CCSpawn_class->convert = JS_ConvertStub;
	JSB_CCSpawn_class->finalize = JSB_CCSpawn_finalize;
	JSB_CCSpawn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initOneTwo", JSB_CCSpawn_initOne_two_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSpawn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionOneTwo", JSB_CCSpawn_actionOne_two__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCSpawn_actionWithArray__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSpawn_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCSpawn_class, JSB_CCSpawn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSpawn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSpawn_class, JSB_CCSpawn_object, NULL);
	JSB_CCSpawn *proxy = [[JSB_CCSpawn alloc] initWithJSObject:jsobj class:[CCSpawn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXTiledMap
 */
#pragma mark - CCTMXTiledMap

JSClass* JSB_CCTMXTiledMap_class = NULL;
JSObject* JSB_CCTMXTiledMap_object = NULL;
// Constructor
JSBool JSB_CCTMXTiledMap_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTMXTiledMap createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTMXTiledMap_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTMXTiledMap)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTMXTiledMap_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTMXTiledMap *proxy = [[JSB_CCTMXTiledMap alloc] initWithJSObject:obj class:[CCTMXTiledMap class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCTMXTiledMap_initWithTMXFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXTiledMap *real = [(CCTMXTiledMap*)[proxy.klass alloc] initWithTMXFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSB_CCTMXTiledMap_initWithXML_resourcePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXTiledMap *real = [(CCTMXTiledMap*)[proxy.klass alloc] initWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXLayer* (o)
JSBool JSB_CCTMXTiledMap_layerNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXLayer* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real layerNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCTMXTiledMap_mapOrientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real mapOrientation ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXTiledMap_mapSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real mapSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXObjectGroup* (o)
JSBool JSB_CCTMXTiledMap_objectGroupNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXObjectGroup* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real objectGroupNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCTMXTiledMap_objectGroups(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real objectGroups ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXTiledMap_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real properties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: NSDictionary* (dict)
JSBool JSB_CCTMXTiledMap_propertiesForGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSDictionary* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real propertiesForGID:(unsigned int)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSObject* (o)
JSBool JSB_CCTMXTiledMap_propertyNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSObject* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real propertyNamed:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCTMXTiledMap_setObjectGroups_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	[real setObjectGroups:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXTiledMap_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	[real setProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXTiledMap_tileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real tileSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXTiledMap* (o)
JSBool JSB_CCTMXTiledMap_tiledMapWithTMXFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXTiledMap* ret_val;

	ret_val = [CCTMXTiledMap tiledMapWithTMXFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCTMXTiledMap* (o)
JSBool JSB_CCTMXTiledMap_tiledMapWithXML_resourcePath__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXTiledMap* ret_val;

	ret_val = [CCTMXTiledMap tiledMapWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTMXTiledMap_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTMXTiledMap_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTMXTiledMap_class->name = name;
	JSB_CCTMXTiledMap_class->addProperty = JS_PropertyStub;
	JSB_CCTMXTiledMap_class->delProperty = JS_PropertyStub;
	JSB_CCTMXTiledMap_class->getProperty = JS_PropertyStub;
	JSB_CCTMXTiledMap_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTMXTiledMap_class->enumerate = JS_EnumerateStub;
	JSB_CCTMXTiledMap_class->resolve = JS_ResolveStub;
	JSB_CCTMXTiledMap_class->convert = JS_ConvertStub;
	JSB_CCTMXTiledMap_class->finalize = JSB_CCTMXTiledMap_finalize;
	JSB_CCTMXTiledMap_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTMXFile", JSB_CCTMXTiledMap_initWithTMXFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithXMLResourcePath", JSB_CCTMXTiledMap_initWithXML_resourcePath_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLayer", JSB_CCTMXTiledMap_layerNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMapOrientation", JSB_CCTMXTiledMap_mapOrientation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMapSize", JSB_CCTMXTiledMap_mapSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getObjectGroup", JSB_CCTMXTiledMap_objectGroupNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getObjectGroups", JSB_CCTMXTiledMap_objectGroups, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSB_CCTMXTiledMap_properties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("propertiesForGID", JSB_CCTMXTiledMap_propertiesForGID_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("propertyNamed", JSB_CCTMXTiledMap_propertyNamed_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setObjectGroups", JSB_CCTMXTiledMap_setObjectGroups_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSB_CCTMXTiledMap_setProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileSize", JSB_CCTMXTiledMap_tileSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTMXTiledMap_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTMXTiledMap_tiledMapWithTMXFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("tiledMapWithXMLResourcePath", JSB_CCTMXTiledMap_tiledMapWithXML_resourcePath__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTMXTiledMap_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCTMXTiledMap_class, JSB_CCTMXTiledMap_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTMXTiledMap

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTMXTiledMap_class, JSB_CCTMXTiledMap_object, NULL);
	JSB_CCTMXTiledMap *proxy = [[JSB_CCTMXTiledMap alloc] initWithJSObject:jsobj class:[CCTMXTiledMap class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleExplosion
 */
#pragma mark - CCParticleExplosion

JSClass* JSB_CCParticleExplosion_class = NULL;
JSObject* JSB_CCParticleExplosion_object = NULL;
// Constructor
JSBool JSB_CCParticleExplosion_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleExplosion createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleExplosion_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleExplosion)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleExplosion_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleExplosion *proxy = [[JSB_CCParticleExplosion alloc] initWithJSObject:obj class:[CCParticleExplosion class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleExplosion_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleExplosion *real = [(CCParticleExplosion*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleExplosion* (o)
JSBool JSB_CCParticleExplosion_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleExplosion* (o)
JSBool JSB_CCParticleExplosion_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleExplosion* (o)
JSBool JSB_CCParticleExplosion_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleExplosion_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleExplosion_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleExplosion_class->name = name;
	JSB_CCParticleExplosion_class->addProperty = JS_PropertyStub;
	JSB_CCParticleExplosion_class->delProperty = JS_PropertyStub;
	JSB_CCParticleExplosion_class->getProperty = JS_PropertyStub;
	JSB_CCParticleExplosion_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleExplosion_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleExplosion_class->resolve = JS_ResolveStub;
	JSB_CCParticleExplosion_class->convert = JS_ConvertStub;
	JSB_CCParticleExplosion_class->finalize = JSB_CCParticleExplosion_finalize;
	JSB_CCParticleExplosion_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleExplosion_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleExplosion_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleExplosion_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleExplosion_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleExplosion_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleExplosion_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleExplosion_class, JSB_CCParticleExplosion_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleExplosion

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleExplosion_class, JSB_CCParticleExplosion_object, NULL);
	JSB_CCParticleExplosion *proxy = [[JSB_CCParticleExplosion alloc] initWithJSObject:jsobj class:[CCParticleExplosion class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCToggleVisibility
 */
#pragma mark - CCToggleVisibility

JSClass* JSB_CCToggleVisibility_class = NULL;
JSObject* JSB_CCToggleVisibility_object = NULL;
// Constructor
JSBool JSB_CCToggleVisibility_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCToggleVisibility createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCToggleVisibility_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCToggleVisibility)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCToggleVisibility_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCToggleVisibility *proxy = [[JSB_CCToggleVisibility alloc] initWithJSObject:obj class:[CCToggleVisibility class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCToggleVisibility_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCToggleVisibility *real = (CCToggleVisibility*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCToggleVisibility* (o)
JSBool JSB_CCToggleVisibility_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCToggleVisibility* ret_val;

	ret_val = [CCToggleVisibility action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCToggleVisibility_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCToggleVisibility_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCToggleVisibility_class->name = name;
	JSB_CCToggleVisibility_class->addProperty = JS_PropertyStub;
	JSB_CCToggleVisibility_class->delProperty = JS_PropertyStub;
	JSB_CCToggleVisibility_class->getProperty = JS_PropertyStub;
	JSB_CCToggleVisibility_class->setProperty = JS_StrictPropertyStub;
	JSB_CCToggleVisibility_class->enumerate = JS_EnumerateStub;
	JSB_CCToggleVisibility_class->resolve = JS_ResolveStub;
	JSB_CCToggleVisibility_class->convert = JS_ConvertStub;
	JSB_CCToggleVisibility_class->finalize = JSB_CCToggleVisibility_finalize;
	JSB_CCToggleVisibility_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCToggleVisibility_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCToggleVisibility_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCToggleVisibility_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCToggleVisibility_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCToggleVisibility_class, JSB_CCToggleVisibility_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCToggleVisibility

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCToggleVisibility_class, JSB_CCToggleVisibility_object, NULL);
	JSB_CCToggleVisibility *proxy = [[JSB_CCToggleVisibility alloc] initWithJSObject:jsobj class:[CCToggleVisibility class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFade
 */
#pragma mark - CCTransitionFade

JSClass* JSB_CCTransitionFade_class = NULL;
JSObject* JSB_CCTransitionFade_object = NULL;
// Constructor
JSBool JSB_CCTransitionFade_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFade createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFade_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFade)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFade_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFade *proxy = [[JSB_CCTransitionFade alloc] initWithJSObject:obj class:[CCTransitionFade class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, ccColor3B
// Ret value: None (None)
JSBool JSB_CCTransitionFade_initWithDuration_scene_withColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; ccColor3B arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTransitionFade *real = [(CCTransitionFade*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:arg1 withColor:(ccColor3B)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, ccColor3B
// Ret value: CCTransitionFade* (o)
JSBool JSB_CCTransitionFade_transitionWithDuration_scene_withColor__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; ccColor3B arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFade* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionFade transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionFade transitionWithDuration:(ccTime)arg0 scene:arg1 withColor:(ccColor3B)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFade* (o)
JSBool JSB_CCTransitionFade_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFade* ret_val;

	ret_val = [CCTransitionFade node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFade_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFade_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFade_class->name = name;
	JSB_CCTransitionFade_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFade_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFade_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFade_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFade_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFade_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFade_class->convert = JS_ConvertStub;
	JSB_CCTransitionFade_class->finalize = JSB_CCTransitionFade_finalize;
	JSB_CCTransitionFade_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSceneWithColor", JSB_CCTransitionFade_initWithDuration_scene_withColor_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFade_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFade_transitionWithDuration_scene_withColor__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFade_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFade_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionFade_class, JSB_CCTransitionFade_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFade

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFade_class, JSB_CCTransitionFade_object, NULL);
	JSB_CCTransitionFade *proxy = [[JSB_CCTransitionFade alloc] initWithJSObject:jsobj class:[CCTransitionFade class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelAtlas
 */
#pragma mark - CCLabelAtlas

JSClass* JSB_CCLabelAtlas_class = NULL;
JSObject* JSB_CCLabelAtlas_object = NULL;
// Constructor
JSBool JSB_CCLabelAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLabelAtlas createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLabelAtlas_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLabelAtlas)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLabelAtlas_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLabelAtlas *proxy = [[JSB_CCLabelAtlas alloc] initWithJSObject:obj class:[CCLabelAtlas class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSB_CCLabelAtlas_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; uint32_t arg2; uint32_t arg3; uint32_t arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelAtlas *real = [(CCLabelAtlas*)[proxy.klass alloc] initWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(NSUInteger)arg2 itemHeight:(NSUInteger)arg3 startCharMap:(NSUInteger)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSB_CCLabelAtlas_initWithString_fntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelAtlas *real = [(CCLabelAtlas*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, CCTexture2D*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSB_CCLabelAtlas_initWithString_texture_itemWidth_itemHeight_startCharMap_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; id arg1; uint32_t arg2; uint32_t arg3; uint32_t arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelAtlas *real = [(CCLabelAtlas*)[proxy.klass alloc] initWithString:(NSString*)arg0 texture:arg1 itemWidth:(NSUInteger)arg2 itemHeight:(NSUInteger)arg3 startCharMap:(NSUInteger)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCLabelAtlas* (o)
JSBool JSB_CCLabelAtlas_labelWithString_charMapFile_itemWidth_itemHeight_startCharMap__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 5 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; uint32_t arg2; uint32_t arg3; uint32_t arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	}
	if (argc >= 5) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg4 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLabelAtlas* ret_val;

	if( argc == 2 ) {
		ret_val = [CCLabelAtlas labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	}
	else if( argc == 5 ) {
		ret_val = [CCLabelAtlas labelWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(NSUInteger)arg2 itemHeight:(NSUInteger)arg3 startCharMap:(NSUInteger)arg4  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: char*
// Ret value: void (None)
JSBool JSB_CCLabelAtlas_setCString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	const char* arg0; 

	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelAtlas *real = (CCLabelAtlas*) [proxy realObj];
	[real setCString:(char*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCLabelAtlas_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelAtlas *real = (CCLabelAtlas*) [proxy realObj];
	[real setString:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCLabelAtlas_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelAtlas *real = (CCLabelAtlas*) [proxy realObj];
	ret_val = [real string ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_CCLabelAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLabelAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLabelAtlas_class->name = name;
	JSB_CCLabelAtlas_class->addProperty = JS_PropertyStub;
	JSB_CCLabelAtlas_class->delProperty = JS_PropertyStub;
	JSB_CCLabelAtlas_class->getProperty = JS_PropertyStub;
	JSB_CCLabelAtlas_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLabelAtlas_class->enumerate = JS_EnumerateStub;
	JSB_CCLabelAtlas_class->resolve = JS_ResolveStub;
	JSB_CCLabelAtlas_class->convert = JS_ConvertStub;
	JSB_CCLabelAtlas_class->finalize = JSB_CCLabelAtlas_finalize;
	JSB_CCLabelAtlas_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithStringCharMapFileItemWidthItemHeightStartCharMap", JSB_CCLabelAtlas_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFile", JSB_CCLabelAtlas_initWithString_fntFile_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringTextureItemWidthItemHeightStartCharMap", JSB_CCLabelAtlas_initWithString_texture_itemWidth_itemHeight_startCharMap_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCString", JSB_CCLabelAtlas_setCString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setString", JSB_CCLabelAtlas_setString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getString", JSB_CCLabelAtlas_string, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLabelAtlas_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("_create", JSB_CCLabelAtlas_labelWithString_charMapFile_itemWidth_itemHeight_startCharMap__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLabelAtlas_object = JS_InitClass(cx, globalObj, JSB_CCAtlasNode_object, JSB_CCLabelAtlas_class, JSB_CCLabelAtlas_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLabelAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLabelAtlas_class, JSB_CCLabelAtlas_object, NULL);
	JSB_CCLabelAtlas *proxy = [[JSB_CCLabelAtlas alloc] initWithJSObject:jsobj class:[CCLabelAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInL
 */
#pragma mark - CCTransitionMoveInL

JSClass* JSB_CCTransitionMoveInL_class = NULL;
JSObject* JSB_CCTransitionMoveInL_object = NULL;
// Constructor
JSBool JSB_CCTransitionMoveInL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionMoveInL createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionMoveInL_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionMoveInL)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionMoveInL_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionMoveInL *proxy = [[JSB_CCTransitionMoveInL alloc] initWithJSObject:obj class:[CCTransitionMoveInL class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionMoveInL_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	ret_val = [real action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionMoveInL_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionMoveInL_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInL* (o)
JSBool JSB_CCTransitionMoveInL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionMoveInL* ret_val;

	ret_val = [CCTransitionMoveInL transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInL* (o)
JSBool JSB_CCTransitionMoveInL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionMoveInL* ret_val;

	ret_val = [CCTransitionMoveInL node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionMoveInL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionMoveInL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionMoveInL_class->name = name;
	JSB_CCTransitionMoveInL_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInL_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInL_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInL_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionMoveInL_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionMoveInL_class->resolve = JS_ResolveStub;
	JSB_CCTransitionMoveInL_class->convert = JS_ConvertStub;
	JSB_CCTransitionMoveInL_class->finalize = JSB_CCTransitionMoveInL_finalize;
	JSB_CCTransitionMoveInL_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSB_CCTransitionMoveInL_action, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initScenes", JSB_CCTransitionMoveInL_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionMoveInL_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionMoveInL_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionMoveInL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionMoveInL_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionMoveInL_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionMoveInL_class, JSB_CCTransitionMoveInL_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionMoveInL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionMoveInL_class, JSB_CCTransitionMoveInL_object, NULL);
	JSB_CCTransitionMoveInL *proxy = [[JSB_CCTransitionMoveInL alloc] initWithJSObject:jsobj class:[CCTransitionMoveInL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInT
 */
#pragma mark - CCTransitionMoveInT

JSClass* JSB_CCTransitionMoveInT_class = NULL;
JSObject* JSB_CCTransitionMoveInT_object = NULL;
// Constructor
JSBool JSB_CCTransitionMoveInT_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionMoveInT createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionMoveInT_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionMoveInT)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionMoveInT_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionMoveInT *proxy = [[JSB_CCTransitionMoveInT alloc] initWithJSObject:obj class:[CCTransitionMoveInT class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionMoveInT_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionMoveInT *real = (CCTransitionMoveInT*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInT* (o)
JSBool JSB_CCTransitionMoveInT_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionMoveInT* ret_val;

	ret_val = [CCTransitionMoveInT transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInT* (o)
JSBool JSB_CCTransitionMoveInT_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionMoveInT* ret_val;

	ret_val = [CCTransitionMoveInT node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionMoveInT_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionMoveInT_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionMoveInT_class->name = name;
	JSB_CCTransitionMoveInT_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInT_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInT_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInT_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionMoveInT_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionMoveInT_class->resolve = JS_ResolveStub;
	JSB_CCTransitionMoveInT_class->convert = JS_ConvertStub;
	JSB_CCTransitionMoveInT_class->finalize = JSB_CCTransitionMoveInT_finalize;
	JSB_CCTransitionMoveInT_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionMoveInT_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionMoveInT_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionMoveInT_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionMoveInT_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionMoveInT_object = JS_InitClass(cx, globalObj, JSB_CCTransitionMoveInL_object, JSB_CCTransitionMoveInT_class, JSB_CCTransitionMoveInT_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionMoveInT

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionMoveInT_class, JSB_CCTransitionMoveInT_object, NULL);
	JSB_CCTransitionMoveInT *proxy = [[JSB_CCTransitionMoveInT alloc] initWithJSObject:jsobj class:[CCTransitionMoveInT class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInR
 */
#pragma mark - CCTransitionMoveInR

JSClass* JSB_CCTransitionMoveInR_class = NULL;
JSObject* JSB_CCTransitionMoveInR_object = NULL;
// Constructor
JSBool JSB_CCTransitionMoveInR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionMoveInR createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionMoveInR_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionMoveInR)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionMoveInR_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionMoveInR *proxy = [[JSB_CCTransitionMoveInR alloc] initWithJSObject:obj class:[CCTransitionMoveInR class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionMoveInR_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionMoveInR *real = (CCTransitionMoveInR*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInR* (o)
JSBool JSB_CCTransitionMoveInR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionMoveInR* ret_val;

	ret_val = [CCTransitionMoveInR transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInR* (o)
JSBool JSB_CCTransitionMoveInR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionMoveInR* ret_val;

	ret_val = [CCTransitionMoveInR node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionMoveInR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionMoveInR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionMoveInR_class->name = name;
	JSB_CCTransitionMoveInR_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInR_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInR_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInR_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionMoveInR_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionMoveInR_class->resolve = JS_ResolveStub;
	JSB_CCTransitionMoveInR_class->convert = JS_ConvertStub;
	JSB_CCTransitionMoveInR_class->finalize = JSB_CCTransitionMoveInR_finalize;
	JSB_CCTransitionMoveInR_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionMoveInR_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionMoveInR_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionMoveInR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionMoveInR_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionMoveInR_object = JS_InitClass(cx, globalObj, JSB_CCTransitionMoveInL_object, JSB_CCTransitionMoveInR_class, JSB_CCTransitionMoveInR_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionMoveInR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionMoveInR_class, JSB_CCTransitionMoveInR_object, NULL);
	JSB_CCTransitionMoveInR *proxy = [[JSB_CCTransitionMoveInR alloc] initWithJSObject:jsobj class:[CCTransitionMoveInR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialIn
 */
#pragma mark - CCEaseExponentialIn

JSClass* JSB_CCEaseExponentialIn_class = NULL;
JSObject* JSB_CCEaseExponentialIn_object = NULL;
// Constructor
JSBool JSB_CCEaseExponentialIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseExponentialIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseExponentialIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseExponentialIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseExponentialIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseExponentialIn *proxy = [[JSB_CCEaseExponentialIn alloc] initWithJSObject:obj class:[CCEaseExponentialIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseExponentialIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseExponentialIn *real = (CCEaseExponentialIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialIn* (o)
JSBool JSB_CCEaseExponentialIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseExponentialIn* ret_val;

	ret_val = [CCEaseExponentialIn actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseExponentialIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseExponentialIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseExponentialIn_class->name = name;
	JSB_CCEaseExponentialIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseExponentialIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseExponentialIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseExponentialIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseExponentialIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseExponentialIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseExponentialIn_class->convert = JS_ConvertStub;
	JSB_CCEaseExponentialIn_class->finalize = JSB_CCEaseExponentialIn_finalize;
	JSB_CCEaseExponentialIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseExponentialIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseExponentialIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseExponentialIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseExponentialIn_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseExponentialIn_class, JSB_CCEaseExponentialIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseExponentialIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseExponentialIn_class, JSB_CCEaseExponentialIn_object, NULL);
	JSB_CCEaseExponentialIn *proxy = [[JSB_CCEaseExponentialIn alloc] initWithJSObject:jsobj class:[CCEaseExponentialIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPlace
 */
#pragma mark - CCPlace

JSClass* JSB_CCPlace_class = NULL;
JSObject* JSB_CCPlace_object = NULL;
// Constructor
JSBool JSB_CCPlace_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCPlace createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCPlace_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCPlace)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCPlace_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCPlace *proxy = [[JSB_CCPlace alloc] initWithJSObject:obj class:[CCPlace class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CCPlace* (o)
JSBool JSB_CCPlace_actionWithPosition__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPlace* ret_val;

	ret_val = [CCPlace actionWithPosition:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: None (None)
JSBool JSB_CCPlace_initWithPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCPlace *real = [(CCPlace*)[proxy.klass alloc] initWithPosition:(CGPoint)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCPlace_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCPlace_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCPlace_class->name = name;
	JSB_CCPlace_class->addProperty = JS_PropertyStub;
	JSB_CCPlace_class->delProperty = JS_PropertyStub;
	JSB_CCPlace_class->getProperty = JS_PropertyStub;
	JSB_CCPlace_class->setProperty = JS_StrictPropertyStub;
	JSB_CCPlace_class->enumerate = JS_EnumerateStub;
	JSB_CCPlace_class->resolve = JS_ResolveStub;
	JSB_CCPlace_class->convert = JS_ConvertStub;
	JSB_CCPlace_class->finalize = JSB_CCPlace_finalize;
	JSB_CCPlace_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithPosition", JSB_CCPlace_initWithPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCPlace_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCPlace_actionWithPosition__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCPlace_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCPlace_class, JSB_CCPlace_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCPlace

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCPlace_class, JSB_CCPlace_object, NULL);
	JSB_CCPlace *proxy = [[JSB_CCPlace alloc] initWithJSObject:jsobj class:[CCPlace class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFire
 */
#pragma mark - CCParticleFire

JSClass* JSB_CCParticleFire_class = NULL;
JSObject* JSB_CCParticleFire_object = NULL;
// Constructor
JSBool JSB_CCParticleFire_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleFire createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleFire_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleFire)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleFire_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleFire *proxy = [[JSB_CCParticleFire alloc] initWithJSObject:obj class:[CCParticleFire class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleFire_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleFire *real = [(CCParticleFire*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFire* (o)
JSBool JSB_CCParticleFire_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFire* (o)
JSBool JSB_CCParticleFire_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFire* (o)
JSBool JSB_CCParticleFire_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleFire_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleFire_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleFire_class->name = name;
	JSB_CCParticleFire_class->addProperty = JS_PropertyStub;
	JSB_CCParticleFire_class->delProperty = JS_PropertyStub;
	JSB_CCParticleFire_class->getProperty = JS_PropertyStub;
	JSB_CCParticleFire_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleFire_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleFire_class->resolve = JS_ResolveStub;
	JSB_CCParticleFire_class->convert = JS_ConvertStub;
	JSB_CCParticleFire_class->finalize = JSB_CCParticleFire_finalize;
	JSB_CCParticleFire_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleFire_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleFire_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleFire_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleFire_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleFire_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleFire_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleFire_class, JSB_CCParticleFire_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleFire

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleFire_class, JSB_CCParticleFire_object, NULL);
	JSB_CCParticleFire *proxy = [[JSB_CCParticleFire alloc] initWithJSObject:jsobj class:[CCParticleFire class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCatmullRomTo
 */
#pragma mark - CCCatmullRomTo

JSClass* JSB_CCCatmullRomTo_class = NULL;
JSObject* JSB_CCCatmullRomTo_object = NULL;
// Constructor
JSBool JSB_CCCatmullRomTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCatmullRomTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCatmullRomTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCatmullRomTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCatmullRomTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCatmullRomTo *proxy = [[JSB_CCCatmullRomTo alloc] initWithJSObject:obj class:[CCCatmullRomTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*
// Ret value: None (None)
JSBool JSB_CCCatmullRomTo_initWithDuration_points_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCatmullRomTo *real = [(CCCatmullRomTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCCatmullRomTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCatmullRomTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCatmullRomTo_class->name = name;
	JSB_CCCatmullRomTo_class->addProperty = JS_PropertyStub;
	JSB_CCCatmullRomTo_class->delProperty = JS_PropertyStub;
	JSB_CCCatmullRomTo_class->getProperty = JS_PropertyStub;
	JSB_CCCatmullRomTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCatmullRomTo_class->enumerate = JS_EnumerateStub;
	JSB_CCCatmullRomTo_class->resolve = JS_ResolveStub;
	JSB_CCCatmullRomTo_class->convert = JS_ConvertStub;
	JSB_CCCatmullRomTo_class->finalize = JSB_CCCatmullRomTo_finalize;
	JSB_CCCatmullRomTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPoints", JSB_CCCatmullRomTo_initWithDuration_points_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCatmullRomTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCCatmullRomTo_actionWithDuration_points__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCatmullRomTo_object = JS_InitClass(cx, globalObj, JSB_CCCardinalSplineTo_object, JSB_CCCatmullRomTo_class, JSB_CCCatmullRomTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCatmullRomTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCatmullRomTo_class, JSB_CCCatmullRomTo_object, NULL);
	JSB_CCCatmullRomTo *proxy = [[JSB_CCCatmullRomTo alloc] initWithJSObject:jsobj class:[CCCatmullRomTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCStopGrid
 */
#pragma mark - CCStopGrid

JSClass* JSB_CCStopGrid_class = NULL;
JSObject* JSB_CCStopGrid_object = NULL;
// Constructor
JSBool JSB_CCStopGrid_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCStopGrid createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCStopGrid_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCStopGrid)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCStopGrid_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCStopGrid *proxy = [[JSB_CCStopGrid alloc] initWithJSObject:obj class:[CCStopGrid class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCStopGrid_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCStopGrid *real = (CCStopGrid*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCStopGrid* (o)
JSBool JSB_CCStopGrid_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCStopGrid* ret_val;

	ret_val = [CCStopGrid action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCStopGrid_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCStopGrid_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCStopGrid_class->name = name;
	JSB_CCStopGrid_class->addProperty = JS_PropertyStub;
	JSB_CCStopGrid_class->delProperty = JS_PropertyStub;
	JSB_CCStopGrid_class->getProperty = JS_PropertyStub;
	JSB_CCStopGrid_class->setProperty = JS_StrictPropertyStub;
	JSB_CCStopGrid_class->enumerate = JS_EnumerateStub;
	JSB_CCStopGrid_class->resolve = JS_ResolveStub;
	JSB_CCStopGrid_class->convert = JS_ConvertStub;
	JSB_CCStopGrid_class->finalize = JSB_CCStopGrid_finalize;
	JSB_CCStopGrid_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCStopGrid_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCStopGrid_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCStopGrid_action_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCStopGrid_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCStopGrid_class, JSB_CCStopGrid_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCStopGrid

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCStopGrid_class, JSB_CCStopGrid_object, NULL);
	JSB_CCStopGrid *proxy = [[JSB_CCStopGrid alloc] initWithJSObject:jsobj class:[CCStopGrid class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelBMFont
 */
#pragma mark - CCLabelBMFont

JSClass* JSB_CCLabelBMFont_class = NULL;
JSObject* JSB_CCLabelBMFont_object = NULL;
// Constructor
JSBool JSB_CCLabelBMFont_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLabelBMFont createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLabelBMFont_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLabelBMFont)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLabelBMFont_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLabelBMFont *proxy = [[JSB_CCLabelBMFont alloc] initWithJSObject:obj class:[CCLabelBMFont class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextAlignment (i)
JSBool JSB_CCLabelBMFont_alignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextAlignment ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real alignment ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLabelBMFont_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_createFontChars(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real createFontChars ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCLabelBMFont_fntFile(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real fntFile ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSB_CCLabelBMFont_initWithString_fntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment
// Ret value: None (None)
JSBool JSB_CCLabelBMFont_initWithString_fntFile_width_alignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment, CGPoint
// Ret value: None (None)
JSBool JSB_CCLabelBMFont_initWithString_fntFile_width_alignment_imageOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; CGPoint arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3 imageOffset:(CGPoint)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment, CGPoint
// Ret value: CCLabelBMFont* (o)
JSBool JSB_CCLabelBMFont_labelWithString_fntFile_width_alignment_imageOffset__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 5 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; CGPoint arg4; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg3 );
	}
	if (argc >= 5) {
		ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg4 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLabelBMFont* ret_val;

	if( argc == 0 ) {
		ret_val = [CCLabelBMFont node ];
	}
	else if( argc == 2 ) {
		ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	}
	else if( argc == 4 ) {
		ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3  ];
	}
	else if( argc == 5 ) {
		ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3 imageOffset:(CGPoint)arg4  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLabelBMFont_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_purgeCachedData_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[CCLabelBMFont purgeCachedData ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTextAlignment
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setAlignment:(CCTextAlignment)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setFntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setFntFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setWidth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setWidth:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: char*
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setCString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	const char* arg0; 

	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setCString:(char*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setString:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCLabelBMFont_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real string ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCLabelBMFont_displayedColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real displayedColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCLabelBMFont_displayedOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real displayedOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLabelBMFont_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLabelBMFont_isCascadeColorEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real isCascadeColorEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCLabelBMFont_isCascadeOpacityEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real isCascadeOpacityEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setCascadeColorEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setCascadeColorEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setCascadeOpacityEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setCascadeOpacityEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_updateDisplayedColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real updateDisplayedColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCLabelBMFont_updateDisplayedOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real updateDisplayedOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCLabelBMFont_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLabelBMFont_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLabelBMFont_class->name = name;
	JSB_CCLabelBMFont_class->addProperty = JS_PropertyStub;
	JSB_CCLabelBMFont_class->delProperty = JS_PropertyStub;
	JSB_CCLabelBMFont_class->getProperty = JS_PropertyStub;
	JSB_CCLabelBMFont_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLabelBMFont_class->enumerate = JS_EnumerateStub;
	JSB_CCLabelBMFont_class->resolve = JS_ResolveStub;
	JSB_CCLabelBMFont_class->convert = JS_ConvertStub;
	JSB_CCLabelBMFont_class->finalize = JSB_CCLabelBMFont_finalize;
	JSB_CCLabelBMFont_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAlignment", JSB_CCLabelBMFont_alignment, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getColor", JSB_CCLabelBMFont_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createFontChars", JSB_CCLabelBMFont_createFontChars, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFntFile", JSB_CCLabelBMFont_fntFile, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFile", JSB_CCLabelBMFont_initWithString_fntFile_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFileWidthAlignment", JSB_CCLabelBMFont_initWithString_fntFile_width_alignment_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFileWidthAlignmentImageOffset", JSB_CCLabelBMFont_initWithString_fntFile_width_alignment_imageOffset_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSB_CCLabelBMFont_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAlignment", JSB_CCLabelBMFont_setAlignment_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCLabelBMFont_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFntFile", JSB_CCLabelBMFont_setFntFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCLabelBMFont_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setWidth", JSB_CCLabelBMFont_setWidth_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCString", JSB_CCLabelBMFont_setCString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setString", JSB_CCLabelBMFont_setString_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getString", JSB_CCLabelBMFont_string, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedColor", JSB_CCLabelBMFont_displayedColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedOpacity", JSB_CCLabelBMFont_displayedOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCLabelBMFont_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeColorEnabled", JSB_CCLabelBMFont_isCascadeColorEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeOpacityEnabled", JSB_CCLabelBMFont_isCascadeOpacityEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeColorEnabled", JSB_CCLabelBMFont_setCascadeColorEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeOpacityEnabled", JSB_CCLabelBMFont_setCascadeOpacityEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCLabelBMFont_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedColor", JSB_CCLabelBMFont_updateDisplayedColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedOpacity", JSB_CCLabelBMFont_updateDisplayedOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLabelBMFont_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLabelBMFont_labelWithString_fntFile_width_alignment_imageOffset__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("purgeCachedData", JSB_CCLabelBMFont_purgeCachedData_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLabelBMFont_object = JS_InitClass(cx, globalObj, JSB_CCSpriteBatchNode_object, JSB_CCLabelBMFont_class, JSB_CCLabelBMFont_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLabelBMFont

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLabelBMFont_class, JSB_CCLabelBMFont_object, NULL);
	JSB_CCLabelBMFont *proxy = [[JSB_CCLabelBMFont alloc] initWithJSObject:jsobj class:[CCLabelBMFont class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInB
 */
#pragma mark - CCTransitionMoveInB

JSClass* JSB_CCTransitionMoveInB_class = NULL;
JSObject* JSB_CCTransitionMoveInB_object = NULL;
// Constructor
JSBool JSB_CCTransitionMoveInB_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionMoveInB createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionMoveInB_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionMoveInB)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionMoveInB_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionMoveInB *proxy = [[JSB_CCTransitionMoveInB alloc] initWithJSObject:obj class:[CCTransitionMoveInB class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionMoveInB_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionMoveInB *real = (CCTransitionMoveInB*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInB* (o)
JSBool JSB_CCTransitionMoveInB_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionMoveInB* ret_val;

	ret_val = [CCTransitionMoveInB transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInB* (o)
JSBool JSB_CCTransitionMoveInB_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionMoveInB* ret_val;

	ret_val = [CCTransitionMoveInB node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionMoveInB_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionMoveInB_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionMoveInB_class->name = name;
	JSB_CCTransitionMoveInB_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInB_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInB_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionMoveInB_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionMoveInB_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionMoveInB_class->resolve = JS_ResolveStub;
	JSB_CCTransitionMoveInB_class->convert = JS_ConvertStub;
	JSB_CCTransitionMoveInB_class->finalize = JSB_CCTransitionMoveInB_finalize;
	JSB_CCTransitionMoveInB_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionMoveInB_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionMoveInB_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionMoveInB_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionMoveInB_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionMoveInB_object = JS_InitClass(cx, globalObj, JSB_CCTransitionMoveInL_object, JSB_CCTransitionMoveInB_class, JSB_CCTransitionMoveInB_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionMoveInB

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionMoveInB_class, JSB_CCTransitionMoveInB_object, NULL);
	JSB_CCTransitionMoveInB *proxy = [[JSB_CCTransitionMoveInB alloc] initWithJSObject:jsobj class:[CCTransitionMoveInB class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipX
 */
#pragma mark - CCTransitionZoomFlipX

JSClass* JSB_CCTransitionZoomFlipX_class = NULL;
JSObject* JSB_CCTransitionZoomFlipX_object = NULL;
// Constructor
JSBool JSB_CCTransitionZoomFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionZoomFlipX createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionZoomFlipX_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionZoomFlipX)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionZoomFlipX_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionZoomFlipX *proxy = [[JSB_CCTransitionZoomFlipX alloc] initWithJSObject:obj class:[CCTransitionZoomFlipX class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionZoomFlipX_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionZoomFlipX *real = [(CCTransitionZoomFlipX*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipX* (o)
JSBool JSB_CCTransitionZoomFlipX_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionZoomFlipX* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionZoomFlipX transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionZoomFlipX transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipX* (o)
JSBool JSB_CCTransitionZoomFlipX_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionZoomFlipX* ret_val;

	ret_val = [CCTransitionZoomFlipX node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionZoomFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionZoomFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionZoomFlipX_class->name = name;
	JSB_CCTransitionZoomFlipX_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipX_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipX_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipX_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionZoomFlipX_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionZoomFlipX_class->resolve = JS_ResolveStub;
	JSB_CCTransitionZoomFlipX_class->convert = JS_ConvertStub;
	JSB_CCTransitionZoomFlipX_class->finalize = JSB_CCTransitionZoomFlipX_finalize;
	JSB_CCTransitionZoomFlipX_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionZoomFlipX_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionZoomFlipX_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionZoomFlipX_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionZoomFlipX_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionZoomFlipX_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionZoomFlipX_class, JSB_CCTransitionZoomFlipX_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionZoomFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionZoomFlipX_class, JSB_CCTransitionZoomFlipX_object, NULL);
	JSB_CCTransitionZoomFlipX *proxy = [[JSB_CCTransitionZoomFlipX alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseOut
 */
#pragma mark - CCEaseOut

JSClass* JSB_CCEaseOut_class = NULL;
JSObject* JSB_CCEaseOut_object = NULL;
// Constructor
JSBool JSB_CCEaseOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseOut *proxy = [[JSB_CCEaseOut alloc] initWithJSObject:obj class:[CCEaseOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseOut *real = (CCEaseOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseOut* (o)
JSBool JSB_CCEaseOut_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseOut* ret_val;

	ret_val = [CCEaseOut actionWithAction:arg0 rate:(float)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseOut_class->name = name;
	JSB_CCEaseOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseOut_class->convert = JS_ConvertStub;
	JSB_CCEaseOut_class->finalize = JSB_CCEaseOut_finalize;
	JSB_CCEaseOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseOut_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseRateAction_object, JSB_CCEaseOut_class, JSB_CCEaseOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseOut_class, JSB_CCEaseOut_object, NULL);
	JSB_CCEaseOut *proxy = [[JSB_CCEaseOut alloc] initWithJSObject:jsobj class:[CCEaseOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemToggle
 */
#pragma mark - CCMenuItemToggle

JSClass* JSB_CCMenuItemToggle_class = NULL;
JSObject* JSB_CCMenuItemToggle_object = NULL;
// Constructor
JSBool JSB_CCMenuItemToggle_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMenuItemToggle createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMenuItemToggle_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMenuItemToggle)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMenuItemToggle_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMenuItemToggle *proxy = [[JSB_CCMenuItemToggle alloc] initWithJSObject:obj class:[CCMenuItemToggle class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSArray*, void (^)(id)
// Ret value: None (None)
JSBool JSB_CCMenuItemToggle_initWithItems_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; js_block arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = [(CCMenuItemToggle*)[proxy.klass alloc] initWithItems:(NSArray*)arg0 block:(void (^)(id))arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCMenuItemToggle* (o)
JSBool JSB_CCMenuItemToggle_itemWithItems__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle itemWithItems:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*, void (^)(id)
// Ret value: CCMenuItemToggle* (o)
JSBool JSB_CCMenuItemToggle_itemWithItems_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; js_block arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle itemWithItems:(NSArray*)arg0 block:(void (^)(id))arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCMenuItemToggle_selectedIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real selectedIndex ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItem* (o)
JSBool JSB_CCMenuItemToggle_selectedItem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCMenuItem* ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real selectedItem ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setSelectedIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setSelectedIndex:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setSubItems_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setSubItems:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCMenuItemToggle_subItems(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real subItems ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCMenuItemToggle_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real color ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B (N/A)
JSBool JSB_CCMenuItemToggle_displayedColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real displayedColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor3B( cx, (ccColor3B)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCMenuItemToggle_displayedOpacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real displayedOpacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemToggle_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemToggle_isCascadeColorEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real isCascadeColorEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCMenuItemToggle_isCascadeOpacityEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real isCascadeOpacityEnabled ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSB_CCMenuItemToggle_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setCascadeColorEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setCascadeColorEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setCascadeOpacityEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setCascadeOpacityEnabled:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_updateDisplayedColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 

	ok &= JSB_jsval_to_ccColor3B( cx, *argvp++, (ccColor3B*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real updateDisplayedColor:(ccColor3B)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSB_CCMenuItemToggle_updateDisplayedOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real updateDisplayedOpacity:(GLubyte)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCMenuItemToggle_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMenuItemToggle_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMenuItemToggle_class->name = name;
	JSB_CCMenuItemToggle_class->addProperty = JS_PropertyStub;
	JSB_CCMenuItemToggle_class->delProperty = JS_PropertyStub;
	JSB_CCMenuItemToggle_class->getProperty = JS_PropertyStub;
	JSB_CCMenuItemToggle_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMenuItemToggle_class->enumerate = JS_EnumerateStub;
	JSB_CCMenuItemToggle_class->resolve = JS_ResolveStub;
	JSB_CCMenuItemToggle_class->convert = JS_ConvertStub;
	JSB_CCMenuItemToggle_class->finalize = JSB_CCMenuItemToggle_finalize;
	JSB_CCMenuItemToggle_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithItemsBlock", JSB_CCMenuItemToggle_initWithItems_block_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSelectedIndex", JSB_CCMenuItemToggle_selectedIndex, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("selectedItem", JSB_CCMenuItemToggle_selectedItem, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSelectedIndex", JSB_CCMenuItemToggle_setSelectedIndex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSubItems", JSB_CCMenuItemToggle_setSubItems_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSubItems", JSB_CCMenuItemToggle_subItems, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getColor", JSB_CCMenuItemToggle_color, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedColor", JSB_CCMenuItemToggle_displayedColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDisplayedOpacity", JSB_CCMenuItemToggle_displayedOpacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSB_CCMenuItemToggle_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeColorEnabled", JSB_CCMenuItemToggle_isCascadeColorEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isCascadeOpacityEnabled", JSB_CCMenuItemToggle_isCascadeOpacityEnabled, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSB_CCMenuItemToggle_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeColorEnabled", JSB_CCMenuItemToggle_setCascadeColorEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setCascadeOpacityEnabled", JSB_CCMenuItemToggle_setCascadeOpacityEnabled_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setColor", JSB_CCMenuItemToggle_setColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCMenuItemToggle_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSB_CCMenuItemToggle_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedColor", JSB_CCMenuItemToggle_updateDisplayedColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateDisplayedOpacity", JSB_CCMenuItemToggle_updateDisplayedOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMenuItemToggle_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("_create", JSB_CCMenuItemToggle_itemWithItems__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("itemWithItemsBlock", JSB_CCMenuItemToggle_itemWithItems_block__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMenuItemToggle_object = JS_InitClass(cx, globalObj, JSB_CCMenuItem_object, JSB_CCMenuItemToggle_class, JSB_CCMenuItemToggle_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMenuItemToggle

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMenuItemToggle_class, JSB_CCMenuItemToggle_object, NULL);
	JSB_CCMenuItemToggle *proxy = [[JSB_CCMenuItemToggle alloc] initWithJSObject:jsobj class:[CCMenuItemToggle class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScheduler
 */
#pragma mark - CCScheduler

JSClass* JSB_CCScheduler_class = NULL;
JSObject* JSB_CCScheduler_object = NULL;
// Constructor
JSBool JSB_CCScheduler_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCScheduler createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCScheduler_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCScheduler)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCScheduler_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCScheduler *proxy = [[JSB_CCScheduler alloc] initWithJSObject:obj class:[CCScheduler class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCScheduler_isPaused(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real isPaused ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: BOOL (b)
JSBool JSB_CCScheduler_isTargetPaused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real isTargetPaused:arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSSet* (set)
JSBool JSB_CCScheduler_pauseAllTargets(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSSet* ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real pauseAllTargets ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSSet( cx, (NSSet*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: NSSet* (set)
JSBool JSB_CCScheduler_pauseAllTargetsWithMinPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSSet* ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real pauseAllTargetsWithMinPriority:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSSet( cx, (NSSet*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCScheduler_pauseTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real pauseTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCScheduler_resumeTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real resumeTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSSet*
// Ret value: void (None)
JSBool JSB_CCScheduler_resumeTargets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSSet* arg0; 

	ok &= JSB_jsval_to_NSSet( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real resumeTargets:(NSSet*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*, NSInteger, BOOL
// Ret value: void (None)
JSBool JSB_CCScheduler_scheduleUpdateForTarget_priority_paused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; JSBool arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real scheduleUpdateForTarget:arg0 priority:(NSInteger)arg1 paused:(BOOL)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCScheduler_setTimeScale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real setTimeScale:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSB_CCScheduler_timeScale(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTime ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real timeScale ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCScheduler_unscheduleAll(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAll ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCScheduler_unscheduleAllForTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAllForTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSB_CCScheduler_unscheduleAllWithMinPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAllWithMinPriority:(NSInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSObject*
// Ret value: void (None)
JSBool JSB_CCScheduler_unscheduleBlockForKey_target_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; id arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleBlockForKey:(NSString*)arg0 target:arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCScheduler_unscheduleUpdateForTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleUpdateForTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCScheduler_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCScheduler_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCScheduler_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCScheduler_class->name = name;
	JSB_CCScheduler_class->addProperty = JS_PropertyStub;
	JSB_CCScheduler_class->delProperty = JS_PropertyStub;
	JSB_CCScheduler_class->getProperty = JS_PropertyStub;
	JSB_CCScheduler_class->setProperty = JS_StrictPropertyStub;
	JSB_CCScheduler_class->enumerate = JS_EnumerateStub;
	JSB_CCScheduler_class->resolve = JS_ResolveStub;
	JSB_CCScheduler_class->convert = JS_ConvertStub;
	JSB_CCScheduler_class->finalize = JSB_CCScheduler_finalize;
	JSB_CCScheduler_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("isPaused", JSB_CCScheduler_isPaused, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("isTargetPaused", JSB_CCScheduler_isTargetPaused_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseAllTargets", JSB_CCScheduler_pauseAllTargets, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseAllTargetsWithMinPriority", JSB_CCScheduler_pauseAllTargetsWithMinPriority_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseTarget", JSB_CCScheduler_pauseTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resumeTarget", JSB_CCScheduler_resumeTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resumeTargets", JSB_CCScheduler_resumeTargets_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("scheduleCallbackForTarget", JSB_CCScheduler_scheduleBlockForKey_target_interval_repeat_delay_paused_block_, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdateForTarget", JSB_CCScheduler_scheduleUpdateForTarget_priority_paused_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTimeScale", JSB_CCScheduler_setTimeScale_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTimeScale", JSB_CCScheduler_timeScale, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllCallbacks", JSB_CCScheduler_unscheduleAll, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllCallbacksForTarget", JSB_CCScheduler_unscheduleAllForTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllWithMinPriority", JSB_CCScheduler_unscheduleAllWithMinPriority_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleBlockForKeyTarget", JSB_CCScheduler_unscheduleBlockForKey_target_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("unscheduleUpdateForTarget", JSB_CCScheduler_unscheduleUpdateForTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_CCScheduler_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCScheduler_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCScheduler_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCScheduler_class, JSB_CCScheduler_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCScheduler

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCScheduler_class, JSB_CCScheduler_object, NULL);
	JSB_CCScheduler *proxy = [[JSB_CCScheduler alloc] initWithJSObject:jsobj class:[CCScheduler class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEasePolynomial
 */
#pragma mark - CCEasePolynomial

JSClass* JSB_CCEasePolynomial_class = NULL;
JSObject* JSB_CCEasePolynomial_object = NULL;
// Constructor
JSBool JSB_CCEasePolynomial_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEasePolynomial createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEasePolynomial_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEasePolynomial)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEasePolynomial_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEasePolynomial *proxy = [[JSB_CCEasePolynomial alloc] initWithJSObject:obj class:[CCEasePolynomial class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCEasePolynomial_polynomialOrder(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCEasePolynomial *real = (CCEasePolynomial*) [proxy realObj];
	ret_val = [real polynomialOrder ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCEasePolynomial_setPolynomialOrder_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEasePolynomial *real = (CCEasePolynomial*) [proxy realObj];
	[real setPolynomialOrder:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEasePolynomial* (o)
JSBool JSB_CCEasePolynomial_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEasePolynomial* ret_val;

	ret_val = [CCEasePolynomial actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEasePolynomial_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEasePolynomial_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEasePolynomial_class->name = name;
	JSB_CCEasePolynomial_class->addProperty = JS_PropertyStub;
	JSB_CCEasePolynomial_class->delProperty = JS_PropertyStub;
	JSB_CCEasePolynomial_class->getProperty = JS_PropertyStub;
	JSB_CCEasePolynomial_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEasePolynomial_class->enumerate = JS_EnumerateStub;
	JSB_CCEasePolynomial_class->resolve = JS_ResolveStub;
	JSB_CCEasePolynomial_class->convert = JS_ConvertStub;
	JSB_CCEasePolynomial_class->finalize = JSB_CCEasePolynomial_finalize;
	JSB_CCEasePolynomial_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getPolynomialOrder", JSB_CCEasePolynomial_polynomialOrder, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPolynomialOrder", JSB_CCEasePolynomial_setPolynomialOrder_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEasePolynomial_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEasePolynomial_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEasePolynomial_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEasePolynomial_class, JSB_CCEasePolynomial_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEasePolynomial

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEasePolynomial_class, JSB_CCEasePolynomial_object, NULL);
	JSB_CCEasePolynomial *proxy = [[JSB_CCEasePolynomial alloc] initWithJSObject:jsobj class:[CCEasePolynomial class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEasePolynomialInOut
 */
#pragma mark - CCEasePolynomialInOut

JSClass* JSB_CCEasePolynomialInOut_class = NULL;
JSObject* JSB_CCEasePolynomialInOut_object = NULL;
// Constructor
JSBool JSB_CCEasePolynomialInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEasePolynomialInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEasePolynomialInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEasePolynomialInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEasePolynomialInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEasePolynomialInOut *proxy = [[JSB_CCEasePolynomialInOut alloc] initWithJSObject:obj class:[CCEasePolynomialInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEasePolynomialInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEasePolynomialInOut *real = (CCEasePolynomialInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEasePolynomialInOut* (o)
JSBool JSB_CCEasePolynomialInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEasePolynomialInOut* ret_val;

	ret_val = [CCEasePolynomialInOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEasePolynomialInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEasePolynomialInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEasePolynomialInOut_class->name = name;
	JSB_CCEasePolynomialInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEasePolynomialInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEasePolynomialInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEasePolynomialInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEasePolynomialInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEasePolynomialInOut_class->resolve = JS_ResolveStub;
	JSB_CCEasePolynomialInOut_class->convert = JS_ConvertStub;
	JSB_CCEasePolynomialInOut_class->finalize = JSB_CCEasePolynomialInOut_finalize;
	JSB_CCEasePolynomialInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEasePolynomialInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEasePolynomialInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEasePolynomialInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEasePolynomialInOut_object = JS_InitClass(cx, globalObj, JSB_CCEasePolynomial_object, JSB_CCEasePolynomialInOut_class, JSB_CCEasePolynomialInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEasePolynomialInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEasePolynomialInOut_class, JSB_CCEasePolynomialInOut_object, NULL);
	JSB_CCEasePolynomialInOut *proxy = [[JSB_CCEasePolynomialInOut alloc] initWithJSObject:jsobj class:[CCEasePolynomialInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFollow
 */
#pragma mark - CCFollow

JSClass* JSB_CCFollow_class = NULL;
JSObject* JSB_CCFollow_object = NULL;
// Constructor
JSBool JSB_CCFollow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFollow createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFollow_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFollow)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFollow_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFollow *proxy = [[JSB_CCFollow alloc] initWithJSObject:obj class:[CCFollow class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*, CGRect
// Ret value: CCFollow* (o)
JSBool JSB_CCFollow_actionWithTarget_worldBoundary__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFollow* ret_val;

	if( argc == 1 ) {
		ret_val = [CCFollow actionWithTarget:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCFollow actionWithTarget:arg0 worldBoundary:(CGRect)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCFollow_boundarySet(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCFollow *real = (CCFollow*) [proxy realObj];
	ret_val = [real boundarySet ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: None (None)
JSBool JSB_CCFollow_initWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFollow *real = [(CCFollow*)[proxy.klass alloc] initWithTarget:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCNode*, CGRect
// Ret value: None (None)
JSBool JSB_CCFollow_initWithTarget_worldBoundary_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFollow *real = [(CCFollow*)[proxy.klass alloc] initWithTarget:arg0 worldBoundary:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCFollow_setBoundarySet_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFollow *real = (CCFollow*) [proxy realObj];
	[real setBoundarySet:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCFollow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFollow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFollow_class->name = name;
	JSB_CCFollow_class->addProperty = JS_PropertyStub;
	JSB_CCFollow_class->delProperty = JS_PropertyStub;
	JSB_CCFollow_class->getProperty = JS_PropertyStub;
	JSB_CCFollow_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFollow_class->enumerate = JS_EnumerateStub;
	JSB_CCFollow_class->resolve = JS_ResolveStub;
	JSB_CCFollow_class->convert = JS_ConvertStub;
	JSB_CCFollow_class->finalize = JSB_CCFollow_finalize;
	JSB_CCFollow_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBoundarySet", JSB_CCFollow_boundarySet, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTarget", JSB_CCFollow_initWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTargetWorldBoundary", JSB_CCFollow_initWithTarget_worldBoundary_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBoundarySet", JSB_CCFollow_setBoundarySet_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFollow_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFollow_actionWithTarget_worldBoundary__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFollow_object = JS_InitClass(cx, globalObj, JSB_CCAction_object, JSB_CCFollow_class, JSB_CCFollow_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFollow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFollow_class, JSB_CCFollow_object, NULL);
	JSB_CCFollow *proxy = [[JSB_CCFollow alloc] initWithJSObject:jsobj class:[CCFollow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCOrbitCamera
 */
#pragma mark - CCOrbitCamera

JSClass* JSB_CCOrbitCamera_class = NULL;
JSObject* JSB_CCOrbitCamera_object = NULL;
// Constructor
JSBool JSB_CCOrbitCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCOrbitCamera createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCOrbitCamera_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCOrbitCamera)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCOrbitCamera_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCOrbitCamera *proxy = [[JSB_CCOrbitCamera alloc] initWithJSObject:obj class:[CCOrbitCamera class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: float, float, float, float, float, float, float
// Ret value: CCOrbitCamera* (o)
JSBool JSB_CCOrbitCamera_actionWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 7, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; double arg6; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCOrbitCamera* ret_val;

	ret_val = [CCOrbitCamera actionWithDuration:(float)arg0 radius:(float)arg1 deltaRadius:(float)arg2 angleZ:(float)arg3 deltaAngleZ:(float)arg4 angleX:(float)arg5 deltaAngleX:(float)arg6  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: float, float, float, float, float, float, float
// Ret value: None (None)
JSBool JSB_CCOrbitCamera_initWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 7, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; double arg6; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCOrbitCamera *real = [(CCOrbitCamera*)[proxy.klass alloc] initWithDuration:(float)arg0 radius:(float)arg1 deltaRadius:(float)arg2 angleZ:(float)arg3 deltaAngleZ:(float)arg4 angleX:(float)arg5 deltaAngleX:(float)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCOrbitCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCOrbitCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCOrbitCamera_class->name = name;
	JSB_CCOrbitCamera_class->addProperty = JS_PropertyStub;
	JSB_CCOrbitCamera_class->delProperty = JS_PropertyStub;
	JSB_CCOrbitCamera_class->getProperty = JS_PropertyStub;
	JSB_CCOrbitCamera_class->setProperty = JS_StrictPropertyStub;
	JSB_CCOrbitCamera_class->enumerate = JS_EnumerateStub;
	JSB_CCOrbitCamera_class->resolve = JS_ResolveStub;
	JSB_CCOrbitCamera_class->convert = JS_ConvertStub;
	JSB_CCOrbitCamera_class->finalize = JSB_CCOrbitCamera_finalize;
	JSB_CCOrbitCamera_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRadiusDeltaRadiusAngleZDeltaAngleZAngleXDeltaAngleX", JSB_CCOrbitCamera_initWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX_, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCOrbitCamera_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCOrbitCamera_actionWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX__static, 7, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCOrbitCamera_object = JS_InitClass(cx, globalObj, JSB_CCActionCamera_object, JSB_CCOrbitCamera_class, JSB_CCOrbitCamera_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCOrbitCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCOrbitCamera_class, JSB_CCOrbitCamera_object, NULL);
	JSB_CCOrbitCamera *proxy = [[JSB_CCOrbitCamera alloc] initWithJSObject:jsobj class:[CCOrbitCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimationFrame
 */
#pragma mark - CCAnimationFrame

JSClass* JSB_CCAnimationFrame_class = NULL;
JSObject* JSB_CCAnimationFrame_object = NULL;
// Constructor
JSBool JSB_CCAnimationFrame_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAnimationFrame createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAnimationFrame_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAnimationFrame)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAnimationFrame_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAnimationFrame *proxy = [[JSB_CCAnimationFrame alloc] initWithJSObject:obj class:[CCAnimationFrame class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAnimationFrame_delayUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	ret_val = [real delayUnits ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*, float, NSDictionary*
// Ret value: None (None)
JSBool JSB_CCAnimationFrame_initWithSpriteFrame_delayUnits_userInfo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; NSDictionary* arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationFrame *real = [(CCAnimationFrame*)[proxy.klass alloc] initWithSpriteFrame:arg0 delayUnits:(float)arg1 userInfo:(NSDictionary*)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCAnimationFrame_setDelayUnits_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	[real setDelayUnits:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCAnimationFrame_setSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	[real setSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSDictionary*
// Ret value: void (None)
JSBool JSB_CCAnimationFrame_setUserInfo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	[real setUserInfo:(NSDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrame* (o)
JSBool JSB_CCAnimationFrame_spriteFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSpriteFrame* ret_val;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	ret_val = [real spriteFrame ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSDictionary* (dict)
JSBool JSB_CCAnimationFrame_userInfo(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSDictionary* ret_val;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	ret_val = [real userInfo ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

void JSB_CCAnimationFrame_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAnimationFrame_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAnimationFrame_class->name = name;
	JSB_CCAnimationFrame_class->addProperty = JS_PropertyStub;
	JSB_CCAnimationFrame_class->delProperty = JS_PropertyStub;
	JSB_CCAnimationFrame_class->getProperty = JS_PropertyStub;
	JSB_CCAnimationFrame_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAnimationFrame_class->enumerate = JS_EnumerateStub;
	JSB_CCAnimationFrame_class->resolve = JS_ResolveStub;
	JSB_CCAnimationFrame_class->convert = JS_ConvertStub;
	JSB_CCAnimationFrame_class->finalize = JSB_CCAnimationFrame_finalize;
	JSB_CCAnimationFrame_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDelayUnits", JSB_CCAnimationFrame_delayUnits, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrameDelayUnitsUserInfo", JSB_CCAnimationFrame_initWithSpriteFrame_delayUnits_userInfo_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDelayUnits", JSB_CCAnimationFrame_setDelayUnits_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSpriteFrame", JSB_CCAnimationFrame_setSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUserInfo", JSB_CCAnimationFrame_setUserInfo_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpriteFrame", JSB_CCAnimationFrame_spriteFrame, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getUserInfo", JSB_CCAnimationFrame_userInfo, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAnimationFrame_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCAnimationFrame_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCAnimationFrame_class, JSB_CCAnimationFrame_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAnimationFrame

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAnimationFrame_class, JSB_CCAnimationFrame_object, NULL);
	JSB_CCAnimationFrame *proxy = [[JSB_CCAnimationFrame alloc] initWithJSObject:jsobj class:[CCAnimationFrame class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInL
 */
#pragma mark - CCTransitionSlideInL

JSClass* JSB_CCTransitionSlideInL_class = NULL;
JSObject* JSB_CCTransitionSlideInL_object = NULL;
// Constructor
JSBool JSB_CCTransitionSlideInL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSlideInL createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSlideInL_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSlideInL)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSlideInL_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSlideInL *proxy = [[JSB_CCTransitionSlideInL alloc] initWithJSObject:obj class:[CCTransitionSlideInL class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionSlideInL_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	ret_val = [real action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionSlideInL_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionSlideInL_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInL* (o)
JSBool JSB_CCTransitionSlideInL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSlideInL* ret_val;

	ret_val = [CCTransitionSlideInL transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInL* (o)
JSBool JSB_CCTransitionSlideInL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSlideInL* ret_val;

	ret_val = [CCTransitionSlideInL node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSlideInL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSlideInL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSlideInL_class->name = name;
	JSB_CCTransitionSlideInL_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInL_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInL_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInL_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSlideInL_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSlideInL_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSlideInL_class->convert = JS_ConvertStub;
	JSB_CCTransitionSlideInL_class->finalize = JSB_CCTransitionSlideInL_finalize;
	JSB_CCTransitionSlideInL_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSB_CCTransitionSlideInL_action, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initScenes", JSB_CCTransitionSlideInL_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionSlideInL_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSlideInL_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSlideInL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSlideInL_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSlideInL_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionSlideInL_class, JSB_CCTransitionSlideInL_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSlideInL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSlideInL_class, JSB_CCTransitionSlideInL_object, NULL);
	JSB_CCTransitionSlideInL *proxy = [[JSB_CCTransitionSlideInL alloc] initWithJSObject:jsobj class:[CCTransitionSlideInL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInB
 */
#pragma mark - CCTransitionSlideInB

JSClass* JSB_CCTransitionSlideInB_class = NULL;
JSObject* JSB_CCTransitionSlideInB_object = NULL;
// Constructor
JSBool JSB_CCTransitionSlideInB_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSlideInB createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSlideInB_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSlideInB)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSlideInB_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSlideInB *proxy = [[JSB_CCTransitionSlideInB alloc] initWithJSObject:obj class:[CCTransitionSlideInB class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionSlideInB_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionSlideInB *real = (CCTransitionSlideInB*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInB* (o)
JSBool JSB_CCTransitionSlideInB_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSlideInB* ret_val;

	ret_val = [CCTransitionSlideInB transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInB* (o)
JSBool JSB_CCTransitionSlideInB_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSlideInB* ret_val;

	ret_val = [CCTransitionSlideInB node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSlideInB_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSlideInB_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSlideInB_class->name = name;
	JSB_CCTransitionSlideInB_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInB_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInB_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInB_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSlideInB_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSlideInB_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSlideInB_class->convert = JS_ConvertStub;
	JSB_CCTransitionSlideInB_class->finalize = JSB_CCTransitionSlideInB_finalize;
	JSB_CCTransitionSlideInB_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionSlideInB_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSlideInB_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSlideInB_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSlideInB_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSlideInB_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSlideInL_object, JSB_CCTransitionSlideInB_class, JSB_CCTransitionSlideInB_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSlideInB

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSlideInB_class, JSB_CCTransitionSlideInB_object, NULL);
	JSB_CCTransitionSlideInB *proxy = [[JSB_CCTransitionSlideInB alloc] initWithJSObject:jsobj class:[CCTransitionSlideInB class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTimer
 */
#pragma mark - CCTimer

JSClass* JSB_CCTimer_class = NULL;
JSObject* JSB_CCTimer_object = NULL;
// Constructor
JSBool JSB_CCTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTimer createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTimer_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTimer)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTimer_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTimer *proxy = [[JSB_CCTimer alloc] initWithJSObject:obj class:[CCTimer class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSB_CCTimer_interval(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccTime ret_val;

	CCTimer *real = (CCTimer*) [proxy realObj];
	ret_val = [real interval ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCTimer_setInterval_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTimer *real = (CCTimer*) [proxy realObj];
	[real setInterval:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCTimer_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTimer *real = (CCTimer*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTimer_class->name = name;
	JSB_CCTimer_class->addProperty = JS_PropertyStub;
	JSB_CCTimer_class->delProperty = JS_PropertyStub;
	JSB_CCTimer_class->getProperty = JS_PropertyStub;
	JSB_CCTimer_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTimer_class->enumerate = JS_EnumerateStub;
	JSB_CCTimer_class->resolve = JS_ResolveStub;
	JSB_CCTimer_class->convert = JS_ConvertStub;
	JSB_CCTimer_class->finalize = JSB_CCTimer_finalize;
	JSB_CCTimer_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getInterval", JSB_CCTimer_interval, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setInterval", JSB_CCTimer_setInterval_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("update", JSB_CCTimer_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTimer_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCTimer_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTimer_class, JSB_CCTimer_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTimer_class, JSB_CCTimer_object, NULL);
	JSB_CCTimer *proxy = [[JSB_CCTimer alloc] initWithJSObject:jsobj class:[CCTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTimerBlock
 */
#pragma mark - CCTimerBlock

JSClass* JSB_CCTimerBlock_class = NULL;
JSObject* JSB_CCTimerBlock_object = NULL;
// Constructor
JSBool JSB_CCTimerBlock_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTimerBlock createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTimerBlock_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTimerBlock)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTimerBlock_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTimerBlock *proxy = [[JSB_CCTimerBlock alloc] initWithJSObject:obj class:[CCTimerBlock class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTimerBlock_key(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTimerBlock *real = (CCTimerBlock*) [proxy realObj];
	ret_val = [real key ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSObject* (o)
JSBool JSB_CCTimerBlock_target(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSObject* ret_val;

	CCTimerBlock *real = (CCTimerBlock*) [proxy realObj];
	ret_val = [real target ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTimerBlock_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTimerBlock_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTimerBlock_class->name = name;
	JSB_CCTimerBlock_class->addProperty = JS_PropertyStub;
	JSB_CCTimerBlock_class->delProperty = JS_PropertyStub;
	JSB_CCTimerBlock_class->getProperty = JS_PropertyStub;
	JSB_CCTimerBlock_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTimerBlock_class->enumerate = JS_EnumerateStub;
	JSB_CCTimerBlock_class->resolve = JS_ResolveStub;
	JSB_CCTimerBlock_class->convert = JS_ConvertStub;
	JSB_CCTimerBlock_class->finalize = JSB_CCTimerBlock_finalize;
	JSB_CCTimerBlock_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getKey", JSB_CCTimerBlock_key, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTarget", JSB_CCTimerBlock_target, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTimerBlock_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCTimerBlock_object = JS_InitClass(cx, globalObj, JSB_CCTimer_object, JSB_CCTimerBlock_class, JSB_CCTimerBlock_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTimerBlock

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTimerBlock_class, JSB_CCTimerBlock_object, NULL);
	JSB_CCTimerBlock *proxy = [[JSB_CCTimerBlock alloc] initWithJSObject:jsobj class:[CCTimerBlock class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParallaxNode
 */
#pragma mark - CCParallaxNode

JSClass* JSB_CCParallaxNode_class = NULL;
JSObject* JSB_CCParallaxNode_object = NULL;
// Constructor
JSBool JSB_CCParallaxNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParallaxNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParallaxNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParallaxNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParallaxNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParallaxNode *proxy = [[JSB_CCParallaxNode alloc] initWithJSObject:obj class:[CCParallaxNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger, CGPoint, CGPoint
// Ret value: void (None)
JSBool JSB_CCParallaxNode_addChild_z_parallaxRatio_positionOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; CGPoint arg2; CGPoint arg3; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCParallaxNode *real = (CCParallaxNode*) [proxy realObj];
	[real addChild:arg0 z:(NSInteger)arg1 parallaxRatio:(CGPoint)arg2 positionOffset:(CGPoint)arg3  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParallaxNode* (o)
JSBool JSB_CCParallaxNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParallaxNode* ret_val;

	ret_val = [CCParallaxNode node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParallaxNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParallaxNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParallaxNode_class->name = name;
	JSB_CCParallaxNode_class->addProperty = JS_PropertyStub;
	JSB_CCParallaxNode_class->delProperty = JS_PropertyStub;
	JSB_CCParallaxNode_class->getProperty = JS_PropertyStub;
	JSB_CCParallaxNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParallaxNode_class->enumerate = JS_EnumerateStub;
	JSB_CCParallaxNode_class->resolve = JS_ResolveStub;
	JSB_CCParallaxNode_class->convert = JS_ConvertStub;
	JSB_CCParallaxNode_class->finalize = JSB_CCParallaxNode_finalize;
	JSB_CCParallaxNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChild", JSB_CCParallaxNode_addChild_z_parallaxRatio_positionOffset_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParallaxNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCParallaxNode_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParallaxNode_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCParallaxNode_class, JSB_CCParallaxNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParallaxNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParallaxNode_class, JSB_CCParallaxNode_object, NULL);
	JSB_CCParallaxNode *proxy = [[JSB_CCParallaxNode alloc] initWithJSObject:jsobj class:[CCParallaxNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressHorizontal
 */
#pragma mark - CCTransitionProgressHorizontal

JSClass* JSB_CCTransitionProgressHorizontal_class = NULL;
JSObject* JSB_CCTransitionProgressHorizontal_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressHorizontal_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressHorizontal createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressHorizontal_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressHorizontal)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressHorizontal_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressHorizontal *proxy = [[JSB_CCTransitionProgressHorizontal alloc] initWithJSObject:obj class:[CCTransitionProgressHorizontal class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressHorizontal *real = (CCTransitionProgressHorizontal*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressHorizontal* (o)
JSBool JSB_CCTransitionProgressHorizontal_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressHorizontal* ret_val;

	ret_val = [CCTransitionProgressHorizontal transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressHorizontal* (o)
JSBool JSB_CCTransitionProgressHorizontal_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressHorizontal* ret_val;

	ret_val = [CCTransitionProgressHorizontal node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressHorizontal_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressHorizontal_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressHorizontal_class->name = name;
	JSB_CCTransitionProgressHorizontal_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressHorizontal_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressHorizontal_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressHorizontal_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressHorizontal_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressHorizontal_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressHorizontal_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressHorizontal_class->finalize = JSB_CCTransitionProgressHorizontal_finalize;
	JSB_CCTransitionProgressHorizontal_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressHorizontal_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressHorizontal_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressHorizontal_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressHorizontal_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressHorizontal_class, JSB_CCTransitionProgressHorizontal_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressHorizontal

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressHorizontal_class, JSB_CCTransitionProgressHorizontal_object, NULL);
	JSB_CCTransitionProgressHorizontal *proxy = [[JSB_CCTransitionProgressHorizontal alloc] initWithJSObject:jsobj class:[CCTransitionProgressHorizontal class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRepeat
 */
#pragma mark - CCRepeat

JSClass* JSB_CCRepeat_class = NULL;
JSObject* JSB_CCRepeat_object = NULL;
// Constructor
JSBool JSB_CCRepeat_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRepeat createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRepeat_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRepeat)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRepeat_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRepeat *proxy = [[JSB_CCRepeat alloc] initWithJSObject:obj class:[CCRepeat class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, NSUInteger
// Ret value: CCRepeat* (o)
JSBool JSB_CCRepeat_actionWithAction_times__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRepeat* ret_val;

	ret_val = [CCRepeat actionWithAction:arg0 times:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCRepeat_initWithAction_times_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRepeat *real = [(CCRepeat*)[proxy.klass alloc] initWithAction:arg0 times:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSB_CCRepeat_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	CCRepeat *real = (CCRepeat*) [proxy realObj];
	ret_val = [real innerAction ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*
// Ret value: void (None)
JSBool JSB_CCRepeat_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRepeat *real = (CCRepeat*) [proxy realObj];
	[real setInnerAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCRepeat_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRepeat_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRepeat_class->name = name;
	JSB_CCRepeat_class->addProperty = JS_PropertyStub;
	JSB_CCRepeat_class->delProperty = JS_PropertyStub;
	JSB_CCRepeat_class->getProperty = JS_PropertyStub;
	JSB_CCRepeat_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRepeat_class->enumerate = JS_EnumerateStub;
	JSB_CCRepeat_class->resolve = JS_ResolveStub;
	JSB_CCRepeat_class->convert = JS_ConvertStub;
	JSB_CCRepeat_class->finalize = JSB_CCRepeat_finalize;
	JSB_CCRepeat_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionTimes", JSB_CCRepeat_initWithAction_times_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSB_CCRepeat_innerAction, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSB_CCRepeat_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRepeat_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRepeat_actionWithAction_times__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRepeat_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCRepeat_class, JSB_CCRepeat_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRepeat

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRepeat_class, JSB_CCRepeat_object, NULL);
	JSB_CCRepeat *proxy = [[JSB_CCRepeat alloc] initWithJSObject:jsobj class:[CCRepeat class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSnow
 */
#pragma mark - CCParticleSnow

JSClass* JSB_CCParticleSnow_class = NULL;
JSObject* JSB_CCParticleSnow_object = NULL;
// Constructor
JSBool JSB_CCParticleSnow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSnow createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSnow_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSnow)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSnow_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSnow *proxy = [[JSB_CCParticleSnow alloc] initWithJSObject:obj class:[CCParticleSnow class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleSnow_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSnow *real = [(CCParticleSnow*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSnow* (o)
JSBool JSB_CCParticleSnow_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSnow* (o)
JSBool JSB_CCParticleSnow_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSnow* (o)
JSBool JSB_CCParticleSnow_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleSnow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSnow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSnow_class->name = name;
	JSB_CCParticleSnow_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSnow_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSnow_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSnow_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSnow_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSnow_class->resolve = JS_ResolveStub;
	JSB_CCParticleSnow_class->convert = JS_ConvertStub;
	JSB_CCParticleSnow_class->finalize = JSB_CCParticleSnow_finalize;
	JSB_CCParticleSnow_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleSnow_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSnow_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleSnow_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleSnow_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleSnow_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSnow_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleSnow_class, JSB_CCParticleSnow_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSnow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSnow_class, JSB_CCParticleSnow_object, NULL);
	JSB_CCParticleSnow *proxy = [[JSB_CCParticleSnow alloc] initWithJSObject:jsobj class:[CCParticleSnow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShatteredTiles3D
 */
#pragma mark - CCShatteredTiles3D

JSClass* JSB_CCShatteredTiles3D_class = NULL;
JSObject* JSB_CCShatteredTiles3D_object = NULL;
// Constructor
JSBool JSB_CCShatteredTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShatteredTiles3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShatteredTiles3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShatteredTiles3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShatteredTiles3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShatteredTiles3D *proxy = [[JSB_CCShatteredTiles3D alloc] initWithJSObject:obj class:[CCShatteredTiles3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: CCShatteredTiles3D* (o)
JSBool JSB_CCShatteredTiles3D_actionWithDuration_size_range_shatterZ__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCShatteredTiles3D* ret_val;

	ret_val = [CCShatteredTiles3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shatterZ:(BOOL)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: None (None)
JSBool JSB_CCShatteredTiles3D_initWithDuration_size_range_shatterZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShatteredTiles3D *real = [(CCShatteredTiles3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shatterZ:(BOOL)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCShatteredTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShatteredTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShatteredTiles3D_class->name = name;
	JSB_CCShatteredTiles3D_class->addProperty = JS_PropertyStub;
	JSB_CCShatteredTiles3D_class->delProperty = JS_PropertyStub;
	JSB_CCShatteredTiles3D_class->getProperty = JS_PropertyStub;
	JSB_CCShatteredTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShatteredTiles3D_class->enumerate = JS_EnumerateStub;
	JSB_CCShatteredTiles3D_class->resolve = JS_ResolveStub;
	JSB_CCShatteredTiles3D_class->convert = JS_ConvertStub;
	JSB_CCShatteredTiles3D_class->finalize = JSB_CCShatteredTiles3D_finalize;
	JSB_CCShatteredTiles3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizeRangeShatterZ", JSB_CCShatteredTiles3D_initWithDuration_size_range_shatterZ_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShatteredTiles3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCShatteredTiles3D_actionWithDuration_size_range_shatterZ__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShatteredTiles3D_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCShatteredTiles3D_class, JSB_CCShatteredTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShatteredTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShatteredTiles3D_class, JSB_CCShatteredTiles3D_object, NULL);
	JSB_CCShatteredTiles3D *proxy = [[JSB_CCShatteredTiles3D alloc] initWithJSObject:jsobj class:[CCShatteredTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipY
 */
#pragma mark - CCTransitionFlipY

JSClass* JSB_CCTransitionFlipY_class = NULL;
JSObject* JSB_CCTransitionFlipY_object = NULL;
// Constructor
JSBool JSB_CCTransitionFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFlipY createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFlipY_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFlipY)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFlipY_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFlipY *proxy = [[JSB_CCTransitionFlipY alloc] initWithJSObject:obj class:[CCTransitionFlipY class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionFlipY_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionFlipY *real = [(CCTransitionFlipY*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipY* (o)
JSBool JSB_CCTransitionFlipY_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFlipY* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionFlipY transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionFlipY transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipY* (o)
JSBool JSB_CCTransitionFlipY_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFlipY* ret_val;

	ret_val = [CCTransitionFlipY node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFlipY_class->name = name;
	JSB_CCTransitionFlipY_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFlipY_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFlipY_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFlipY_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFlipY_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFlipY_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFlipY_class->convert = JS_ConvertStub;
	JSB_CCTransitionFlipY_class->finalize = JSB_CCTransitionFlipY_finalize;
	JSB_CCTransitionFlipY_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionFlipY_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFlipY_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFlipY_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFlipY_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFlipY_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionFlipY_class, JSB_CCTransitionFlipY_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFlipY_class, JSB_CCTransitionFlipY_object, NULL);
	JSB_CCTransitionFlipY *proxy = [[JSB_CCTransitionFlipY alloc] initWithJSObject:jsobj class:[CCTransitionFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipX
 */
#pragma mark - CCTransitionFlipX

JSClass* JSB_CCTransitionFlipX_class = NULL;
JSObject* JSB_CCTransitionFlipX_object = NULL;
// Constructor
JSBool JSB_CCTransitionFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFlipX createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFlipX_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFlipX)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFlipX_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFlipX *proxy = [[JSB_CCTransitionFlipX alloc] initWithJSObject:obj class:[CCTransitionFlipX class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionFlipX_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionFlipX *real = [(CCTransitionFlipX*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipX* (o)
JSBool JSB_CCTransitionFlipX_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFlipX* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionFlipX transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionFlipX transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipX* (o)
JSBool JSB_CCTransitionFlipX_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFlipX* ret_val;

	ret_val = [CCTransitionFlipX node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFlipX_class->name = name;
	JSB_CCTransitionFlipX_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFlipX_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFlipX_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFlipX_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFlipX_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFlipX_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFlipX_class->convert = JS_ConvertStub;
	JSB_CCTransitionFlipX_class->finalize = JSB_CCTransitionFlipX_finalize;
	JSB_CCTransitionFlipX_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionFlipX_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFlipX_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFlipX_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFlipX_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFlipX_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionFlipX_class, JSB_CCTransitionFlipX_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFlipX_class, JSB_CCTransitionFlipX_object, NULL);
	JSB_CCTransitionFlipX *proxy = [[JSB_CCTransitionFlipX alloc] initWithJSObject:jsobj class:[CCTransitionFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteFrame
 */
#pragma mark - CCSpriteFrame

JSClass* JSB_CCSpriteFrame_class = NULL;
JSObject* JSB_CCSpriteFrame_object = NULL;
// Constructor
JSBool JSB_CCSpriteFrame_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSpriteFrame createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSpriteFrame_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSpriteFrame)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSpriteFrame_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSpriteFrame *proxy = [[JSB_CCSpriteFrame alloc] initWithJSObject:obj class:[CCSpriteFrame class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL, CGPoint, CGSize
// Ret value: CCSpriteFrame* (o)
JSBool JSB_CCSpriteFrame_frameWithTexture_rectInPixels_rotated_offset_originalSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 5 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	}
	if (argc >= 5) {
		ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpriteFrame* ret_val;

	if( argc == 2 ) {
		ret_val = [CCSpriteFrame frameWithTexture:arg0 rect:(CGRect)arg1  ];
	}
	else if( argc == 5 ) {
		ret_val = [CCSpriteFrame frameWithTexture:arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, CGRect, BOOL, CGPoint, CGSize
// Ret value: CCSpriteFrame* (o)
JSBool JSB_CCSpriteFrame_frameWithTextureFilename_rectInPixels_rotated_offset_originalSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 5 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	}
	if (argc >= 5) {
		ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpriteFrame* ret_val;

	if( argc == 2 ) {
		ret_val = [CCSpriteFrame frameWithTextureFilename:(NSString*)arg0 rect:(CGRect)arg1  ];
	}
	else if( argc == 5 ) {
		ret_val = [CCSpriteFrame frameWithTextureFilename:(NSString*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: None (None)
JSBool JSB_CCSpriteFrame_initWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTexture:arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL, CGPoint, CGSize
// Ret value: None (None)
JSBool JSB_CCSpriteFrame_initWithTexture_rectInPixels_rotated_offset_originalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTexture:arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: None (None)
JSBool JSB_CCSpriteFrame_initWithTextureFilename_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTextureFilename:(NSString*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect, BOOL, CGPoint, CGSize
// Ret value: None (None)
JSBool JSB_CCSpriteFrame_initWithTextureFilename_rectInPixels_rotated_offset_originalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTextureFilename:(NSString*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCSpriteFrame_offset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real offset ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCSpriteFrame_offsetInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real offsetInPixels ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCSpriteFrame_originalSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real originalSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCSpriteFrame_originalSizeInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real originalSizeInPixels ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSB_CCSpriteFrame_rect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGRect ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rect ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGRect( cx, (CGRect)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSB_CCSpriteFrame_rectInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGRect ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rectInPixels ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGRect( cx, (CGRect)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCSpriteFrame_rotated(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rotated ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOffset:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setOffsetInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOffsetInPixels:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setOriginalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOriginalSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setOriginalSizeInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOriginalSizeInPixels:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRect:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setRectInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRectInPixels:(CGRect)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setRotated_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRotated:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCSpriteFrame_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCSpriteFrame_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCSpriteFrame_textureFilename(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real textureFilename ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_CCSpriteFrame_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSpriteFrame_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSpriteFrame_class->name = name;
	JSB_CCSpriteFrame_class->addProperty = JS_PropertyStub;
	JSB_CCSpriteFrame_class->delProperty = JS_PropertyStub;
	JSB_CCSpriteFrame_class->getProperty = JS_PropertyStub;
	JSB_CCSpriteFrame_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSpriteFrame_class->enumerate = JS_EnumerateStub;
	JSB_CCSpriteFrame_class->resolve = JS_ResolveStub;
	JSB_CCSpriteFrame_class->convert = JS_ConvertStub;
	JSB_CCSpriteFrame_class->finalize = JSB_CCSpriteFrame_finalize;
	JSB_CCSpriteFrame_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTextureRect", JSB_CCSpriteFrame_initWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureRectInPixelsRotatedOffsetOriginalSize", JSB_CCSpriteFrame_initWithTexture_rectInPixels_rotated_offset_originalSize_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureFilenameRect", JSB_CCSpriteFrame_initWithTextureFilename_rect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureFilenameRectInPixelsRotatedOffsetOriginalSize", JSB_CCSpriteFrame_initWithTextureFilename_rectInPixels_rotated_offset_originalSize_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOffset", JSB_CCSpriteFrame_offset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOffsetInPixels", JSB_CCSpriteFrame_offsetInPixels, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOriginalSize", JSB_CCSpriteFrame_originalSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOriginalSizeInPixels", JSB_CCSpriteFrame_originalSizeInPixels, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRect", JSB_CCSpriteFrame_rect, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRectInPixels", JSB_CCSpriteFrame_rectInPixels, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRotated", JSB_CCSpriteFrame_rotated, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOffset", JSB_CCSpriteFrame_setOffset_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOffsetInPixels", JSB_CCSpriteFrame_setOffsetInPixels_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOriginalSize", JSB_CCSpriteFrame_setOriginalSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOriginalSizeInPixels", JSB_CCSpriteFrame_setOriginalSizeInPixels_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRect", JSB_CCSpriteFrame_setRect_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRectInPixels", JSB_CCSpriteFrame_setRectInPixels_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRotated", JSB_CCSpriteFrame_setRotated_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCSpriteFrame_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCSpriteFrame_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTextureFilename", JSB_CCSpriteFrame_textureFilename, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSpriteFrame_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("createWithTexture", JSB_CCSpriteFrame_frameWithTexture_rectInPixels_rotated_offset_originalSize__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCSpriteFrame_frameWithTextureFilename_rectInPixels_rotated_offset_originalSize__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSpriteFrame_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCSpriteFrame_class, JSB_CCSpriteFrame_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSpriteFrame

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSpriteFrame_class, JSB_CCSpriteFrame_object, NULL);
	JSB_CCSpriteFrame *proxy = [[JSB_CCSpriteFrame alloc] initWithJSObject:jsobj class:[CCSpriteFrame class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSplitRows
 */
#pragma mark - CCSplitRows

JSClass* JSB_CCSplitRows_class = NULL;
JSObject* JSB_CCSplitRows_object = NULL;
// Constructor
JSBool JSB_CCSplitRows_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSplitRows createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSplitRows_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSplitRows)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSplitRows_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSplitRows *proxy = [[JSB_CCSplitRows alloc] initWithJSObject:obj class:[CCSplitRows class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: CCSplitRows* (o)
JSBool JSB_CCSplitRows_actionWithDuration_rows__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSplitRows* ret_val;

	ret_val = [CCSplitRows actionWithDuration:(ccTime)arg0 rows:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: None (None)
JSBool JSB_CCSplitRows_initWithDuration_rows_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSplitRows *real = [(CCSplitRows*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 rows:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCSplitRows_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSplitRows_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSplitRows_class->name = name;
	JSB_CCSplitRows_class->addProperty = JS_PropertyStub;
	JSB_CCSplitRows_class->delProperty = JS_PropertyStub;
	JSB_CCSplitRows_class->getProperty = JS_PropertyStub;
	JSB_CCSplitRows_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSplitRows_class->enumerate = JS_EnumerateStub;
	JSB_CCSplitRows_class->resolve = JS_ResolveStub;
	JSB_CCSplitRows_class->convert = JS_ConvertStub;
	JSB_CCSplitRows_class->finalize = JSB_CCSplitRows_finalize;
	JSB_CCSplitRows_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRows", JSB_CCSplitRows_initWithDuration_rows_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSplitRows_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSplitRows_actionWithDuration_rows__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSplitRows_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCSplitRows_class, JSB_CCSplitRows_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSplitRows

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSplitRows_class, JSB_CCSplitRows_object, NULL);
	JSB_CCSplitRows *proxy = [[JSB_CCSplitRows alloc] initWithJSObject:jsobj class:[CCSplitRows class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTextureCache
 */
#pragma mark - CCTextureCache

JSClass* JSB_CCTextureCache_class = NULL;
JSObject* JSB_CCTextureCache_object = NULL;
// Constructor
JSBool JSB_CCTextureCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTextureCache createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTextureCache_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTextureCache)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTextureCache_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTextureCache *proxy = [[JSB_CCTextureCache alloc] initWithJSObject:obj class:[CCTextureCache class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSB_CCTextureCache_addImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real addImage:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSB_CCTextureCache_addPVRImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real addPVRImage:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureCache_dumpCachedTextureInfo(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real dumpCachedTextureInfo ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureCache_purgeSharedTextureCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[CCTextureCache purgeSharedTextureCache ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureCache_removeAllTextures(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeAllTextures ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCTextureCache_removeTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTextureCache_removeTextureForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeTextureForKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureCache_removeUnusedTextures(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeUnusedTextures ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureCache* (o)
JSBool JSB_CCTextureCache_sharedTextureCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTextureCache* ret_val;

	ret_val = [CCTextureCache sharedTextureCache ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSB_CCTextureCache_textureForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real textureForKey:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTextureCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTextureCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTextureCache_class->name = name;
	JSB_CCTextureCache_class->addProperty = JS_PropertyStub;
	JSB_CCTextureCache_class->delProperty = JS_PropertyStub;
	JSB_CCTextureCache_class->getProperty = JS_PropertyStub;
	JSB_CCTextureCache_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTextureCache_class->enumerate = JS_EnumerateStub;
	JSB_CCTextureCache_class->resolve = JS_ResolveStub;
	JSB_CCTextureCache_class->convert = JS_ConvertStub;
	JSB_CCTextureCache_class->finalize = JSB_CCTextureCache_finalize;
	JSB_CCTextureCache_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addImage", JSB_CCTextureCache_addImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addPVRImage", JSB_CCTextureCache_addPVRImage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("dumpCachedTextureInfo", JSB_CCTextureCache_dumpCachedTextureInfo, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAllTextures", JSB_CCTextureCache_removeAllTextures, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeTexture", JSB_CCTextureCache_removeTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeTextureForKey", JSB_CCTextureCache_removeTextureForKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeUnusedTextures", JSB_CCTextureCache_removeUnusedTextures, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("textureForKey", JSB_CCTextureCache_textureForKey_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTextureCache_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedTextureCache", JSB_CCTextureCache_purgeSharedTextureCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSB_CCTextureCache_sharedTextureCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTextureCache_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTextureCache_class, JSB_CCTextureCache_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTextureCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTextureCache_class, JSB_CCTextureCache_object, NULL);
	JSB_CCTextureCache *proxy = [[JSB_CCTextureCache alloc] initWithJSObject:jsobj class:[CCTextureCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRipple3D
 */
#pragma mark - CCRipple3D

JSClass* JSB_CCRipple3D_class = NULL;
JSObject* JSB_CCRipple3D_object = NULL;
// Constructor
JSBool JSB_CCRipple3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRipple3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRipple3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRipple3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRipple3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRipple3D *proxy = [[JSB_CCRipple3D alloc] initWithJSObject:obj class:[CCRipple3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, float, NSInteger, float
// Ret value: CCRipple3D* (o)
JSBool JSB_CCRipple3D_actionWithDuration_size_position_radius_waves_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; double arg3; int32_t arg4; double arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRipple3D* ret_val;

	ret_val = [CCRipple3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 radius:(float)arg3 waves:(NSInteger)arg4 amplitude:(float)arg5  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCRipple3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCRipple3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, float, NSInteger, float
// Ret value: None (None)
JSBool JSB_CCRipple3D_initWithDuration_size_position_radius_waves_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; double arg3; int32_t arg4; double arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRipple3D *real = [(CCRipple3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 radius:(float)arg3 waves:(NSInteger)arg4 amplitude:(float)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCRipple3D_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real position ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCRipple3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCRipple3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCRipple3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRipple3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRipple3D_class->name = name;
	JSB_CCRipple3D_class->addProperty = JS_PropertyStub;
	JSB_CCRipple3D_class->delProperty = JS_PropertyStub;
	JSB_CCRipple3D_class->getProperty = JS_PropertyStub;
	JSB_CCRipple3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRipple3D_class->enumerate = JS_EnumerateStub;
	JSB_CCRipple3D_class->resolve = JS_ResolveStub;
	JSB_CCRipple3D_class->convert = JS_ConvertStub;
	JSB_CCRipple3D_class->finalize = JSB_CCRipple3D_finalize;
	JSB_CCRipple3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCRipple3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCRipple3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizePositionRadiusWavesAmplitude", JSB_CCRipple3D_initWithDuration_size_position_radius_waves_amplitude_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSB_CCRipple3D_position, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCRipple3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCRipple3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSB_CCRipple3D_setPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRipple3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRipple3D_actionWithDuration_size_position_radius_waves_amplitude__static, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRipple3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCRipple3D_class, JSB_CCRipple3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRipple3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRipple3D_class, JSB_CCRipple3D_object, NULL);
	JSB_CCRipple3D *proxy = [[JSB_CCRipple3D alloc] initWithJSObject:jsobj class:[CCRipple3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRotateBy
 */
#pragma mark - CCRotateBy

JSClass* JSB_CCRotateBy_class = NULL;
JSObject* JSB_CCRotateBy_object = NULL;
// Constructor
JSBool JSB_CCRotateBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRotateBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRotateBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRotateBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRotateBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRotateBy *proxy = [[JSB_CCRotateBy alloc] initWithJSObject:obj class:[CCRotateBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCRotateBy* (o)
JSBool JSB_CCRotateBy_actionWithDuration_angleX_angleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRotateBy* ret_val;

	if( argc == 2 ) {
		ret_val = [CCRotateBy actionWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCRotateBy actionWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSB_CCRotateBy_initWithDuration_angle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRotateBy *real = [(CCRotateBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSB_CCRotateBy_initWithDuration_angleX_angleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRotateBy *real = [(CCRotateBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCRotateBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRotateBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRotateBy_class->name = name;
	JSB_CCRotateBy_class->addProperty = JS_PropertyStub;
	JSB_CCRotateBy_class->delProperty = JS_PropertyStub;
	JSB_CCRotateBy_class->getProperty = JS_PropertyStub;
	JSB_CCRotateBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRotateBy_class->enumerate = JS_EnumerateStub;
	JSB_CCRotateBy_class->resolve = JS_ResolveStub;
	JSB_CCRotateBy_class->convert = JS_ConvertStub;
	JSB_CCRotateBy_class->finalize = JSB_CCRotateBy_finalize;
	JSB_CCRotateBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationAngle", JSB_CCRotateBy_initWithDuration_angle_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationAngleXAngleY", JSB_CCRotateBy_initWithDuration_angleX_angleY_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRotateBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRotateBy_actionWithDuration_angleX_angleY__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRotateBy_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCRotateBy_class, JSB_CCRotateBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRotateBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRotateBy_class, JSB_CCRotateBy_object, NULL);
	JSB_CCRotateBy *proxy = [[JSB_CCRotateBy alloc] initWithJSObject:jsobj class:[CCRotateBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeIn
 */
#pragma mark - CCFadeIn

JSClass* JSB_CCFadeIn_class = NULL;
JSObject* JSB_CCFadeIn_object = NULL;
// Constructor
JSBool JSB_CCFadeIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeIn *proxy = [[JSB_CCFadeIn alloc] initWithJSObject:obj class:[CCFadeIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCFadeIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFadeIn *real = (CCFadeIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFadeIn* (o)
JSBool JSB_CCFadeIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeIn* ret_val;

	ret_val = [CCFadeIn actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFadeIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeIn_class->name = name;
	JSB_CCFadeIn_class->addProperty = JS_PropertyStub;
	JSB_CCFadeIn_class->delProperty = JS_PropertyStub;
	JSB_CCFadeIn_class->getProperty = JS_PropertyStub;
	JSB_CCFadeIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeIn_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeIn_class->resolve = JS_ResolveStub;
	JSB_CCFadeIn_class->convert = JS_ConvertStub;
	JSB_CCFadeIn_class->finalize = JSB_CCFadeIn_finalize;
	JSB_CCFadeIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCFadeIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeIn_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCFadeIn_class, JSB_CCFadeIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeIn_class, JSB_CCFadeIn_object, NULL);
	JSB_CCFadeIn *proxy = [[JSB_CCFadeIn alloc] initWithJSObject:jsobj class:[CCFadeIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseIn
 */
#pragma mark - CCEaseIn

JSClass* JSB_CCEaseIn_class = NULL;
JSObject* JSB_CCEaseIn_object = NULL;
// Constructor
JSBool JSB_CCEaseIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseIn *proxy = [[JSB_CCEaseIn alloc] initWithJSObject:obj class:[CCEaseIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseIn *real = (CCEaseIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseIn* (o)
JSBool JSB_CCEaseIn_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseIn* ret_val;

	ret_val = [CCEaseIn actionWithAction:arg0 rate:(float)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseIn_class->name = name;
	JSB_CCEaseIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseIn_class->convert = JS_ConvertStub;
	JSB_CCEaseIn_class->finalize = JSB_CCEaseIn_finalize;
	JSB_CCEaseIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseIn_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseIn_object = JS_InitClass(cx, globalObj, JSB_CCEaseRateAction_object, JSB_CCEaseIn_class, JSB_CCEaseIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseIn_class, JSB_CCEaseIn_object, NULL);
	JSB_CCEaseIn *proxy = [[JSB_CCEaseIn alloc] initWithJSObject:jsobj class:[CCEaseIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXMapInfo
 */
#pragma mark - CCTMXMapInfo

JSClass* JSB_CCTMXMapInfo_class = NULL;
JSObject* JSB_CCTMXMapInfo_object = NULL;
// Constructor
JSBool JSB_CCTMXMapInfo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTMXMapInfo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTMXMapInfo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTMXMapInfo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTMXMapInfo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTMXMapInfo *proxy = [[JSB_CCTMXMapInfo alloc] initWithJSObject:obj class:[CCTMXMapInfo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTMXMapInfo_filename(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real filename ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXMapInfo* (o)
JSBool JSB_CCTMXMapInfo_formatWithTMXFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXMapInfo* ret_val;

	ret_val = [CCTMXMapInfo formatWithTMXFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCTMXMapInfo* (o)
JSBool JSB_CCTMXMapInfo_formatWithXML_resourcePath__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTMXMapInfo* ret_val;

	ret_val = [CCTMXMapInfo formatWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCTMXMapInfo_initWithTMXFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = [(CCTMXMapInfo*)[proxy.klass alloc] initWithTMXFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSB_CCTMXMapInfo_initWithXML_resourcePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = [(CCTMXMapInfo*)[proxy.klass alloc] initWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCTMXMapInfo_layers(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real layers ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXMapInfo_mapSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real mapSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCTMXMapInfo_objectGroups(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real objectGroups ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCTMXMapInfo_orientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real orientation ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXMapInfo_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real properties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTMXMapInfo_resources(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real resources ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setFilename:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setLayers_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setLayers:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setMapSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setMapSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setObjectGroups_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setObjectGroups:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setOrientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setOrientation:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setResources_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setResources:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setTileProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setTileProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setTileSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setTileSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCTMXMapInfo_setTilesets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setTilesets:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXMapInfo_tileProperties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real tileProperties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXMapInfo_tileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real tileSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCTMXMapInfo_tilesets(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real tilesets ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

void JSB_CCTMXMapInfo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTMXMapInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTMXMapInfo_class->name = name;
	JSB_CCTMXMapInfo_class->addProperty = JS_PropertyStub;
	JSB_CCTMXMapInfo_class->delProperty = JS_PropertyStub;
	JSB_CCTMXMapInfo_class->getProperty = JS_PropertyStub;
	JSB_CCTMXMapInfo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTMXMapInfo_class->enumerate = JS_EnumerateStub;
	JSB_CCTMXMapInfo_class->resolve = JS_ResolveStub;
	JSB_CCTMXMapInfo_class->convert = JS_ConvertStub;
	JSB_CCTMXMapInfo_class->finalize = JSB_CCTMXMapInfo_finalize;
	JSB_CCTMXMapInfo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getFilename", JSB_CCTMXMapInfo_filename, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTMXFile", JSB_CCTMXMapInfo_initWithTMXFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithXMLResourcePath", JSB_CCTMXMapInfo_initWithXML_resourcePath_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLayers", JSB_CCTMXMapInfo_layers, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMapSize", JSB_CCTMXMapInfo_mapSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getObjectGroups", JSB_CCTMXMapInfo_objectGroups, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOrientation", JSB_CCTMXMapInfo_orientation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSB_CCTMXMapInfo_properties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getResources", JSB_CCTMXMapInfo_resources, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFilename", JSB_CCTMXMapInfo_setFilename_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLayers", JSB_CCTMXMapInfo_setLayers_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMapSize", JSB_CCTMXMapInfo_setMapSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setObjectGroups", JSB_CCTMXMapInfo_setObjectGroups_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOrientation", JSB_CCTMXMapInfo_setOrientation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSB_CCTMXMapInfo_setProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setResources", JSB_CCTMXMapInfo_setResources_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTileProperties", JSB_CCTMXMapInfo_setTileProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTileSize", JSB_CCTMXMapInfo_setTileSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTilesets", JSB_CCTMXMapInfo_setTilesets_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileProperties", JSB_CCTMXMapInfo_tileProperties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTileSize", JSB_CCTMXMapInfo_tileSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTilesets", JSB_CCTMXMapInfo_tilesets, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTMXMapInfo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("formatWithTMXFile", JSB_CCTMXMapInfo_formatWithTMXFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("formatWithXMLResourcePath", JSB_CCTMXMapInfo_formatWithXML_resourcePath__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTMXMapInfo_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTMXMapInfo_class, JSB_CCTMXMapInfo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTMXMapInfo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTMXMapInfo_class, JSB_CCTMXMapInfo_object, NULL);
	JSB_CCTMXMapInfo *proxy = [[JSB_CCTMXMapInfo alloc] initWithJSObject:jsobj class:[CCTMXMapInfo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSmoke
 */
#pragma mark - CCParticleSmoke

JSClass* JSB_CCParticleSmoke_class = NULL;
JSObject* JSB_CCParticleSmoke_object = NULL;
// Constructor
JSBool JSB_CCParticleSmoke_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCParticleSmoke createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCParticleSmoke_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCParticleSmoke)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCParticleSmoke_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCParticleSmoke *proxy = [[JSB_CCParticleSmoke alloc] initWithJSObject:obj class:[CCParticleSmoke class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCParticleSmoke_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCParticleSmoke *real = [(CCParticleSmoke*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSmoke* (o)
JSBool JSB_CCParticleSmoke_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke particleWithFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSmoke* (o)
JSBool JSB_CCParticleSmoke_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke particleWithTotalParticles:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSmoke* (o)
JSBool JSB_CCParticleSmoke_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCParticleSmoke_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCParticleSmoke_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCParticleSmoke_class->name = name;
	JSB_CCParticleSmoke_class->addProperty = JS_PropertyStub;
	JSB_CCParticleSmoke_class->delProperty = JS_PropertyStub;
	JSB_CCParticleSmoke_class->getProperty = JS_PropertyStub;
	JSB_CCParticleSmoke_class->setProperty = JS_StrictPropertyStub;
	JSB_CCParticleSmoke_class->enumerate = JS_EnumerateStub;
	JSB_CCParticleSmoke_class->resolve = JS_ResolveStub;
	JSB_CCParticleSmoke_class->convert = JS_ConvertStub;
	JSB_CCParticleSmoke_class->finalize = JSB_CCParticleSmoke_finalize;
	JSB_CCParticleSmoke_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCParticleSmoke_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCParticleSmoke_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSB_CCParticleSmoke_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSB_CCParticleSmoke_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCParticleSmoke_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCParticleSmoke_object = JS_InitClass(cx, globalObj, JSB_CCParticleSystemQuad_object, JSB_CCParticleSmoke_class, JSB_CCParticleSmoke_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCParticleSmoke

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCParticleSmoke_class, JSB_CCParticleSmoke_object, NULL);
	JSB_CCParticleSmoke *proxy = [[JSB_CCParticleSmoke alloc] initWithJSObject:jsobj class:[CCParticleSmoke class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXLayerInfo
 */
#pragma mark - CCTMXLayerInfo

JSClass* JSB_CCTMXLayerInfo_class = NULL;
JSObject* JSB_CCTMXLayerInfo_object = NULL;
// Constructor
JSBool JSB_CCTMXLayerInfo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTMXLayerInfo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTMXLayerInfo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTMXLayerInfo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTMXLayerInfo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTMXLayerInfo *proxy = [[JSB_CCTMXLayerInfo alloc] initWithJSObject:obj class:[CCTMXLayerInfo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize (N/A)
JSBool JSB_CCTMXLayerInfo_layerSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real layerSize ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGSize( cx, (CGSize)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSB_CCTMXLayerInfo_maxGID(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real maxGID ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSB_CCTMXLayerInfo_minGID(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real minGID ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCTMXLayerInfo_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real name ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCTMXLayerInfo_offset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real offset ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned char (c)
JSBool JSB_CCTMXLayerInfo_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	unsigned char ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real opacity ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTMXLayerInfo_ownTiles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real ownTiles ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableDictionary* (dict)
JSBool JSB_CCTMXLayerInfo_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableDictionary* ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real properties ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSDictionary( cx, (NSDictionary*) ret_val ));

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setLayerSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setLayerSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setMaxGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setMaxGID:(unsigned int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setMinGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setMinGID:(unsigned int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOffset:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: unsigned char
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOpacity:(unsigned char)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setOwnTiles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOwnTiles:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableDictionary*
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSDictionary* arg0; 

	ok &= JSB_jsval_to_NSDictionary( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setProperties:(NSMutableDictionary*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCTMXLayerInfo_setVisible_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setVisible:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTMXLayerInfo_visible(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real visible ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

void JSB_CCTMXLayerInfo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTMXLayerInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTMXLayerInfo_class->name = name;
	JSB_CCTMXLayerInfo_class->addProperty = JS_PropertyStub;
	JSB_CCTMXLayerInfo_class->delProperty = JS_PropertyStub;
	JSB_CCTMXLayerInfo_class->getProperty = JS_PropertyStub;
	JSB_CCTMXLayerInfo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTMXLayerInfo_class->enumerate = JS_EnumerateStub;
	JSB_CCTMXLayerInfo_class->resolve = JS_ResolveStub;
	JSB_CCTMXLayerInfo_class->convert = JS_ConvertStub;
	JSB_CCTMXLayerInfo_class->finalize = JSB_CCTMXLayerInfo_finalize;
	JSB_CCTMXLayerInfo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getLayerSize", JSB_CCTMXLayerInfo_layerSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxGID", JSB_CCTMXLayerInfo_maxGID, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMinGID", JSB_CCTMXLayerInfo_minGID, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getName", JSB_CCTMXLayerInfo_name, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOffset", JSB_CCTMXLayerInfo_offset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSB_CCTMXLayerInfo_opacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getOwnTiles", JSB_CCTMXLayerInfo_ownTiles, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSB_CCTMXLayerInfo_properties, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLayerSize", JSB_CCTMXLayerInfo_setLayerSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMaxGID", JSB_CCTMXLayerInfo_setMaxGID_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMinGID", JSB_CCTMXLayerInfo_setMinGID_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setName", JSB_CCTMXLayerInfo_setName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOffset", JSB_CCTMXLayerInfo_setOffset_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSB_CCTMXLayerInfo_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setOwnTiles", JSB_CCTMXLayerInfo_setOwnTiles_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSB_CCTMXLayerInfo_setProperties_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVisible", JSB_CCTMXLayerInfo_setVisible_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVisible", JSB_CCTMXLayerInfo_visible, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTMXLayerInfo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCTMXLayerInfo_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTMXLayerInfo_class, JSB_CCTMXLayerInfo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTMXLayerInfo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTMXLayerInfo_class, JSB_CCTMXLayerInfo_object, NULL);
	JSB_CCTMXLayerInfo *proxy = [[JSB_CCTMXLayerInfo alloc] initWithJSObject:jsobj class:[CCTMXLayerInfo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipY
 */
#pragma mark - CCTransitionZoomFlipY

JSClass* JSB_CCTransitionZoomFlipY_class = NULL;
JSObject* JSB_CCTransitionZoomFlipY_object = NULL;
// Constructor
JSBool JSB_CCTransitionZoomFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionZoomFlipY createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionZoomFlipY_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionZoomFlipY)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionZoomFlipY_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionZoomFlipY *proxy = [[JSB_CCTransitionZoomFlipY alloc] initWithJSObject:obj class:[CCTransitionZoomFlipY class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionZoomFlipY_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionZoomFlipY *real = [(CCTransitionZoomFlipY*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipY* (o)
JSBool JSB_CCTransitionZoomFlipY_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionZoomFlipY* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionZoomFlipY transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionZoomFlipY transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipY* (o)
JSBool JSB_CCTransitionZoomFlipY_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionZoomFlipY* ret_val;

	ret_val = [CCTransitionZoomFlipY node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionZoomFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionZoomFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionZoomFlipY_class->name = name;
	JSB_CCTransitionZoomFlipY_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipY_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipY_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipY_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionZoomFlipY_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionZoomFlipY_class->resolve = JS_ResolveStub;
	JSB_CCTransitionZoomFlipY_class->convert = JS_ConvertStub;
	JSB_CCTransitionZoomFlipY_class->finalize = JSB_CCTransitionZoomFlipY_finalize;
	JSB_CCTransitionZoomFlipY_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionZoomFlipY_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionZoomFlipY_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionZoomFlipY_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionZoomFlipY_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionZoomFlipY_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionZoomFlipY_class, JSB_CCTransitionZoomFlipY_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionZoomFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionZoomFlipY_class, JSB_CCTransitionZoomFlipY_object, NULL);
	JSB_CCTransitionZoomFlipY *proxy = [[JSB_CCTransitionZoomFlipY alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEasePolynomialIn
 */
#pragma mark - CCEasePolynomialIn

JSClass* JSB_CCEasePolynomialIn_class = NULL;
JSObject* JSB_CCEasePolynomialIn_object = NULL;
// Constructor
JSBool JSB_CCEasePolynomialIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEasePolynomialIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEasePolynomialIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEasePolynomialIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEasePolynomialIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEasePolynomialIn *proxy = [[JSB_CCEasePolynomialIn alloc] initWithJSObject:obj class:[CCEasePolynomialIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEasePolynomialIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEasePolynomialIn *real = (CCEasePolynomialIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEasePolynomialIn* (o)
JSBool JSB_CCEasePolynomialIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEasePolynomialIn* ret_val;

	ret_val = [CCEasePolynomialIn actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEasePolynomialIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEasePolynomialIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEasePolynomialIn_class->name = name;
	JSB_CCEasePolynomialIn_class->addProperty = JS_PropertyStub;
	JSB_CCEasePolynomialIn_class->delProperty = JS_PropertyStub;
	JSB_CCEasePolynomialIn_class->getProperty = JS_PropertyStub;
	JSB_CCEasePolynomialIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEasePolynomialIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEasePolynomialIn_class->resolve = JS_ResolveStub;
	JSB_CCEasePolynomialIn_class->convert = JS_ConvertStub;
	JSB_CCEasePolynomialIn_class->finalize = JSB_CCEasePolynomialIn_finalize;
	JSB_CCEasePolynomialIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEasePolynomialIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEasePolynomialIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEasePolynomialIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEasePolynomialIn_object = JS_InitClass(cx, globalObj, JSB_CCEasePolynomial_object, JSB_CCEasePolynomialIn_class, JSB_CCEasePolynomialIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEasePolynomialIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEasePolynomialIn_class, JSB_CCEasePolynomialIn_object, NULL);
	JSB_CCEasePolynomialIn *proxy = [[JSB_CCEasePolynomialIn alloc] initWithJSObject:jsobj class:[CCEasePolynomialIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShuffleTiles
 */
#pragma mark - CCShuffleTiles

JSClass* JSB_CCShuffleTiles_class = NULL;
JSObject* JSB_CCShuffleTiles_object = NULL;
// Constructor
JSBool JSB_CCShuffleTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShuffleTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShuffleTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShuffleTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShuffleTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShuffleTiles *proxy = [[JSB_CCShuffleTiles alloc] initWithJSObject:obj class:[CCShuffleTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, unsigned int
// Ret value: CCShuffleTiles* (o)
JSBool JSB_CCShuffleTiles_actionWithDuration_size_seed__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCShuffleTiles* ret_val;

	ret_val = [CCShuffleTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 seed:(unsigned int)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, unsigned int
// Ret value: None (None)
JSBool JSB_CCShuffleTiles_initWithDuration_size_seed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShuffleTiles *real = [(CCShuffleTiles*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 seed:(unsigned int)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCShuffleTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShuffleTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShuffleTiles_class->name = name;
	JSB_CCShuffleTiles_class->addProperty = JS_PropertyStub;
	JSB_CCShuffleTiles_class->delProperty = JS_PropertyStub;
	JSB_CCShuffleTiles_class->getProperty = JS_PropertyStub;
	JSB_CCShuffleTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShuffleTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCShuffleTiles_class->resolve = JS_ResolveStub;
	JSB_CCShuffleTiles_class->convert = JS_ConvertStub;
	JSB_CCShuffleTiles_class->finalize = JSB_CCShuffleTiles_finalize;
	JSB_CCShuffleTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizeSeed", JSB_CCShuffleTiles_initWithDuration_size_seed_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShuffleTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCShuffleTiles_actionWithDuration_size_seed__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShuffleTiles_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCShuffleTiles_class, JSB_CCShuffleTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShuffleTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShuffleTiles_class, JSB_CCShuffleTiles_object, NULL);
	JSB_CCShuffleTiles *proxy = [[JSB_CCShuffleTiles alloc] initWithJSObject:jsobj class:[CCShuffleTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCReuseGrid
 */
#pragma mark - CCReuseGrid

JSClass* JSB_CCReuseGrid_class = NULL;
JSObject* JSB_CCReuseGrid_object = NULL;
// Constructor
JSBool JSB_CCReuseGrid_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCReuseGrid createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCReuseGrid_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCReuseGrid)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCReuseGrid_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCReuseGrid *proxy = [[JSB_CCReuseGrid alloc] initWithJSObject:obj class:[CCReuseGrid class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: int
// Ret value: CCReuseGrid* (o)
JSBool JSB_CCReuseGrid_actionWithTimes__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCReuseGrid* ret_val;

	ret_val = [CCReuseGrid actionWithTimes:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: int
// Ret value: None (None)
JSBool JSB_CCReuseGrid_initWithTimes_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCReuseGrid *real = [(CCReuseGrid*)[proxy.klass alloc] initWithTimes:(int)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCReuseGrid_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCReuseGrid_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCReuseGrid_class->name = name;
	JSB_CCReuseGrid_class->addProperty = JS_PropertyStub;
	JSB_CCReuseGrid_class->delProperty = JS_PropertyStub;
	JSB_CCReuseGrid_class->getProperty = JS_PropertyStub;
	JSB_CCReuseGrid_class->setProperty = JS_StrictPropertyStub;
	JSB_CCReuseGrid_class->enumerate = JS_EnumerateStub;
	JSB_CCReuseGrid_class->resolve = JS_ResolveStub;
	JSB_CCReuseGrid_class->convert = JS_ConvertStub;
	JSB_CCReuseGrid_class->finalize = JSB_CCReuseGrid_finalize;
	JSB_CCReuseGrid_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTimes", JSB_CCReuseGrid_initWithTimes_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCReuseGrid_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCReuseGrid_actionWithTimes__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCReuseGrid_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCReuseGrid_class, JSB_CCReuseGrid_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCReuseGrid

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCReuseGrid_class, JSB_CCReuseGrid_object, NULL);
	JSB_CCReuseGrid *proxy = [[JSB_CCReuseGrid alloc] initWithJSObject:jsobj class:[CCReuseGrid class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCConfiguration
 */
#pragma mark - CCConfiguration

JSClass* JSB_CCConfiguration_class = NULL;
JSObject* JSB_CCConfiguration_object = NULL;
// Constructor
JSBool JSB_CCConfiguration_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCConfiguration createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCConfiguration_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCConfiguration)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCConfiguration_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCConfiguration *proxy = [[JSB_CCConfiguration alloc] initWithJSObject:obj class:[CCConfiguration class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSB_CCConfiguration_OSVersion(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	unsigned int ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real OSVersion ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_checkForGLExtension_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real checkForGLExtension:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCConfiguration_dumpInfo(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	[real dumpInfo ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSB_CCConfiguration_maxTextureSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLint ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real maxTextureSize ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSB_CCConfiguration_maxTextureUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLint ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real maxTextureUnits ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSB_CCConfiguration_runningDevice(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSInteger ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real runningDevice ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCConfiguration* (o)
JSBool JSB_CCConfiguration_sharedConfiguration_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCConfiguration* ret_val;

	ret_val = [CCConfiguration sharedConfiguration ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_supportsBGRA8888(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsBGRA8888 ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_supportsDiscardFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsDiscardFramebuffer ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_supportsNPOT(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsNPOT ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_supportsPVRTC(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsPVRTC ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCConfiguration_supportsShareableVAO(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsShareableVAO ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

void JSB_CCConfiguration_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCConfiguration_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCConfiguration_class->name = name;
	JSB_CCConfiguration_class->addProperty = JS_PropertyStub;
	JSB_CCConfiguration_class->delProperty = JS_PropertyStub;
	JSB_CCConfiguration_class->getProperty = JS_PropertyStub;
	JSB_CCConfiguration_class->setProperty = JS_StrictPropertyStub;
	JSB_CCConfiguration_class->enumerate = JS_EnumerateStub;
	JSB_CCConfiguration_class->resolve = JS_ResolveStub;
	JSB_CCConfiguration_class->convert = JS_ConvertStub;
	JSB_CCConfiguration_class->finalize = JSB_CCConfiguration_finalize;
	JSB_CCConfiguration_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getOSVersion", JSB_CCConfiguration_OSVersion, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("checkForGLExtension", JSB_CCConfiguration_checkForGLExtension_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("dumpInfo", JSB_CCConfiguration_dumpInfo, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxTextureSize", JSB_CCConfiguration_maxTextureSize, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMaxTextureUnits", JSB_CCConfiguration_maxTextureUnits, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("runningDevice", JSB_CCConfiguration_runningDevice, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSupportsBGRA8888", JSB_CCConfiguration_supportsBGRA8888, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSupportsDiscardFramebuffer", JSB_CCConfiguration_supportsDiscardFramebuffer, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSupportsNPOT", JSB_CCConfiguration_supportsNPOT, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSupportsPVRTC", JSB_CCConfiguration_supportsPVRTC, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSupportsShareableVAO", JSB_CCConfiguration_supportsShareableVAO, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCConfiguration_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedConfiguration", JSB_CCConfiguration_sharedConfiguration_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCConfiguration_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCConfiguration_class, JSB_CCConfiguration_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCConfiguration

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCConfiguration_class, JSB_CCConfiguration_object, NULL);
	JSB_CCConfiguration *proxy = [[JSB_CCConfiguration alloc] initWithJSObject:jsobj class:[CCConfiguration class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineIn
 */
#pragma mark - CCEaseSineIn

JSClass* JSB_CCEaseSineIn_class = NULL;
JSObject* JSB_CCEaseSineIn_object = NULL;
// Constructor
JSBool JSB_CCEaseSineIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseSineIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseSineIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseSineIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseSineIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseSineIn *proxy = [[JSB_CCEaseSineIn alloc] initWithJSObject:obj class:[CCEaseSineIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseSineIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseSineIn *real = (CCEaseSineIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineIn* (o)
JSBool JSB_CCEaseSineIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseSineIn* ret_val;

	ret_val = [CCEaseSineIn actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseSineIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseSineIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseSineIn_class->name = name;
	JSB_CCEaseSineIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseSineIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseSineIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseSineIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseSineIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseSineIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseSineIn_class->convert = JS_ConvertStub;
	JSB_CCEaseSineIn_class->finalize = JSB_CCEaseSineIn_finalize;
	JSB_CCEaseSineIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseSineIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseSineIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseSineIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseSineIn_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseSineIn_class, JSB_CCEaseSineIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseSineIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseSineIn_class, JSB_CCEaseSineIn_object, NULL);
	JSB_CCEaseSineIn *proxy = [[JSB_CCEaseSineIn alloc] initWithJSObject:jsobj class:[CCEaseSineIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeBL
 */
#pragma mark - CCTransitionFadeBL

JSClass* JSB_CCTransitionFadeBL_class = NULL;
JSObject* JSB_CCTransitionFadeBL_object = NULL;
// Constructor
JSBool JSB_CCTransitionFadeBL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFadeBL createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFadeBL_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFadeBL)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFadeBL_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFadeBL *proxy = [[JSB_CCTransitionFadeBL alloc] initWithJSObject:obj class:[CCTransitionFadeBL class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionFadeBL_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionFadeBL *real = (CCTransitionFadeBL*) [proxy realObj];
	ret_val = [real actionWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeBL* (o)
JSBool JSB_CCTransitionFadeBL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFadeBL* ret_val;

	ret_val = [CCTransitionFadeBL transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeBL* (o)
JSBool JSB_CCTransitionFadeBL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFadeBL* ret_val;

	ret_val = [CCTransitionFadeBL node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFadeBL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFadeBL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFadeBL_class->name = name;
	JSB_CCTransitionFadeBL_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFadeBL_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFadeBL_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFadeBL_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFadeBL_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFadeBL_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFadeBL_class->convert = JS_ConvertStub;
	JSB_CCTransitionFadeBL_class->finalize = JSB_CCTransitionFadeBL_finalize;
	JSB_CCTransitionFadeBL_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSB_CCTransitionFadeBL_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFadeBL_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFadeBL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFadeBL_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFadeBL_object = JS_InitClass(cx, globalObj, JSB_CCTransitionFadeTR_object, JSB_CCTransitionFadeBL_class, JSB_CCTransitionFadeBL_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFadeBL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFadeBL_class, JSB_CCTransitionFadeBL_object, NULL);
	JSB_CCTransitionFadeBL *proxy = [[JSB_CCTransitionFadeBL alloc] initWithJSObject:jsobj class:[CCTransitionFadeBL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimate
 */
#pragma mark - CCAnimate

JSClass* JSB_CCAnimate_class = NULL;
JSObject* JSB_CCAnimate_object = NULL;
// Constructor
JSBool JSB_CCAnimate_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAnimate createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAnimate_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAnimate)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAnimate_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAnimate *proxy = [[JSB_CCAnimate alloc] initWithJSObject:obj class:[CCAnimate class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAnimation*
// Ret value: CCAnimate* (o)
JSBool JSB_CCAnimate_actionWithAnimation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAnimate* ret_val;

	ret_val = [CCAnimate actionWithAnimation:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAnimation* (o)
JSBool JSB_CCAnimate_animation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCAnimation* ret_val;

	CCAnimate *real = (CCAnimate*) [proxy realObj];
	ret_val = [real animation ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCAnimation*
// Ret value: None (None)
JSBool JSB_CCAnimate_initWithAnimation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimate *real = [(CCAnimate*)[proxy.klass alloc] initWithAnimation:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCAnimation*
// Ret value: void (None)
JSBool JSB_CCAnimate_setAnimation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimate *real = (CCAnimate*) [proxy realObj];
	[real setAnimation:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCAnimate_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAnimate_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAnimate_class->name = name;
	JSB_CCAnimate_class->addProperty = JS_PropertyStub;
	JSB_CCAnimate_class->delProperty = JS_PropertyStub;
	JSB_CCAnimate_class->getProperty = JS_PropertyStub;
	JSB_CCAnimate_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAnimate_class->enumerate = JS_EnumerateStub;
	JSB_CCAnimate_class->resolve = JS_ResolveStub;
	JSB_CCAnimate_class->convert = JS_ConvertStub;
	JSB_CCAnimate_class->finalize = JSB_CCAnimate_finalize;
	JSB_CCAnimate_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnimation", JSB_CCAnimate_animation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithAnimation", JSB_CCAnimate_initWithAnimation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAnimation", JSB_CCAnimate_setAnimation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAnimate_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCAnimate_actionWithAnimation__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAnimate_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCAnimate_class, JSB_CCAnimate_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAnimate

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAnimate_class, JSB_CCAnimate_object, NULL);
	JSB_CCAnimate *proxy = [[JSB_CCAnimate alloc] initWithJSObject:jsobj class:[CCAnimate class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPhysicsSprite
 */
#pragma mark - CCPhysicsSprite

JSClass* JSB_CCPhysicsSprite_class = NULL;
JSObject* JSB_CCPhysicsSprite_object = NULL;
// Constructor
JSBool JSB_CCPhysicsSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCPhysicsSprite createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCPhysicsSprite_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCPhysicsSprite)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCPhysicsSprite_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCPhysicsSprite *proxy = [[JSB_CCPhysicsSprite alloc] initWithJSObject:obj class:[CCPhysicsSprite class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody* (N/A)
JSBool JSB_CCPhysicsSprite_CPBody(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	cpBody* ret_val;

	CCPhysicsSprite *real = (CCPhysicsSprite*) [proxy realObj];
	ret_val = [real CPBody ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_opaque( cx, ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCPhysicsSprite_ignoreBodyRotation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCPhysicsSprite *real = (CCPhysicsSprite*) [proxy realObj];
	ret_val = [real ignoreBodyRotation ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: void (None)
JSBool JSB_CCPhysicsSprite_setCPBody_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; 

	ok &= JSB_jsval_to_opaque( cx, *argvp++, (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCPhysicsSprite *real = (CCPhysicsSprite*) [proxy realObj];
	[real setCPBody:(cpBody*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCPhysicsSprite_setIgnoreBodyRotation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCPhysicsSprite *real = (CCPhysicsSprite*) [proxy realObj];
	[real setIgnoreBodyRotation:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: CCPhysicsSprite* (o)
JSBool JSB_CCPhysicsSprite_spriteWithFile_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPhysicsSprite* ret_val;

	if( argc == 0 ) {
		ret_val = [CCPhysicsSprite node ];
	}
	else if( argc == 1 ) {
		ret_val = [CCPhysicsSprite spriteWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCPhysicsSprite spriteWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: CCPhysicsSprite* (o)
JSBool JSB_CCPhysicsSprite_spriteWithSpriteFrame__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPhysicsSprite* ret_val;

	ret_val = [CCPhysicsSprite spriteWithSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCPhysicsSprite* (o)
JSBool JSB_CCPhysicsSprite_spriteWithSpriteFrameName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPhysicsSprite* ret_val;

	ret_val = [CCPhysicsSprite spriteWithSpriteFrameName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: CCPhysicsSprite* (o)
JSBool JSB_CCPhysicsSprite_spriteWithTexture_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPhysicsSprite* ret_val;

	if( argc == 1 ) {
		ret_val = [CCPhysicsSprite spriteWithTexture:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCPhysicsSprite spriteWithTexture:arg0 rect:(CGRect)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCPhysicsSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCPhysicsSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCPhysicsSprite_class->name = name;
	JSB_CCPhysicsSprite_class->addProperty = JS_PropertyStub;
	JSB_CCPhysicsSprite_class->delProperty = JS_PropertyStub;
	JSB_CCPhysicsSprite_class->getProperty = JS_PropertyStub;
	JSB_CCPhysicsSprite_class->setProperty = JS_StrictPropertyStub;
	JSB_CCPhysicsSprite_class->enumerate = JS_EnumerateStub;
	JSB_CCPhysicsSprite_class->resolve = JS_ResolveStub;
	JSB_CCPhysicsSprite_class->convert = JS_ConvertStub;
	JSB_CCPhysicsSprite_class->finalize = JSB_CCPhysicsSprite_finalize;
	JSB_CCPhysicsSprite_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getCPBody", JSB_CCPhysicsSprite_CPBody, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getIgnoreBodyRotation", JSB_CCPhysicsSprite_ignoreBodyRotation, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("_setCPBody", JSB_CCPhysicsSprite_setCPBody_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setIgnoreBodyRotation", JSB_CCPhysicsSprite_setIgnoreBodyRotation_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCPhysicsSprite_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCPhysicsSprite_spriteWithFile_rect__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrame", JSB_CCPhysicsSprite_spriteWithSpriteFrame__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrameName", JSB_CCPhysicsSprite_spriteWithSpriteFrameName__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("createWithTexture", JSB_CCPhysicsSprite_spriteWithTexture_rect__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCPhysicsSprite_object = JS_InitClass(cx, globalObj, JSB_CCSprite_object, JSB_CCPhysicsSprite_class, JSB_CCPhysicsSprite_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCPhysicsSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCPhysicsSprite_class, JSB_CCPhysicsSprite_object, NULL);
	JSB_CCPhysicsSprite *proxy = [[JSB_CCPhysicsSprite alloc] initWithJSObject:jsobj class:[CCPhysicsSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCallBlockN
 */
#pragma mark - CCCallBlockN

JSClass* JSB_CCCallBlockN_class = NULL;
JSObject* JSB_CCCallBlockN_object = NULL;
// Constructor
JSBool JSB_CCCallBlockN_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCCallBlockN createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCCallBlockN_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCCallBlockN)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCCallBlockN_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCCallBlockN *proxy = [[JSB_CCCallBlockN alloc] initWithJSObject:obj class:[CCCallBlockN class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCCallBlockN_execute(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCCallBlockN *real = (CCCallBlockN*) [proxy realObj];
	[real execute ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: void (^)(CCNode *)
// Ret value: None (None)
JSBool JSB_CCCallBlockN_initWithBlock_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= JSB_jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCCallBlockN *real = [(CCCallBlockN*)[proxy.klass alloc] initWithBlock:(void (^)(CCNode *))arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCCallBlockN_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCCallBlockN_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCCallBlockN_class->name = name;
	JSB_CCCallBlockN_class->addProperty = JS_PropertyStub;
	JSB_CCCallBlockN_class->delProperty = JS_PropertyStub;
	JSB_CCCallBlockN_class->getProperty = JS_PropertyStub;
	JSB_CCCallBlockN_class->setProperty = JS_StrictPropertyStub;
	JSB_CCCallBlockN_class->enumerate = JS_EnumerateStub;
	JSB_CCCallBlockN_class->resolve = JS_ResolveStub;
	JSB_CCCallBlockN_class->convert = JS_ConvertStub;
	JSB_CCCallBlockN_class->finalize = JSB_CCCallBlockN_finalize;
	JSB_CCCallBlockN_class->flags = JSCLASS_HAS_RESERVED_SLOTS(2);

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("execute", JSB_CCCallBlockN_execute, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithBlock", JSB_CCCallBlockN_initWithBlock_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCCallBlockN_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCCallBlockN_actionWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCCallBlockN_object = JS_InitClass(cx, globalObj, JSB_CCActionInstant_object, JSB_CCCallBlockN_class, JSB_CCCallBlockN_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCCallBlockN

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCCallBlockN_class, JSB_CCCallBlockN_object, NULL);
	JSB_CCCallBlockN *proxy = [[JSB_CCCallBlockN alloc] initWithJSObject:jsobj class:[CCCallBlockN class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBezierBy
 */
#pragma mark - CCBezierBy

JSClass* JSB_CCBezierBy_class = NULL;
JSObject* JSB_CCBezierBy_object = NULL;
// Constructor
JSBool JSB_CCBezierBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCBezierBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCBezierBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCBezierBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCBezierBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCBezierBy *proxy = [[JSB_CCBezierBy alloc] initWithJSObject:obj class:[CCBezierBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

void JSB_CCBezierBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCBezierBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCBezierBy_class->name = name;
	JSB_CCBezierBy_class->addProperty = JS_PropertyStub;
	JSB_CCBezierBy_class->delProperty = JS_PropertyStub;
	JSB_CCBezierBy_class->getProperty = JS_PropertyStub;
	JSB_CCBezierBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCBezierBy_class->enumerate = JS_EnumerateStub;
	JSB_CCBezierBy_class->resolve = JS_ResolveStub;
	JSB_CCBezierBy_class->convert = JS_ConvertStub;
	JSB_CCBezierBy_class->finalize = JSB_CCBezierBy_finalize;
	JSB_CCBezierBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("ctor", JSB_CCBezierBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCBezierBy_actionWithDuration_bezier__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCBezierBy_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCBezierBy_class, JSB_CCBezierBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCBezierBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCBezierBy_class, JSB_CCBezierBy_object, NULL);
	JSB_CCBezierBy *proxy = [[JSB_CCBezierBy alloc] initWithJSObject:jsobj class:[CCBezierBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimation
 */
#pragma mark - CCAnimation

JSClass* JSB_CCAnimation_class = NULL;
JSObject* JSB_CCAnimation_object = NULL;
// Constructor
JSBool JSB_CCAnimation_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCAnimation createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCAnimation_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCAnimation)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCAnimation_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCAnimation *proxy = [[JSB_CCAnimation alloc] initWithJSObject:obj class:[CCAnimation class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSB_CCAnimation_addSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrame:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCAnimation_addSpriteFrameWithFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrameWithFilename:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: void (None)
JSBool JSB_CCAnimation_addSpriteFrameWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrameWithTexture:arg0 rect:(CGRect)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSArray*, float, NSUInteger
// Ret value: CCAnimation* (o)
JSBool JSB_CCAnimation_animationWithAnimationFrames_delayPerUnit_loops__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; uint32_t arg2; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAnimation* ret_val;

	if( argc == 0 ) {
		ret_val = [CCAnimation animation ];
	}
	else if( argc == 1 ) {
		ret_val = [CCAnimation animationWithSpriteFrames:(NSArray*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCAnimation animationWithSpriteFrames:(NSArray*)arg0 delay:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCAnimation animationWithAnimationFrames:(NSArray*)arg0 delayPerUnit:(float)arg1 loops:(NSUInteger)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAnimation_delayPerUnit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real delayPerUnit ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAnimation_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real duration ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSB_CCAnimation_frames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real frames ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSArray( cx, (NSArray*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSArray*, float, NSUInteger
// Ret value: None (None)
JSBool JSB_CCAnimation_initWithAnimationFrames_delayPerUnit_loops_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; uint32_t arg2; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithAnimationFrames:(NSArray*)arg0 delayPerUnit:(float)arg1 loops:(NSUInteger)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: None (None)
JSBool JSB_CCAnimation_initWithSpriteFrames_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithSpriteFrames:(NSArray*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSArray*, float
// Ret value: None (None)
JSBool JSB_CCAnimation_initWithSpriteFrames_delay_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithSpriteFrames:(NSArray*)arg0 delay:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCAnimation_loops(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real loops ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCAnimation_restoreOriginalFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real restoreOriginalFrame ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCAnimation_setDelayPerUnit_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setDelayPerUnit:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSB_CCAnimation_setFrames_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsval_to_NSArray( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setFrames:(NSMutableArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCAnimation_setLoops_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setLoops:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCAnimation_setRestoreOriginalFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setRestoreOriginalFrame:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCAnimation_totalDelayUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real totalDelayUnits ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

void JSB_CCAnimation_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCAnimation_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCAnimation_class->name = name;
	JSB_CCAnimation_class->addProperty = JS_PropertyStub;
	JSB_CCAnimation_class->delProperty = JS_PropertyStub;
	JSB_CCAnimation_class->getProperty = JS_PropertyStub;
	JSB_CCAnimation_class->setProperty = JS_StrictPropertyStub;
	JSB_CCAnimation_class->enumerate = JS_EnumerateStub;
	JSB_CCAnimation_class->resolve = JS_ResolveStub;
	JSB_CCAnimation_class->convert = JS_ConvertStub;
	JSB_CCAnimation_class->finalize = JSB_CCAnimation_finalize;
	JSB_CCAnimation_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addSpriteFrame", JSB_CCAnimation_addSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrameWithFile", JSB_CCAnimation_addSpriteFrameWithFilename_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrameWithTextureRect", JSB_CCAnimation_addSpriteFrameWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDelayPerUnit", JSB_CCAnimation_delayPerUnit, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getDuration", JSB_CCAnimation_duration, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFrames", JSB_CCAnimation_frames, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithAnimationFramesDelayPerUnitLoops", JSB_CCAnimation_initWithAnimationFrames_delayPerUnit_loops_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrames", JSB_CCAnimation_initWithSpriteFrames_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFramesDelay", JSB_CCAnimation_initWithSpriteFrames_delay_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLoops", JSB_CCAnimation_loops, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRestoreOriginalFrame", JSB_CCAnimation_restoreOriginalFrame, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setDelayPerUnit", JSB_CCAnimation_setDelayPerUnit_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setFrames", JSB_CCAnimation_setFrames_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLoops", JSB_CCAnimation_setLoops_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRestoreOriginalFrame", JSB_CCAnimation_setRestoreOriginalFrame_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTotalDelayUnits", JSB_CCAnimation_totalDelayUnits, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCAnimation_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCAnimation_animationWithAnimationFrames_delayPerUnit_loops__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCAnimation_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCAnimation_class, JSB_CCAnimation_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCAnimation

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCAnimation_class, JSB_CCAnimation_object, NULL);
	JSB_CCAnimation *proxy = [[JSB_CCAnimation alloc] initWithJSObject:jsobj class:[CCAnimation class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineInOut
 */
#pragma mark - CCEaseSineInOut

JSClass* JSB_CCEaseSineInOut_class = NULL;
JSObject* JSB_CCEaseSineInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseSineInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseSineInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseSineInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseSineInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseSineInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseSineInOut *proxy = [[JSB_CCEaseSineInOut alloc] initWithJSObject:obj class:[CCEaseSineInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseSineInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseSineInOut *real = (CCEaseSineInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineInOut* (o)
JSBool JSB_CCEaseSineInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseSineInOut* ret_val;

	ret_val = [CCEaseSineInOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseSineInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseSineInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseSineInOut_class->name = name;
	JSB_CCEaseSineInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseSineInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseSineInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseSineInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseSineInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseSineInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseSineInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseSineInOut_class->finalize = JSB_CCEaseSineInOut_finalize;
	JSB_CCEaseSineInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseSineInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseSineInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseSineInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseSineInOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseSineInOut_class, JSB_CCEaseSineInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseSineInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseSineInOut_class, JSB_CCEaseSineInOut_object, NULL);
	JSB_CCEaseSineInOut *proxy = [[JSB_CCEaseSineInOut alloc] initWithJSObject:jsobj class:[CCEaseSineInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShaky3D
 */
#pragma mark - CCShaky3D

JSClass* JSB_CCShaky3D_class = NULL;
JSObject* JSB_CCShaky3D_object = NULL;
// Constructor
JSBool JSB_CCShaky3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCShaky3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCShaky3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCShaky3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCShaky3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCShaky3D *proxy = [[JSB_CCShaky3D alloc] initWithJSObject:obj class:[CCShaky3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: CCShaky3D* (o)
JSBool JSB_CCShaky3D_actionWithDuration_size_range_shakeZ__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCShaky3D* ret_val;

	ret_val = [CCShaky3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shakeZ:(BOOL)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, int, BOOL
// Ret value: None (None)
JSBool JSB_CCShaky3D_initWithDuration_size_range_shakeZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; int32_t arg2; JSBool arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCShaky3D *real = [(CCShaky3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 range:(int)arg2 shakeZ:(BOOL)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCShaky3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCShaky3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCShaky3D_class->name = name;
	JSB_CCShaky3D_class->addProperty = JS_PropertyStub;
	JSB_CCShaky3D_class->delProperty = JS_PropertyStub;
	JSB_CCShaky3D_class->getProperty = JS_PropertyStub;
	JSB_CCShaky3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCShaky3D_class->enumerate = JS_EnumerateStub;
	JSB_CCShaky3D_class->resolve = JS_ResolveStub;
	JSB_CCShaky3D_class->convert = JS_ConvertStub;
	JSB_CCShaky3D_class->finalize = JSB_CCShaky3D_finalize;
	JSB_CCShaky3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizeRangeShakeZ", JSB_CCShaky3D_initWithDuration_size_range_shakeZ_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCShaky3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCShaky3D_actionWithDuration_size_range_shakeZ__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCShaky3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCShaky3D_class, JSB_CCShaky3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCShaky3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCShaky3D_class, JSB_CCShaky3D_object, NULL);
	JSB_CCShaky3D *proxy = [[JSB_CCShaky3D alloc] initWithJSObject:jsobj class:[CCShaky3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressRadialCW
 */
#pragma mark - CCTransitionProgressRadialCW

JSClass* JSB_CCTransitionProgressRadialCW_class = NULL;
JSObject* JSB_CCTransitionProgressRadialCW_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressRadialCW_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressRadialCW createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressRadialCW_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressRadialCW)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressRadialCW_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressRadialCW *proxy = [[JSB_CCTransitionProgressRadialCW alloc] initWithJSObject:obj class:[CCTransitionProgressRadialCW class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressRadialCW *real = (CCTransitionProgressRadialCW*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressRadialCW* (o)
JSBool JSB_CCTransitionProgressRadialCW_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressRadialCW* ret_val;

	ret_val = [CCTransitionProgressRadialCW transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressRadialCW* (o)
JSBool JSB_CCTransitionProgressRadialCW_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressRadialCW* ret_val;

	ret_val = [CCTransitionProgressRadialCW node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressRadialCW_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressRadialCW_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressRadialCW_class->name = name;
	JSB_CCTransitionProgressRadialCW_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCW_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCW_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressRadialCW_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressRadialCW_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressRadialCW_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressRadialCW_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressRadialCW_class->finalize = JSB_CCTransitionProgressRadialCW_finalize;
	JSB_CCTransitionProgressRadialCW_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressRadialCW_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressRadialCW_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressRadialCW_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressRadialCW_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressRadialCW_class, JSB_CCTransitionProgressRadialCW_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressRadialCW

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressRadialCW_class, JSB_CCTransitionProgressRadialCW_object, NULL);
	JSB_CCTransitionProgressRadialCW *proxy = [[JSB_CCTransitionProgressRadialCW alloc] initWithJSObject:jsobj class:[CCTransitionProgressRadialCW class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDrawNode
 */
#pragma mark - CCDrawNode

JSClass* JSB_CCDrawNode_class = NULL;
JSObject* JSB_CCDrawNode_object = NULL;
// Constructor
JSBool JSB_CCDrawNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDrawNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDrawNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDrawNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDrawNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDrawNode *proxy = [[JSB_CCDrawNode alloc] initWithJSObject:obj class:[CCDrawNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCDrawNode_clear(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real clear ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint, CGFloat, ccColor4F
// Ret value: void (None)
JSBool JSB_CCDrawNode_drawDot_radius_color_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; ccColor4F arg2; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real drawDot:(CGPoint)arg0 radius:(CGFloat)arg1 color:(ccColor4F)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint, CGPoint, CGFloat, ccColor4F
// Ret value: void (None)
JSBool JSB_CCDrawNode_drawSegmentFrom_to_radius_color_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; CGPoint arg1; double arg2; ccColor4F arg3; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real drawSegmentFrom:(CGPoint)arg0 to:(CGPoint)arg1 radius:(CGFloat)arg2 color:(ccColor4F)arg3  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDrawNode* (o)
JSBool JSB_CCDrawNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCDrawNode* ret_val;

	ret_val = [CCDrawNode node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCDrawNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDrawNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDrawNode_class->name = name;
	JSB_CCDrawNode_class->addProperty = JS_PropertyStub;
	JSB_CCDrawNode_class->delProperty = JS_PropertyStub;
	JSB_CCDrawNode_class->getProperty = JS_PropertyStub;
	JSB_CCDrawNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDrawNode_class->enumerate = JS_EnumerateStub;
	JSB_CCDrawNode_class->resolve = JS_ResolveStub;
	JSB_CCDrawNode_class->convert = JS_ConvertStub;
	JSB_CCDrawNode_class->finalize = JSB_CCDrawNode_finalize;
	JSB_CCDrawNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("clear", JSB_CCDrawNode_clear, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawDot", JSB_CCDrawNode_drawDot_radius_color_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawPoly", JSB_CCDrawNode_drawPolyWithVerts_count_fillColor_borderWidth_borderColor_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawSegment", JSB_CCDrawNode_drawSegmentFrom_to_radius_color_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSB_CCDrawNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDrawNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCDrawNode_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDrawNode_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCDrawNode_class, JSB_CCDrawNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDrawNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDrawNode_class, JSB_CCDrawNode_object, NULL);
	JSB_CCDrawNode *proxy = [[JSB_CCDrawNode alloc] initWithJSObject:jsobj class:[CCDrawNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPhysicsDebugNode
 */
#pragma mark - CCPhysicsDebugNode

JSClass* JSB_CCPhysicsDebugNode_class = NULL;
JSObject* JSB_CCPhysicsDebugNode_object = NULL;
// Constructor
JSBool JSB_CCPhysicsDebugNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCPhysicsDebugNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCPhysicsDebugNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCPhysicsDebugNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCPhysicsDebugNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCPhysicsDebugNode *proxy = [[JSB_CCPhysicsDebugNode alloc] initWithJSObject:obj class:[CCPhysicsDebugNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: CCPhysicsDebugNode* (o)
JSBool JSB_CCPhysicsDebugNode_debugNodeForCPSpace__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpSpace* arg0; 

	ok &= JSB_jsval_to_opaque( cx, *argvp++, (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCPhysicsDebugNode* ret_val;

	ret_val = [CCPhysicsDebugNode debugNodeForCPSpace:(cpSpace*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: void (None)
JSBool JSB_CCPhysicsDebugNode_setSpace_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpSpace* arg0; 

	ok &= JSB_jsval_to_opaque( cx, *argvp++, (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCPhysicsDebugNode *real = (CCPhysicsDebugNode*) [proxy realObj];
	[real setSpace:(cpSpace*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace* (N/A)
JSBool JSB_CCPhysicsDebugNode_space(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	cpSpace* ret_val;

	CCPhysicsDebugNode *real = (CCPhysicsDebugNode*) [proxy realObj];
	ret_val = [real space ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_opaque( cx, ret_val ));

	return JS_TRUE;
}

void JSB_CCPhysicsDebugNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCPhysicsDebugNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCPhysicsDebugNode_class->name = name;
	JSB_CCPhysicsDebugNode_class->addProperty = JS_PropertyStub;
	JSB_CCPhysicsDebugNode_class->delProperty = JS_PropertyStub;
	JSB_CCPhysicsDebugNode_class->getProperty = JS_PropertyStub;
	JSB_CCPhysicsDebugNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCPhysicsDebugNode_class->enumerate = JS_EnumerateStub;
	JSB_CCPhysicsDebugNode_class->resolve = JS_ResolveStub;
	JSB_CCPhysicsDebugNode_class->convert = JS_ConvertStub;
	JSB_CCPhysicsDebugNode_class->finalize = JSB_CCPhysicsDebugNode_finalize;
	JSB_CCPhysicsDebugNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("_setSpace", JSB_CCPhysicsDebugNode_setSpace_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_CCPhysicsDebugNode_space, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCPhysicsDebugNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("_create", JSB_CCPhysicsDebugNode_debugNodeForCPSpace__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCPhysicsDebugNode_object = JS_InitClass(cx, globalObj, JSB_CCDrawNode_object, JSB_CCPhysicsDebugNode_class, JSB_CCPhysicsDebugNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCPhysicsDebugNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCPhysicsDebugNode_class, JSB_CCPhysicsDebugNode_object, NULL);
	JSB_CCPhysicsDebugNode *proxy = [[JSB_CCPhysicsDebugNode alloc] initWithJSObject:jsobj class:[CCPhysicsDebugNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTintTo
 */
#pragma mark - CCTintTo

JSClass* JSB_CCTintTo_class = NULL;
JSObject* JSB_CCTintTo_object = NULL;
// Constructor
JSBool JSB_CCTintTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTintTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTintTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTintTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTintTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTintTo *proxy = [[JSB_CCTintTo alloc] initWithJSObject:obj class:[CCTintTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte, GLubyte, GLubyte
// Ret value: CCTintTo* (o)
JSBool JSB_CCTintTo_actionWithDuration_red_green_blue__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTintTo* ret_val;

	ret_val = [CCTintTo actionWithDuration:(ccTime)arg0 red:(GLubyte)arg1 green:(GLubyte)arg2 blue:(GLubyte)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte, GLubyte, GLubyte
// Ret value: None (None)
JSBool JSB_CCTintTo_initWithDuration_red_green_blue_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTintTo *real = [(CCTintTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 red:(GLubyte)arg1 green:(GLubyte)arg2 blue:(GLubyte)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCTintTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTintTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTintTo_class->name = name;
	JSB_CCTintTo_class->addProperty = JS_PropertyStub;
	JSB_CCTintTo_class->delProperty = JS_PropertyStub;
	JSB_CCTintTo_class->getProperty = JS_PropertyStub;
	JSB_CCTintTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTintTo_class->enumerate = JS_EnumerateStub;
	JSB_CCTintTo_class->resolve = JS_ResolveStub;
	JSB_CCTintTo_class->convert = JS_ConvertStub;
	JSB_CCTintTo_class->finalize = JSB_CCTintTo_finalize;
	JSB_CCTintTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRedGreenBlue", JSB_CCTintTo_initWithDuration_red_green_blue_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTintTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTintTo_actionWithDuration_red_green_blue__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTintTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCTintTo_class, JSB_CCTintTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTintTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTintTo_class, JSB_CCTintTo_object, NULL);
	JSB_CCTintTo *proxy = [[JSB_CCTintTo alloc] initWithJSObject:jsobj class:[CCTintTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionTurnOffTiles
 */
#pragma mark - CCTransitionTurnOffTiles

JSClass* JSB_CCTransitionTurnOffTiles_class = NULL;
JSObject* JSB_CCTransitionTurnOffTiles_object = NULL;
// Constructor
JSBool JSB_CCTransitionTurnOffTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionTurnOffTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionTurnOffTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionTurnOffTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionTurnOffTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionTurnOffTiles *proxy = [[JSB_CCTransitionTurnOffTiles alloc] initWithJSObject:obj class:[CCTransitionTurnOffTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionTurnOffTiles_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionTurnOffTiles *real = [(CCTransitionTurnOffTiles*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionTurnOffTiles_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionTurnOffTiles *real = (CCTransitionTurnOffTiles*) [proxy realObj];
	ret_val = [real easeActionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionTurnOffTiles* (o)
JSBool JSB_CCTransitionTurnOffTiles_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionTurnOffTiles* ret_val;

	ret_val = [CCTransitionTurnOffTiles transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionTurnOffTiles* (o)
JSBool JSB_CCTransitionTurnOffTiles_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionTurnOffTiles* ret_val;

	ret_val = [CCTransitionTurnOffTiles node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionTurnOffTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionTurnOffTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionTurnOffTiles_class->name = name;
	JSB_CCTransitionTurnOffTiles_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionTurnOffTiles_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionTurnOffTiles_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionTurnOffTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionTurnOffTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionTurnOffTiles_class->resolve = JS_ResolveStub;
	JSB_CCTransitionTurnOffTiles_class->convert = JS_ConvertStub;
	JSB_CCTransitionTurnOffTiles_class->finalize = JSB_CCTransitionTurnOffTiles_finalize;
	JSB_CCTransitionTurnOffTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionTurnOffTiles_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSB_CCTransitionTurnOffTiles_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionTurnOffTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionTurnOffTiles_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionTurnOffTiles_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionTurnOffTiles_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionTurnOffTiles_class, JSB_CCTransitionTurnOffTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionTurnOffTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionTurnOffTiles_class, JSB_CCTransitionTurnOffTiles_object, NULL);
	JSB_CCTransitionTurnOffTiles *proxy = [[JSB_CCTransitionTurnOffTiles alloc] initWithJSObject:jsobj class:[CCTransitionTurnOffTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInT
 */
#pragma mark - CCTransitionSlideInT

JSClass* JSB_CCTransitionSlideInT_class = NULL;
JSObject* JSB_CCTransitionSlideInT_object = NULL;
// Constructor
JSBool JSB_CCTransitionSlideInT_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSlideInT createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSlideInT_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSlideInT)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSlideInT_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSlideInT *proxy = [[JSB_CCTransitionSlideInT alloc] initWithJSObject:obj class:[CCTransitionSlideInT class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionSlideInT_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionSlideInT *real = (CCTransitionSlideInT*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInT* (o)
JSBool JSB_CCTransitionSlideInT_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSlideInT* ret_val;

	ret_val = [CCTransitionSlideInT transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInT* (o)
JSBool JSB_CCTransitionSlideInT_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSlideInT* ret_val;

	ret_val = [CCTransitionSlideInT node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSlideInT_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSlideInT_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSlideInT_class->name = name;
	JSB_CCTransitionSlideInT_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInT_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInT_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInT_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSlideInT_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSlideInT_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSlideInT_class->convert = JS_ConvertStub;
	JSB_CCTransitionSlideInT_class->finalize = JSB_CCTransitionSlideInT_finalize;
	JSB_CCTransitionSlideInT_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionSlideInT_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSlideInT_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSlideInT_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSlideInT_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSlideInT_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSlideInL_object, JSB_CCTransitionSlideInT_class, JSB_CCTransitionSlideInT_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSlideInT

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSlideInT_class, JSB_CCTransitionSlideInT_object, NULL);
	JSB_CCTransitionSlideInT *proxy = [[JSB_CCTransitionSlideInT alloc] initWithJSObject:jsobj class:[CCTransitionSlideInT class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBlink
 */
#pragma mark - CCBlink

JSClass* JSB_CCBlink_class = NULL;
JSObject* JSB_CCBlink_object = NULL;
// Constructor
JSBool JSB_CCBlink_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCBlink createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCBlink_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCBlink)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCBlink_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCBlink *proxy = [[JSB_CCBlink alloc] initWithJSObject:obj class:[CCBlink class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: CCBlink* (o)
JSBool JSB_CCBlink_actionWithDuration_blinks__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCBlink* ret_val;

	ret_val = [CCBlink actionWithDuration:(ccTime)arg0 blinks:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: None (None)
JSBool JSB_CCBlink_initWithDuration_blinks_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCBlink *real = [(CCBlink*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 blinks:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCBlink_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCBlink_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCBlink_class->name = name;
	JSB_CCBlink_class->addProperty = JS_PropertyStub;
	JSB_CCBlink_class->delProperty = JS_PropertyStub;
	JSB_CCBlink_class->getProperty = JS_PropertyStub;
	JSB_CCBlink_class->setProperty = JS_StrictPropertyStub;
	JSB_CCBlink_class->enumerate = JS_EnumerateStub;
	JSB_CCBlink_class->resolve = JS_ResolveStub;
	JSB_CCBlink_class->convert = JS_ConvertStub;
	JSB_CCBlink_class->finalize = JSB_CCBlink_finalize;
	JSB_CCBlink_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationBlinks", JSB_CCBlink_initWithDuration_blinks_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCBlink_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCBlink_actionWithDuration_blinks__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCBlink_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCBlink_class, JSB_CCBlink_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCBlink

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCBlink_class, JSB_CCBlink_object, NULL);
	JSB_CCBlink *proxy = [[JSB_CCBlink alloc] initWithJSObject:jsobj class:[CCBlink class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTextureAtlas
 */
#pragma mark - CCTextureAtlas

JSClass* JSB_CCTextureAtlas_class = NULL;
JSObject* JSB_CCTextureAtlas_object = NULL;
// Constructor
JSBool JSB_CCTextureAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTextureAtlas createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTextureAtlas_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTextureAtlas)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTextureAtlas_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTextureAtlas *proxy = [[JSB_CCTextureAtlas alloc] initWithJSObject:obj class:[CCTextureAtlas class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTextureAtlas_capacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real capacity ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_drawNumberOfQuads_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawNumberOfQuads:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_drawNumberOfQuads_fromIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawNumberOfQuads:(NSUInteger)arg0 fromIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_drawQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawQuads ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_fillWithEmptyQuadsFromIndex_amount_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real fillWithEmptyQuadsFromIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_increaseTotalQuadsWith_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real increaseTotalQuadsWith:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCTextureAtlas_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = [(CCTextureAtlas*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSB_CCTextureAtlas_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = [(CCTextureAtlas*)[proxy.klass alloc] initWithTexture:arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_insertQuadFromIndex_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real insertQuadFromIndex:(NSUInteger)arg0 atIndex:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_moveQuadsFromIndex_amount_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real moveQuadsFromIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1 atIndex:(NSUInteger)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_moveQuadsFromIndex_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real moveQuadsFromIndex:(NSUInteger)arg0 to:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_removeAllQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeAllQuads ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_removeQuadAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeQuadAtIndex:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_removeQuadsAtIndex_amount_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeQuadsAtIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: BOOL (b)
JSBool JSB_CCTextureAtlas_resizeCapacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real resizeCapacity:(NSUInteger)arg0  ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCTextureAtlas_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real setTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSB_CCTextureAtlas_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real texture ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCTextureAtlas_textureAtlasWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTextureAtlas* ret_val;

	ret_val = [CCTextureAtlas textureAtlasWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCTextureAtlas* (o)
JSBool JSB_CCTextureAtlas_textureAtlasWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTextureAtlas* ret_val;

	ret_val = [CCTextureAtlas textureAtlasWithTexture:arg0 capacity:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTextureAtlas_totalQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real totalQuads ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

void JSB_CCTextureAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTextureAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTextureAtlas_class->name = name;
	JSB_CCTextureAtlas_class->addProperty = JS_PropertyStub;
	JSB_CCTextureAtlas_class->delProperty = JS_PropertyStub;
	JSB_CCTextureAtlas_class->getProperty = JS_PropertyStub;
	JSB_CCTextureAtlas_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTextureAtlas_class->enumerate = JS_EnumerateStub;
	JSB_CCTextureAtlas_class->resolve = JS_ResolveStub;
	JSB_CCTextureAtlas_class->convert = JS_ConvertStub;
	JSB_CCTextureAtlas_class->finalize = JSB_CCTextureAtlas_finalize;
	JSB_CCTextureAtlas_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getCapacity", JSB_CCTextureAtlas_capacity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawNumberOfQuads", JSB_CCTextureAtlas_drawNumberOfQuads_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawNumberOfQuadsFromIndex", JSB_CCTextureAtlas_drawNumberOfQuads_fromIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("drawQuads", JSB_CCTextureAtlas_drawQuads, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("fillWithEmptyQuadsFromIndexAmount", JSB_CCTextureAtlas_fillWithEmptyQuadsFromIndex_amount_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("increaseTotalQuadsWith", JSB_CCTextureAtlas_increaseTotalQuadsWith_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithFileCapacity", JSB_CCTextureAtlas_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithTextureCapacity", JSB_CCTextureAtlas_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("insertQuadFromIndexAtIndex", JSB_CCTextureAtlas_insertQuadFromIndex_atIndex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("moveQuadsFromIndexAmountAtIndex", JSB_CCTextureAtlas_moveQuadsFromIndex_amount_atIndex_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("moveQuadsFromIndexTo", JSB_CCTextureAtlas_moveQuadsFromIndex_to_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAllQuads", JSB_CCTextureAtlas_removeAllQuads, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeQuadAtIndex", JSB_CCTextureAtlas_removeQuadAtIndex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeQuadsAtIndexAmount", JSB_CCTextureAtlas_removeQuadsAtIndex_amount_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resizeCapacity", JSB_CCTextureAtlas_resizeCapacity_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSB_CCTextureAtlas_setTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSB_CCTextureAtlas_texture, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getTotalQuads", JSB_CCTextureAtlas_totalQuads, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTextureAtlas_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("textureAtlasWithFileCapacity", JSB_CCTextureAtlas_textureAtlasWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("textureAtlasWithTextureCapacity", JSB_CCTextureAtlas_textureAtlasWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTextureAtlas_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTextureAtlas_class, JSB_CCTextureAtlas_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTextureAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTextureAtlas_class, JSB_CCTextureAtlas_object, NULL);
	JSB_CCTextureAtlas *proxy = [[JSB_CCTextureAtlas alloc] initWithJSObject:jsobj class:[CCTextureAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInR
 */
#pragma mark - CCTransitionSlideInR

JSClass* JSB_CCTransitionSlideInR_class = NULL;
JSObject* JSB_CCTransitionSlideInR_object = NULL;
// Constructor
JSBool JSB_CCTransitionSlideInR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSlideInR createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSlideInR_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSlideInR)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSlideInR_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSlideInR *proxy = [[JSB_CCTransitionSlideInR alloc] initWithJSObject:obj class:[CCTransitionSlideInR class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCTransitionSlideInR_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionSlideInR *real = (CCTransitionSlideInR*) [proxy realObj];
	[real initScenes ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInR* (o)
JSBool JSB_CCTransitionSlideInR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSlideInR* ret_val;

	ret_val = [CCTransitionSlideInR transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInR* (o)
JSBool JSB_CCTransitionSlideInR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSlideInR* ret_val;

	ret_val = [CCTransitionSlideInR node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSlideInR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSlideInR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSlideInR_class->name = name;
	JSB_CCTransitionSlideInR_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInR_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInR_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSlideInR_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSlideInR_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSlideInR_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSlideInR_class->convert = JS_ConvertStub;
	JSB_CCTransitionSlideInR_class->finalize = JSB_CCTransitionSlideInR_finalize;
	JSB_CCTransitionSlideInR_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSB_CCTransitionSlideInR_initScenes, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSlideInR_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSlideInR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSlideInR_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSlideInR_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSlideInL_object, JSB_CCTransitionSlideInR_class, JSB_CCTransitionSlideInR_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSlideInR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSlideInR_class, JSB_CCTransitionSlideInR_object, NULL);
	JSB_CCTransitionSlideInR *proxy = [[JSB_CCTransitionSlideInR alloc] initWithJSObject:jsobj class:[CCTransitionSlideInR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressInOut
 */
#pragma mark - CCTransitionProgressInOut

JSClass* JSB_CCTransitionProgressInOut_class = NULL;
JSObject* JSB_CCTransitionProgressInOut_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressInOut *proxy = [[JSB_CCTransitionProgressInOut alloc] initWithJSObject:obj class:[CCTransitionProgressInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressInOut *real = (CCTransitionProgressInOut*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressInOut* (o)
JSBool JSB_CCTransitionProgressInOut_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressInOut* ret_val;

	ret_val = [CCTransitionProgressInOut transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressInOut* (o)
JSBool JSB_CCTransitionProgressInOut_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressInOut* ret_val;

	ret_val = [CCTransitionProgressInOut node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressInOut_class->name = name;
	JSB_CCTransitionProgressInOut_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressInOut_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressInOut_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressInOut_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressInOut_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressInOut_class->finalize = JSB_CCTransitionProgressInOut_finalize;
	JSB_CCTransitionProgressInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressInOut_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressInOut_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressInOut_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressInOut_class, JSB_CCTransitionProgressInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressInOut_class, JSB_CCTransitionProgressInOut_object, NULL);
	JSB_CCTransitionProgressInOut *proxy = [[JSB_CCTransitionProgressInOut alloc] initWithJSObject:jsobj class:[CCTransitionProgressInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceIn
 */
#pragma mark - CCEaseBounceIn

JSClass* JSB_CCEaseBounceIn_class = NULL;
JSObject* JSB_CCEaseBounceIn_object = NULL;
// Constructor
JSBool JSB_CCEaseBounceIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBounceIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBounceIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBounceIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBounceIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBounceIn *proxy = [[JSB_CCEaseBounceIn alloc] initWithJSObject:obj class:[CCEaseBounceIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBounceIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBounceIn *real = (CCEaseBounceIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceIn* (o)
JSBool JSB_CCEaseBounceIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBounceIn* ret_val;

	ret_val = [CCEaseBounceIn actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBounceIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBounceIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBounceIn_class->name = name;
	JSB_CCEaseBounceIn_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBounceIn_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBounceIn_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBounceIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBounceIn_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBounceIn_class->resolve = JS_ResolveStub;
	JSB_CCEaseBounceIn_class->convert = JS_ConvertStub;
	JSB_CCEaseBounceIn_class->finalize = JSB_CCEaseBounceIn_finalize;
	JSB_CCEaseBounceIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBounceIn_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBounceIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBounceIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBounceIn_object = JS_InitClass(cx, globalObj, JSB_CCEaseBounce_object, JSB_CCEaseBounceIn_class, JSB_CCEaseBounceIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBounceIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBounceIn_class, JSB_CCEaseBounceIn_object, NULL);
	JSB_CCEaseBounceIn *proxy = [[JSB_CCEaseBounceIn alloc] initWithJSObject:jsobj class:[CCEaseBounceIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLiquid
 */
#pragma mark - CCLiquid

JSClass* JSB_CCLiquid_class = NULL;
JSObject* JSB_CCLiquid_object = NULL;
// Constructor
JSBool JSB_CCLiquid_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLiquid createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLiquid_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLiquid)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLiquid_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLiquid *proxy = [[JSB_CCLiquid alloc] initWithJSObject:obj class:[CCLiquid class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: CCLiquid* (o)
JSBool JSB_CCLiquid_actionWithDuration_size_waves_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLiquid* ret_val;

	ret_val = [CCLiquid actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCLiquid_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCLiquid_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: None (None)
JSBool JSB_CCLiquid_initWithDuration_size_waves_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLiquid *real = [(CCLiquid*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLiquid_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLiquid_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCLiquid_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLiquid_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLiquid_class->name = name;
	JSB_CCLiquid_class->addProperty = JS_PropertyStub;
	JSB_CCLiquid_class->delProperty = JS_PropertyStub;
	JSB_CCLiquid_class->getProperty = JS_PropertyStub;
	JSB_CCLiquid_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLiquid_class->enumerate = JS_EnumerateStub;
	JSB_CCLiquid_class->resolve = JS_ResolveStub;
	JSB_CCLiquid_class->convert = JS_ConvertStub;
	JSB_CCLiquid_class->finalize = JSB_CCLiquid_finalize;
	JSB_CCLiquid_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCLiquid_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCLiquid_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizeWavesAmplitude", JSB_CCLiquid_initWithDuration_size_waves_amplitude_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCLiquid_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCLiquid_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLiquid_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLiquid_actionWithDuration_size_waves_amplitude__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLiquid_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCLiquid_class, JSB_CCLiquid_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLiquid

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLiquid_class, JSB_CCLiquid_object, NULL);
	JSB_CCLiquid *proxy = [[JSB_CCLiquid alloc] initWithJSObject:jsobj class:[CCLiquid class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressTimer
 */
#pragma mark - CCProgressTimer

JSClass* JSB_CCProgressTimer_class = NULL;
JSObject* JSB_CCProgressTimer_object = NULL;
// Constructor
JSBool JSB_CCProgressTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCProgressTimer createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCProgressTimer_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCProgressTimer)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCProgressTimer_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCProgressTimer *proxy = [[JSB_CCProgressTimer alloc] initWithJSObject:obj class:[CCProgressTimer class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCProgressTimer_barChangeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real barChangeRate ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: None (None)
JSBool JSB_CCProgressTimer_initWithSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = [(CCProgressTimer*)[proxy.klass alloc] initWithSprite:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCProgressTimer_midpoint(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real midpoint ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCProgressTimer_percentage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real percentage ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCProgressTimer_progressWithSprite__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	ret_val = [CCProgressTimer progressWithSprite:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCProgressTimer_reverseDirection(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real reverseDirection ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setBarChangeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setBarChangeRate:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setMidpoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setMidpoint:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setPercentage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setPercentage:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setReverseDirection_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setReverseDirection:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setSprite:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCProgressTimerType
// Ret value: void (None)
JSBool JSB_CCProgressTimer_setType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setType:(CCProgressTimerType)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSprite* (o)
JSBool JSB_CCProgressTimer_sprite(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSprite* ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real sprite ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProgressTimerType (i)
JSBool JSB_CCProgressTimer_type(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCProgressTimerType ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real type ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSB_CCProgressTimer_vertexDataCount(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	int ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real vertexDataCount ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

void JSB_CCProgressTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCProgressTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCProgressTimer_class->name = name;
	JSB_CCProgressTimer_class->addProperty = JS_PropertyStub;
	JSB_CCProgressTimer_class->delProperty = JS_PropertyStub;
	JSB_CCProgressTimer_class->getProperty = JS_PropertyStub;
	JSB_CCProgressTimer_class->setProperty = JS_StrictPropertyStub;
	JSB_CCProgressTimer_class->enumerate = JS_EnumerateStub;
	JSB_CCProgressTimer_class->resolve = JS_ResolveStub;
	JSB_CCProgressTimer_class->convert = JS_ConvertStub;
	JSB_CCProgressTimer_class->finalize = JSB_CCProgressTimer_finalize;
	JSB_CCProgressTimer_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBarChangeRate", JSB_CCProgressTimer_barChangeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithSprite", JSB_CCProgressTimer_initWithSprite_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getMidpoint", JSB_CCProgressTimer_midpoint, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPercentage", JSB_CCProgressTimer_percentage, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getReverseDirection", JSB_CCProgressTimer_reverseDirection, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setBarChangeRate", JSB_CCProgressTimer_setBarChangeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setMidpoint", JSB_CCProgressTimer_setMidpoint_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPercentage", JSB_CCProgressTimer_setPercentage_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setReverseDirection", JSB_CCProgressTimer_setReverseDirection_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSprite", JSB_CCProgressTimer_setSprite_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setType", JSB_CCProgressTimer_setType_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSprite", JSB_CCProgressTimer_sprite, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getType", JSB_CCProgressTimer_type, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVertexDataCount", JSB_CCProgressTimer_vertexDataCount, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCProgressTimer_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCProgressTimer_progressWithSprite__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCProgressTimer_object = JS_InitClass(cx, globalObj, JSB_CCNodeRGBA_object, JSB_CCProgressTimer_class, JSB_CCProgressTimer_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCProgressTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCProgressTimer_class, JSB_CCProgressTimer_object, NULL);
	JSB_CCProgressTimer *proxy = [[JSB_CCProgressTimer alloc] initWithJSObject:jsobj class:[CCProgressTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceInOut
 */
#pragma mark - CCEaseBounceInOut

JSClass* JSB_CCEaseBounceInOut_class = NULL;
JSObject* JSB_CCEaseBounceInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseBounceInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBounceInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBounceInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBounceInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBounceInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBounceInOut *proxy = [[JSB_CCEaseBounceInOut alloc] initWithJSObject:obj class:[CCEaseBounceInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBounceInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBounceInOut *real = (CCEaseBounceInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceInOut* (o)
JSBool JSB_CCEaseBounceInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBounceInOut* ret_val;

	ret_val = [CCEaseBounceInOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBounceInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBounceInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBounceInOut_class->name = name;
	JSB_CCEaseBounceInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBounceInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBounceInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBounceInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBounceInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBounceInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseBounceInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseBounceInOut_class->finalize = JSB_CCEaseBounceInOut_finalize;
	JSB_CCEaseBounceInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBounceInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBounceInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBounceInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBounceInOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseBounce_object, JSB_CCEaseBounceInOut_class, JSB_CCEaseBounceInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBounceInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBounceInOut_class, JSB_CCEaseBounceInOut_object, NULL);
	JSB_CCEaseBounceInOut *proxy = [[JSB_CCEaseBounceInOut alloc] initWithJSObject:jsobj class:[CCEaseBounceInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionTween
 */
#pragma mark - CCActionTween

JSClass* JSB_CCActionTween_class = NULL;
JSObject* JSB_CCActionTween_object = NULL;
// Constructor
JSBool JSB_CCActionTween_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionTween createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionTween_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionTween)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionTween_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionTween *proxy = [[JSB_CCActionTween alloc] initWithJSObject:obj class:[CCActionTween class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, NSString*, float, float
// Ret value: CCActionTween* (o)
JSBool JSB_CCActionTween_actionWithDuration_key_from_to__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; NSString* arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionTween* ret_val;

	ret_val = [CCActionTween actionWithDuration:(ccTime)arg0 key:(NSString*)arg1 from:(float)arg2 to:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, NSString*, float, float
// Ret value: None (None)
JSBool JSB_CCActionTween_initWithDuration_key_from_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; NSString* arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionTween *real = [(CCActionTween*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 key:(NSString*)arg1 from:(float)arg2 to:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCActionTween_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionTween_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionTween_class->name = name;
	JSB_CCActionTween_class->addProperty = JS_PropertyStub;
	JSB_CCActionTween_class->delProperty = JS_PropertyStub;
	JSB_CCActionTween_class->getProperty = JS_PropertyStub;
	JSB_CCActionTween_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionTween_class->enumerate = JS_EnumerateStub;
	JSB_CCActionTween_class->resolve = JS_ResolveStub;
	JSB_CCActionTween_class->convert = JS_ConvertStub;
	JSB_CCActionTween_class->finalize = JSB_CCActionTween_finalize;
	JSB_CCActionTween_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationKeyFromTo", JSB_CCActionTween_initWithDuration_key_from_to_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionTween_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationKeyFromTo", JSB_CCActionTween_actionWithDuration_key_from_to__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCActionTween_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCActionTween_class, JSB_CCActionTween_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionTween

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionTween_class, JSB_CCActionTween_object, NULL);
	JSB_CCActionTween *proxy = [[JSB_CCActionTween alloc] initWithJSObject:jsobj class:[CCActionTween class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrabber
 */
#pragma mark - CCGrabber

JSClass* JSB_CCGrabber_class = NULL;
JSObject* JSB_CCGrabber_object = NULL;
// Constructor
JSBool JSB_CCGrabber_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGrabber createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGrabber_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGrabber)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGrabber_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGrabber *proxy = [[JSB_CCGrabber alloc] initWithJSObject:obj class:[CCGrabber class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCGrabber_afterRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real afterRender:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCGrabber_beforeRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real beforeRender:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCGrabber_grab_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real grab:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCGrabber_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGrabber_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGrabber_class->name = name;
	JSB_CCGrabber_class->addProperty = JS_PropertyStub;
	JSB_CCGrabber_class->delProperty = JS_PropertyStub;
	JSB_CCGrabber_class->getProperty = JS_PropertyStub;
	JSB_CCGrabber_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGrabber_class->enumerate = JS_EnumerateStub;
	JSB_CCGrabber_class->resolve = JS_ResolveStub;
	JSB_CCGrabber_class->convert = JS_ConvertStub;
	JSB_CCGrabber_class->finalize = JSB_CCGrabber_finalize;
	JSB_CCGrabber_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("afterRender", JSB_CCGrabber_afterRender_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("beforeRender", JSB_CCGrabber_beforeRender_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("grab", JSB_CCGrabber_grab_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGrabber_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCGrabber_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCGrabber_class, JSB_CCGrabber_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGrabber

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGrabber_class, JSB_CCGrabber_object, NULL);
	JSB_CCGrabber *proxy = [[JSB_CCGrabber alloc] initWithJSObject:jsobj class:[CCGrabber class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSplitRows
 */
#pragma mark - CCTransitionSplitRows

JSClass* JSB_CCTransitionSplitRows_class = NULL;
JSObject* JSB_CCTransitionSplitRows_object = NULL;
// Constructor
JSBool JSB_CCTransitionSplitRows_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionSplitRows createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionSplitRows_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionSplitRows)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionSplitRows_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionSplitRows *proxy = [[JSB_CCTransitionSplitRows alloc] initWithJSObject:obj class:[CCTransitionSplitRows class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionSplitRows_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSplitRows *real = (CCTransitionSplitRows*) [proxy realObj];
	ret_val = [real action ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSplitRows* (o)
JSBool JSB_CCTransitionSplitRows_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionSplitRows* ret_val;

	ret_val = [CCTransitionSplitRows transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSplitRows* (o)
JSBool JSB_CCTransitionSplitRows_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionSplitRows* ret_val;

	ret_val = [CCTransitionSplitRows node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionSplitRows_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionSplitRows_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionSplitRows_class->name = name;
	JSB_CCTransitionSplitRows_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionSplitRows_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionSplitRows_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionSplitRows_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionSplitRows_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionSplitRows_class->resolve = JS_ResolveStub;
	JSB_CCTransitionSplitRows_class->convert = JS_ConvertStub;
	JSB_CCTransitionSplitRows_class->finalize = JSB_CCTransitionSplitRows_finalize;
	JSB_CCTransitionSplitRows_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSB_CCTransitionSplitRows_action, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionSplitRows_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionSplitRows_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionSplitRows_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionSplitRows_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSplitCols_object, JSB_CCTransitionSplitRows_class, JSB_CCTransitionSplitRows_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionSplitRows

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionSplitRows_class, JSB_CCTransitionSplitRows_object, NULL);
	JSB_CCTransitionSplitRows *proxy = [[JSB_CCTransitionSplitRows alloc] initWithJSObject:jsobj class:[CCTransitionSplitRows class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipX3D
 */
#pragma mark - CCFlipX3D

JSClass* JSB_CCFlipX3D_class = NULL;
JSObject* JSB_CCFlipX3D_object = NULL;
// Constructor
JSBool JSB_CCFlipX3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFlipX3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFlipX3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFlipX3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFlipX3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFlipX3D *proxy = [[JSB_CCFlipX3D alloc] initWithJSObject:obj class:[CCFlipX3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFlipX3D* (o)
JSBool JSB_CCFlipX3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFlipX3D* ret_val;

	ret_val = [CCFlipX3D actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: None (None)
JSBool JSB_CCFlipX3D_initWithDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFlipX3D *real = [(CCFlipX3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCFlipX3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFlipX3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFlipX3D_class->name = name;
	JSB_CCFlipX3D_class->addProperty = JS_PropertyStub;
	JSB_CCFlipX3D_class->delProperty = JS_PropertyStub;
	JSB_CCFlipX3D_class->getProperty = JS_PropertyStub;
	JSB_CCFlipX3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFlipX3D_class->enumerate = JS_EnumerateStub;
	JSB_CCFlipX3D_class->resolve = JS_ResolveStub;
	JSB_CCFlipX3D_class->convert = JS_ConvertStub;
	JSB_CCFlipX3D_class->finalize = JSB_CCFlipX3D_finalize;
	JSB_CCFlipX3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDuration", JSB_CCFlipX3D_initWithDuration_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFlipX3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFlipX3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFlipX3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCFlipX3D_class, JSB_CCFlipX3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFlipX3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFlipX3D_class, JSB_CCFlipX3D_object, NULL);
	JSB_CCFlipX3D *proxy = [[JSB_CCFlipX3D alloc] initWithJSObject:jsobj class:[CCFlipX3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipY3D
 */
#pragma mark - CCFlipY3D

JSClass* JSB_CCFlipY3D_class = NULL;
JSObject* JSB_CCFlipY3D_object = NULL;
// Constructor
JSBool JSB_CCFlipY3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFlipY3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFlipY3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFlipY3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFlipY3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFlipY3D *proxy = [[JSB_CCFlipY3D alloc] initWithJSObject:obj class:[CCFlipY3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCFlipY3D_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFlipY3D *real = (CCFlipY3D*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFlipY3D* (o)
JSBool JSB_CCFlipY3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFlipY3D* ret_val;

	ret_val = [CCFlipY3D actionWithDuration:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCFlipY3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFlipY3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFlipY3D_class->name = name;
	JSB_CCFlipY3D_class->addProperty = JS_PropertyStub;
	JSB_CCFlipY3D_class->delProperty = JS_PropertyStub;
	JSB_CCFlipY3D_class->getProperty = JS_PropertyStub;
	JSB_CCFlipY3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFlipY3D_class->enumerate = JS_EnumerateStub;
	JSB_CCFlipY3D_class->resolve = JS_ResolveStub;
	JSB_CCFlipY3D_class->convert = JS_ConvertStub;
	JSB_CCFlipY3D_class->finalize = JSB_CCFlipY3D_finalize;
	JSB_CCFlipY3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCFlipY3D_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFlipY3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFlipY3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFlipY3D_object = JS_InitClass(cx, globalObj, JSB_CCFlipX3D_object, JSB_CCFlipY3D_class, JSB_CCFlipY3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFlipY3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFlipY3D_class, JSB_CCFlipY3D_object, NULL);
	JSB_CCFlipY3D *proxy = [[JSB_CCFlipY3D alloc] initWithJSObject:jsobj class:[CCFlipY3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeTo
 */
#pragma mark - CCFadeTo

JSClass* JSB_CCFadeTo_class = NULL;
JSObject* JSB_CCFadeTo_object = NULL;
// Constructor
JSBool JSB_CCFadeTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCFadeTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCFadeTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCFadeTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCFadeTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCFadeTo *proxy = [[JSB_CCFadeTo alloc] initWithJSObject:obj class:[CCFadeTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte
// Ret value: CCFadeTo* (o)
JSBool JSB_CCFadeTo_actionWithDuration_opacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCFadeTo* ret_val;

	ret_val = [CCFadeTo actionWithDuration:(ccTime)arg0 opacity:(GLubyte)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte
// Ret value: None (None)
JSBool JSB_CCFadeTo_initWithDuration_opacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCFadeTo *real = [(CCFadeTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 opacity:(GLubyte)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCFadeTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCFadeTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCFadeTo_class->name = name;
	JSB_CCFadeTo_class->addProperty = JS_PropertyStub;
	JSB_CCFadeTo_class->delProperty = JS_PropertyStub;
	JSB_CCFadeTo_class->getProperty = JS_PropertyStub;
	JSB_CCFadeTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCFadeTo_class->enumerate = JS_EnumerateStub;
	JSB_CCFadeTo_class->resolve = JS_ResolveStub;
	JSB_CCFadeTo_class->convert = JS_ConvertStub;
	JSB_CCFadeTo_class->finalize = JSB_CCFadeTo_finalize;
	JSB_CCFadeTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationOpacity", JSB_CCFadeTo_initWithDuration_opacity_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCFadeTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCFadeTo_actionWithDuration_opacity__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCFadeTo_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCFadeTo_class, JSB_CCFadeTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCFadeTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCFadeTo_class, JSB_CCFadeTo_object, NULL);
	JSB_CCFadeTo *proxy = [[JSB_CCFadeTo alloc] initWithJSObject:jsobj class:[CCFadeTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackInOut
 */
#pragma mark - CCEaseBackInOut

JSClass* JSB_CCEaseBackInOut_class = NULL;
JSObject* JSB_CCEaseBackInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseBackInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBackInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBackInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBackInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBackInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBackInOut *proxy = [[JSB_CCEaseBackInOut alloc] initWithJSObject:obj class:[CCEaseBackInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBackInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBackInOut *real = (CCEaseBackInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackInOut* (o)
JSBool JSB_CCEaseBackInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBackInOut* ret_val;

	ret_val = [CCEaseBackInOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBackInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBackInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBackInOut_class->name = name;
	JSB_CCEaseBackInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBackInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBackInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBackInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBackInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBackInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseBackInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseBackInOut_class->finalize = JSB_CCEaseBackInOut_finalize;
	JSB_CCEaseBackInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBackInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBackInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBackInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBackInOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseBackInOut_class, JSB_CCEaseBackInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBackInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBackInOut_class, JSB_CCEaseBackInOut_object, NULL);
	JSB_CCEaseBackInOut *proxy = [[JSB_CCEaseBackInOut alloc] initWithJSObject:jsobj class:[CCEaseBackInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialOut
 */
#pragma mark - CCEaseExponentialOut

JSClass* JSB_CCEaseExponentialOut_class = NULL;
JSObject* JSB_CCEaseExponentialOut_object = NULL;
// Constructor
JSBool JSB_CCEaseExponentialOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseExponentialOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseExponentialOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseExponentialOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseExponentialOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseExponentialOut *proxy = [[JSB_CCEaseExponentialOut alloc] initWithJSObject:obj class:[CCEaseExponentialOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseExponentialOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseExponentialOut *real = (CCEaseExponentialOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialOut* (o)
JSBool JSB_CCEaseExponentialOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseExponentialOut* ret_val;

	ret_val = [CCEaseExponentialOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseExponentialOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseExponentialOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseExponentialOut_class->name = name;
	JSB_CCEaseExponentialOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseExponentialOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseExponentialOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseExponentialOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseExponentialOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseExponentialOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseExponentialOut_class->convert = JS_ConvertStub;
	JSB_CCEaseExponentialOut_class->finalize = JSB_CCEaseExponentialOut_finalize;
	JSB_CCEaseExponentialOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseExponentialOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseExponentialOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseExponentialOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseExponentialOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseExponentialOut_class, JSB_CCEaseExponentialOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseExponentialOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseExponentialOut_class, JSB_CCEaseExponentialOut_object, NULL);
	JSB_CCEaseExponentialOut *proxy = [[JSB_CCEaseExponentialOut alloc] initWithJSObject:jsobj class:[CCEaseExponentialOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMoveTo
 */
#pragma mark - CCMoveTo

JSClass* JSB_CCMoveTo_class = NULL;
JSObject* JSB_CCMoveTo_object = NULL;
// Constructor
JSBool JSB_CCMoveTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCMoveTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCMoveTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCMoveTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCMoveTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCMoveTo *proxy = [[JSB_CCMoveTo alloc] initWithJSObject:obj class:[CCMoveTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: CCMoveTo* (o)
JSBool JSB_CCMoveTo_actionWithDuration_position__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCMoveTo* ret_val;

	ret_val = [CCMoveTo actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: None (None)
JSBool JSB_CCMoveTo_initWithDuration_position_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCMoveTo *real = [(CCMoveTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCMoveTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCMoveTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCMoveTo_class->name = name;
	JSB_CCMoveTo_class->addProperty = JS_PropertyStub;
	JSB_CCMoveTo_class->delProperty = JS_PropertyStub;
	JSB_CCMoveTo_class->getProperty = JS_PropertyStub;
	JSB_CCMoveTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCMoveTo_class->enumerate = JS_EnumerateStub;
	JSB_CCMoveTo_class->resolve = JS_ResolveStub;
	JSB_CCMoveTo_class->convert = JS_ConvertStub;
	JSB_CCMoveTo_class->finalize = JSB_CCMoveTo_finalize;
	JSB_CCMoveTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPosition", JSB_CCMoveTo_initWithDuration_position_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCMoveTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCMoveTo_actionWithDuration_position__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCMoveTo_object = JS_InitClass(cx, globalObj, JSB_CCMoveBy_object, JSB_CCMoveTo_class, JSB_CCMoveTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCMoveTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCMoveTo_class, JSB_CCMoveTo_object, NULL);
	JSB_CCMoveTo *proxy = [[JSB_CCMoveTo alloc] initWithJSObject:jsobj class:[CCMoveTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProfilingTimer
 */
#pragma mark - CCProfilingTimer

JSClass* JSB_CCProfilingTimer_class = NULL;
JSObject* JSB_CCProfilingTimer_object = NULL;
// Constructor
JSBool JSB_CCProfilingTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCProfilingTimer createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCProfilingTimer_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCProfilingTimer)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCProfilingTimer_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCProfilingTimer *proxy = [[JSB_CCProfilingTimer alloc] initWithJSObject:obj class:[CCProfilingTimer class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCProfilingTimer_reset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCProfilingTimer *real = (CCProfilingTimer*) [proxy realObj];
	[real reset ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCProfilingTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCProfilingTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCProfilingTimer_class->name = name;
	JSB_CCProfilingTimer_class->addProperty = JS_PropertyStub;
	JSB_CCProfilingTimer_class->delProperty = JS_PropertyStub;
	JSB_CCProfilingTimer_class->getProperty = JS_PropertyStub;
	JSB_CCProfilingTimer_class->setProperty = JS_StrictPropertyStub;
	JSB_CCProfilingTimer_class->enumerate = JS_EnumerateStub;
	JSB_CCProfilingTimer_class->resolve = JS_ResolveStub;
	JSB_CCProfilingTimer_class->convert = JS_ConvertStub;
	JSB_CCProfilingTimer_class->finalize = JSB_CCProfilingTimer_finalize;
	JSB_CCProfilingTimer_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("reset", JSB_CCProfilingTimer_reset, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCProfilingTimer_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCProfilingTimer_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCProfilingTimer_class, JSB_CCProfilingTimer_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCProfilingTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCProfilingTimer_class, JSB_CCProfilingTimer_object, NULL);
	JSB_CCProfilingTimer *proxy = [[JSB_CCProfilingTimer alloc] initWithJSObject:jsobj class:[CCProfilingTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSequence
 */
#pragma mark - CCSequence

JSClass* JSB_CCSequence_class = NULL;
JSObject* JSB_CCSequence_object = NULL;
// Constructor
JSBool JSB_CCSequence_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSequence createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSequence_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSequence)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSequence_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSequence *proxy = [[JSB_CCSequence alloc] initWithJSObject:obj class:[CCSequence class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: CCSequence* (o)
JSBool JSB_CCSequence_actionOne_two__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSequence* ret_val;

	ret_val = [CCSequence actionOne:arg0 two:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCSequence* (o)
JSBool JSB_CCSequence_actionWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= JSB_jsvals_variadic_to_NSArray( cx, argvp, argc, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSequence* ret_val;

	ret_val = [CCSequence actionWithArray:(NSArray*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSB_CCSequence_initOne_two_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSequence *real = [(CCSequence*)[proxy.klass alloc] initOne:arg0 two:arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCSequence_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSequence_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSequence_class->name = name;
	JSB_CCSequence_class->addProperty = JS_PropertyStub;
	JSB_CCSequence_class->delProperty = JS_PropertyStub;
	JSB_CCSequence_class->getProperty = JS_PropertyStub;
	JSB_CCSequence_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSequence_class->enumerate = JS_EnumerateStub;
	JSB_CCSequence_class->resolve = JS_ResolveStub;
	JSB_CCSequence_class->convert = JS_ConvertStub;
	JSB_CCSequence_class->finalize = JSB_CCSequence_finalize;
	JSB_CCSequence_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initOneTwo", JSB_CCSequence_initOne_two_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSequence_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionOneTwo", JSB_CCSequence_actionOne_two__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCSequence_actionWithArray__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSequence_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCSequence_class, JSB_CCSequence_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSequence

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSequence_class, JSB_CCSequence_object, NULL);
	JSB_CCSequence *proxy = [[JSB_CCSequence alloc] initWithJSObject:jsobj class:[CCSequence class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticInOut
 */
#pragma mark - CCEaseElasticInOut

JSClass* JSB_CCEaseElasticInOut_class = NULL;
JSObject* JSB_CCEaseElasticInOut_object = NULL;
// Constructor
JSBool JSB_CCEaseElasticInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseElasticInOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseElasticInOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseElasticInOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseElasticInOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseElasticInOut *proxy = [[JSB_CCEaseElasticInOut alloc] initWithJSObject:obj class:[CCEaseElasticInOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseElasticInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseElasticInOut *real = (CCEaseElasticInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticInOut* (o)
JSBool JSB_CCEaseElasticInOut_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseElasticInOut* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticInOut actionWithAction:arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticInOut actionWithAction:arg0 period:(float)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseElasticInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseElasticInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseElasticInOut_class->name = name;
	JSB_CCEaseElasticInOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseElasticInOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseElasticInOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseElasticInOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseElasticInOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseElasticInOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseElasticInOut_class->convert = JS_ConvertStub;
	JSB_CCEaseElasticInOut_class->finalize = JSB_CCEaseElasticInOut_finalize;
	JSB_CCEaseElasticInOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseElasticInOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseElasticInOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseElasticInOut_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseElasticInOut_object = JS_InitClass(cx, globalObj, JSB_CCEaseElastic_object, JSB_CCEaseElasticInOut_class, JSB_CCEaseElasticInOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseElasticInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseElasticInOut_class, JSB_CCEaseElasticInOut_object, NULL);
	JSB_CCEaseElasticInOut *proxy = [[JSB_CCEaseElasticInOut alloc] initWithJSObject:jsobj class:[CCEaseElasticInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWaves
 */
#pragma mark - CCWaves

JSClass* JSB_CCWaves_class = NULL;
JSObject* JSB_CCWaves_object = NULL;
// Constructor
JSBool JSB_CCWaves_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCWaves createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCWaves_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCWaves)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCWaves_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCWaves *proxy = [[JSB_CCWaves alloc] initWithJSObject:obj class:[CCWaves class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float, BOOL, BOOL
// Ret value: CCWaves* (o)
JSBool JSB_CCWaves_actionWithDuration_size_waves_amplitude_horizontal_vertical__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; JSBool arg4; JSBool arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg4 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCWaves* ret_val;

	ret_val = [CCWaves actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3 horizontal:(BOOL)arg4 vertical:(BOOL)arg5  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWaves_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWaves *real = (CCWaves*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWaves_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWaves *real = (CCWaves*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float, BOOL, BOOL
// Ret value: None (None)
JSBool JSB_CCWaves_initWithDuration_size_waves_amplitude_horizontal_vertical_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; JSBool arg4; JSBool arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg4 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves *real = [(CCWaves*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3 horizontal:(BOOL)arg4 vertical:(BOOL)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWaves_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves *real = (CCWaves*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWaves_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves *real = (CCWaves*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCWaves_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCWaves_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCWaves_class->name = name;
	JSB_CCWaves_class->addProperty = JS_PropertyStub;
	JSB_CCWaves_class->delProperty = JS_PropertyStub;
	JSB_CCWaves_class->getProperty = JS_PropertyStub;
	JSB_CCWaves_class->setProperty = JS_StrictPropertyStub;
	JSB_CCWaves_class->enumerate = JS_EnumerateStub;
	JSB_CCWaves_class->resolve = JS_ResolveStub;
	JSB_CCWaves_class->convert = JS_ConvertStub;
	JSB_CCWaves_class->finalize = JSB_CCWaves_finalize;
	JSB_CCWaves_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCWaves_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCWaves_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizeWavesAmplitudeHorizontalVertical", JSB_CCWaves_initWithDuration_size_waves_amplitude_horizontal_vertical_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCWaves_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCWaves_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCWaves_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCWaves_actionWithDuration_size_waves_amplitude_horizontal_vertical__static, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCWaves_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCWaves_class, JSB_CCWaves_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCWaves

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCWaves_class, JSB_CCWaves_object, NULL);
	JSB_CCWaves *proxy = [[JSB_CCWaves alloc] initWithJSObject:jsobj class:[CCWaves class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipAngular
 */
#pragma mark - CCTransitionZoomFlipAngular

JSClass* JSB_CCTransitionZoomFlipAngular_class = NULL;
JSObject* JSB_CCTransitionZoomFlipAngular_object = NULL;
// Constructor
JSBool JSB_CCTransitionZoomFlipAngular_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionZoomFlipAngular createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionZoomFlipAngular_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionZoomFlipAngular)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionZoomFlipAngular_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionZoomFlipAngular *proxy = [[JSB_CCTransitionZoomFlipAngular alloc] initWithJSObject:obj class:[CCTransitionZoomFlipAngular class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionZoomFlipAngular_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionZoomFlipAngular *real = [(CCTransitionZoomFlipAngular*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipAngular* (o)
JSBool JSB_CCTransitionZoomFlipAngular_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 3 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionZoomFlipAngular* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionZoomFlipAngular transitionWithDuration:(ccTime)arg0 scene:arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionZoomFlipAngular transitionWithDuration:(ccTime)arg0 scene:arg1 orientation:(tOrientation)arg2  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipAngular* (o)
JSBool JSB_CCTransitionZoomFlipAngular_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionZoomFlipAngular* ret_val;

	ret_val = [CCTransitionZoomFlipAngular node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionZoomFlipAngular_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionZoomFlipAngular_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionZoomFlipAngular_class->name = name;
	JSB_CCTransitionZoomFlipAngular_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipAngular_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipAngular_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionZoomFlipAngular_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionZoomFlipAngular_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionZoomFlipAngular_class->resolve = JS_ResolveStub;
	JSB_CCTransitionZoomFlipAngular_class->convert = JS_ConvertStub;
	JSB_CCTransitionZoomFlipAngular_class->finalize = JSB_CCTransitionZoomFlipAngular_finalize;
	JSB_CCTransitionZoomFlipAngular_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionZoomFlipAngular_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionZoomFlipAngular_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionZoomFlipAngular_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionZoomFlipAngular_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionZoomFlipAngular_object = JS_InitClass(cx, globalObj, JSB_CCTransitionSceneOriented_object, JSB_CCTransitionZoomFlipAngular_class, JSB_CCTransitionZoomFlipAngular_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionZoomFlipAngular

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionZoomFlipAngular_class, JSB_CCTransitionZoomFlipAngular_object, NULL);
	JSB_CCTransitionZoomFlipAngular *proxy = [[JSB_CCTransitionZoomFlipAngular alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipAngular class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCClippingNode
 */
#pragma mark - CCClippingNode

JSClass* JSB_CCClippingNode_class = NULL;
JSObject* JSB_CCClippingNode_object = NULL;
// Constructor
JSBool JSB_CCClippingNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCClippingNode createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCClippingNode_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCClippingNode)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCClippingNode_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCClippingNode *proxy = [[JSB_CCClippingNode alloc] initWithJSObject:obj class:[CCClippingNode class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLfloat (d)
JSBool JSB_CCClippingNode_alphaThreshold(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLfloat ret_val;

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	ret_val = [real alphaThreshold ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: CCClippingNode* (o)
JSBool JSB_CCClippingNode_clippingNodeWithStencil__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 0 && argc <= 1 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCClippingNode* ret_val;

	if( argc == 0 ) {
		ret_val = [CCClippingNode clippingNode ];
	}
	else if( argc == 1 ) {
		ret_val = [CCClippingNode clippingNodeWithStencil:arg0  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: None (None)
JSBool JSB_CCClippingNode_initWithStencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 0 && argc <= 1 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	if (argc >= 1) {
		ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 0 ) {
		CCClippingNode *real = [(CCClippingNode*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else if( argc == 1 ) {
		CCClippingNode *real = [(CCClippingNode*)[proxy.klass alloc] initWithStencil:arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCClippingNode_inverted(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	ret_val = [real inverted ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSB_CCClippingNode_setAlphaThreshold_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	[real setAlphaThreshold:(GLfloat)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCClippingNode_setInverted_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	[real setInverted:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCClippingNode_setStencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	[real setStencil:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSB_CCClippingNode_stencil(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCNode* ret_val;

	CCClippingNode *real = (CCClippingNode*) [proxy realObj];
	ret_val = [real stencil ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCClippingNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCClippingNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCClippingNode_class->name = name;
	JSB_CCClippingNode_class->addProperty = JS_PropertyStub;
	JSB_CCClippingNode_class->delProperty = JS_PropertyStub;
	JSB_CCClippingNode_class->getProperty = JS_PropertyStub;
	JSB_CCClippingNode_class->setProperty = JS_StrictPropertyStub;
	JSB_CCClippingNode_class->enumerate = JS_EnumerateStub;
	JSB_CCClippingNode_class->resolve = JS_ResolveStub;
	JSB_CCClippingNode_class->convert = JS_ConvertStub;
	JSB_CCClippingNode_class->finalize = JSB_CCClippingNode_finalize;
	JSB_CCClippingNode_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAlphaThreshold", JSB_CCClippingNode_alphaThreshold, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCClippingNode_initWithStencil_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInverted", JSB_CCClippingNode_inverted, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAlphaThreshold", JSB_CCClippingNode_setAlphaThreshold_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setInverted", JSB_CCClippingNode_setInverted_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setStencil", JSB_CCClippingNode_setStencil_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getStencil", JSB_CCClippingNode_stencil, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCClippingNode_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCClippingNode_clippingNodeWithStencil__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCClippingNode_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCClippingNode_class, JSB_CCClippingNode_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCClippingNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCClippingNode_class, JSB_CCClippingNode_object, NULL);
	JSB_CCClippingNode *proxy = [[JSB_CCClippingNode alloc] initWithJSObject:jsobj class:[CCClippingNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTintBy
 */
#pragma mark - CCTintBy

JSClass* JSB_CCTintBy_class = NULL;
JSObject* JSB_CCTintBy_object = NULL;
// Constructor
JSBool JSB_CCTintBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTintBy createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTintBy_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTintBy)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTintBy_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTintBy *proxy = [[JSB_CCTintBy alloc] initWithJSObject:obj class:[CCTintBy class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, GLshort, GLshort, GLshort
// Ret value: CCTintBy* (o)
JSBool JSB_CCTintBy_actionWithDuration_red_green_blue__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTintBy* ret_val;

	ret_val = [CCTintBy actionWithDuration:(ccTime)arg0 red:(GLshort)arg1 green:(GLshort)arg2 blue:(GLshort)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, GLshort, GLshort, GLshort
// Ret value: None (None)
JSBool JSB_CCTintBy_initWithDuration_red_green_blue_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint16( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTintBy *real = [(CCTintBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 red:(GLshort)arg1 green:(GLshort)arg2 blue:(GLshort)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCTintBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTintBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTintBy_class->name = name;
	JSB_CCTintBy_class->addProperty = JS_PropertyStub;
	JSB_CCTintBy_class->delProperty = JS_PropertyStub;
	JSB_CCTintBy_class->getProperty = JS_PropertyStub;
	JSB_CCTintBy_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTintBy_class->enumerate = JS_EnumerateStub;
	JSB_CCTintBy_class->resolve = JS_ResolveStub;
	JSB_CCTintBy_class->convert = JS_ConvertStub;
	JSB_CCTintBy_class->finalize = JSB_CCTintBy_finalize;
	JSB_CCTintBy_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRedGreenBlue", JSB_CCTintBy_initWithDuration_red_green_blue_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTintBy_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTintBy_actionWithDuration_red_green_blue__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTintBy_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCTintBy_class, JSB_CCTintBy_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTintBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTintBy_class, JSB_CCTintBy_object, NULL);
	JSB_CCTintBy *proxy = [[JSB_CCTintBy alloc] initWithJSObject:jsobj class:[CCTintBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBezierTo
 */
#pragma mark - CCBezierTo

JSClass* JSB_CCBezierTo_class = NULL;
JSObject* JSB_CCBezierTo_object = NULL;
// Constructor
JSBool JSB_CCBezierTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCBezierTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCBezierTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCBezierTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCBezierTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCBezierTo *proxy = [[JSB_CCBezierTo alloc] initWithJSObject:obj class:[CCBezierTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCBezierTo_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCBezierTo *real = (CCBezierTo*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCBezierTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCBezierTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCBezierTo_class->name = name;
	JSB_CCBezierTo_class->addProperty = JS_PropertyStub;
	JSB_CCBezierTo_class->delProperty = JS_PropertyStub;
	JSB_CCBezierTo_class->getProperty = JS_PropertyStub;
	JSB_CCBezierTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCBezierTo_class->enumerate = JS_EnumerateStub;
	JSB_CCBezierTo_class->resolve = JS_ResolveStub;
	JSB_CCBezierTo_class->convert = JS_ConvertStub;
	JSB_CCBezierTo_class->finalize = JSB_CCBezierTo_finalize;
	JSB_CCBezierTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCBezierTo_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCBezierTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCBezierTo_actionWithDuration_bezier__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCBezierTo_object = JS_InitClass(cx, globalObj, JSB_CCBezierBy_object, JSB_CCBezierTo_class, JSB_CCBezierTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCBezierTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCBezierTo_class, JSB_CCBezierTo_object, NULL);
	JSB_CCBezierTo *proxy = [[JSB_CCBezierTo alloc] initWithJSObject:jsobj class:[CCBezierTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDeccelAmplitude
 */
#pragma mark - CCDeccelAmplitude

JSClass* JSB_CCDeccelAmplitude_class = NULL;
JSObject* JSB_CCDeccelAmplitude_object = NULL;
// Constructor
JSBool JSB_CCDeccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCDeccelAmplitude createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCDeccelAmplitude_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCDeccelAmplitude)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCDeccelAmplitude_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCDeccelAmplitude *proxy = [[JSB_CCDeccelAmplitude alloc] initWithJSObject:obj class:[CCDeccelAmplitude class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: CCDeccelAmplitude* (o)
JSBool JSB_CCDeccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCDeccelAmplitude* ret_val;

	ret_val = [CCDeccelAmplitude actionWithAction:arg0 duration:(ccTime)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSB_CCDeccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDeccelAmplitude *real = [(CCDeccelAmplitude*)[proxy.klass alloc] initWithAction:arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCDeccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCDeccelAmplitude *real = (CCDeccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCDeccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCDeccelAmplitude *real = (CCDeccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCDeccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCDeccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCDeccelAmplitude_class->name = name;
	JSB_CCDeccelAmplitude_class->addProperty = JS_PropertyStub;
	JSB_CCDeccelAmplitude_class->delProperty = JS_PropertyStub;
	JSB_CCDeccelAmplitude_class->getProperty = JS_PropertyStub;
	JSB_CCDeccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSB_CCDeccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSB_CCDeccelAmplitude_class->resolve = JS_ResolveStub;
	JSB_CCDeccelAmplitude_class->convert = JS_ConvertStub;
	JSB_CCDeccelAmplitude_class->finalize = JSB_CCDeccelAmplitude_finalize;
	JSB_CCDeccelAmplitude_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSB_CCDeccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRate", JSB_CCDeccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_CCDeccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCDeccelAmplitude_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSB_CCDeccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCDeccelAmplitude_object = JS_InitClass(cx, globalObj, JSB_CCActionInterval_object, JSB_CCDeccelAmplitude_class, JSB_CCDeccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCDeccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCDeccelAmplitude_class, JSB_CCDeccelAmplitude_object, NULL);
	JSB_CCDeccelAmplitude *proxy = [[JSB_CCDeccelAmplitude alloc] initWithJSObject:jsobj class:[CCDeccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLens3D
 */
#pragma mark - CCLens3D

JSClass* JSB_CCLens3D_class = NULL;
JSObject* JSB_CCLens3D_object = NULL;
// Constructor
JSBool JSB_CCLens3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCLens3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCLens3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCLens3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCLens3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCLens3D *proxy = [[JSB_CCLens3D alloc] initWithJSObject:obj class:[CCLens3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, float
// Ret value: CCLens3D* (o)
JSBool JSB_CCLens3D_actionWithDuration_size_position_radius__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCLens3D* ret_val;

	ret_val = [CCLens3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 radius:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, float
// Ret value: None (None)
JSBool JSB_CCLens3D_initWithDuration_size_position_radius_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLens3D *real = [(CCLens3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 radius:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCLens3D_lensEffect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	ret_val = [real lensEffect ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCLens3D_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	ret_val = [real position ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCLens3D_setLensEffect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	[real setLensEffect:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCLens3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCLens3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCLens3D_class->name = name;
	JSB_CCLens3D_class->addProperty = JS_PropertyStub;
	JSB_CCLens3D_class->delProperty = JS_PropertyStub;
	JSB_CCLens3D_class->getProperty = JS_PropertyStub;
	JSB_CCLens3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCLens3D_class->enumerate = JS_EnumerateStub;
	JSB_CCLens3D_class->resolve = JS_ResolveStub;
	JSB_CCLens3D_class->convert = JS_ConvertStub;
	JSB_CCLens3D_class->finalize = JSB_CCLens3D_finalize;
	JSB_CCLens3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizePositionRadius", JSB_CCLens3D_initWithDuration_size_position_radius_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getLensEffect", JSB_CCLens3D_lensEffect, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSB_CCLens3D_position, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setLensEffect", JSB_CCLens3D_setLensEffect_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSB_CCLens3D_setPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCLens3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCLens3D_actionWithDuration_size_position_radius__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCLens3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCLens3D_class, JSB_CCLens3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCLens3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCLens3D_class, JSB_CCLens3D_object, NULL);
	JSB_CCLens3D *proxy = [[JSB_CCLens3D alloc] initWithJSObject:jsobj class:[CCLens3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWaves3D
 */
#pragma mark - CCWaves3D

JSClass* JSB_CCWaves3D_class = NULL;
JSObject* JSB_CCWaves3D_object = NULL;
// Constructor
JSBool JSB_CCWaves3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCWaves3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCWaves3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCWaves3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCWaves3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCWaves3D *proxy = [[JSB_CCWaves3D alloc] initWithJSObject:obj class:[CCWaves3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: CCWaves3D* (o)
JSBool JSB_CCWaves3D_actionWithDuration_size_waves_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCWaves3D* ret_val;

	ret_val = [CCWaves3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWaves3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWaves3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: None (None)
JSBool JSB_CCWaves3D_initWithDuration_size_waves_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves3D *real = [(CCWaves3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWaves3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWaves3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCWaves3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCWaves3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCWaves3D_class->name = name;
	JSB_CCWaves3D_class->addProperty = JS_PropertyStub;
	JSB_CCWaves3D_class->delProperty = JS_PropertyStub;
	JSB_CCWaves3D_class->getProperty = JS_PropertyStub;
	JSB_CCWaves3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCWaves3D_class->enumerate = JS_EnumerateStub;
	JSB_CCWaves3D_class->resolve = JS_ResolveStub;
	JSB_CCWaves3D_class->convert = JS_ConvertStub;
	JSB_CCWaves3D_class->finalize = JSB_CCWaves3D_finalize;
	JSB_CCWaves3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCWaves3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCWaves3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizeWavesAmplitude", JSB_CCWaves3D_initWithDuration_size_waves_amplitude_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCWaves3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCWaves3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCWaves3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCWaves3D_actionWithDuration_size_waves_amplitude__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCWaves3D_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCWaves3D_class, JSB_CCWaves3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCWaves3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCWaves3D_class, JSB_CCWaves3D_object, NULL);
	JSB_CCWaves3D *proxy = [[JSB_CCWaves3D alloc] initWithJSObject:jsobj class:[CCWaves3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpTo
 */
#pragma mark - CCJumpTo

JSClass* JSB_CCJumpTo_class = NULL;
JSObject* JSB_CCJumpTo_object = NULL;
// Constructor
JSBool JSB_CCJumpTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCJumpTo createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCJumpTo_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCJumpTo)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCJumpTo_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCJumpTo *proxy = [[JSB_CCJumpTo alloc] initWithJSObject:obj class:[CCJumpTo class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSB_CCJumpTo_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCJumpTo *real = (CCJumpTo*) [proxy realObj];
	[real startWithTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: CCJumpTo* (o)
JSBool JSB_CCJumpTo_actionWithDuration_position_height_jumps__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCJumpTo* ret_val;

	ret_val = [CCJumpTo actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCJumpTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCJumpTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCJumpTo_class->name = name;
	JSB_CCJumpTo_class->addProperty = JS_PropertyStub;
	JSB_CCJumpTo_class->delProperty = JS_PropertyStub;
	JSB_CCJumpTo_class->getProperty = JS_PropertyStub;
	JSB_CCJumpTo_class->setProperty = JS_StrictPropertyStub;
	JSB_CCJumpTo_class->enumerate = JS_EnumerateStub;
	JSB_CCJumpTo_class->resolve = JS_ResolveStub;
	JSB_CCJumpTo_class->convert = JS_ConvertStub;
	JSB_CCJumpTo_class->finalize = JSB_CCJumpTo_finalize;
	JSB_CCJumpTo_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSB_CCJumpTo_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCJumpTo_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCJumpTo_actionWithDuration_position_height_jumps__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCJumpTo_object = JS_InitClass(cx, globalObj, JSB_CCJumpBy_object, JSB_CCJumpTo_class, JSB_CCJumpTo_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCJumpTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCJumpTo_class, JSB_CCJumpTo_object, NULL);
	JSB_CCJumpTo *proxy = [[JSB_CCJumpTo alloc] initWithJSObject:jsobj class:[CCJumpTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackOut
 */
#pragma mark - CCEaseBackOut

JSClass* JSB_CCEaseBackOut_class = NULL;
JSObject* JSB_CCEaseBackOut_object = NULL;
// Constructor
JSBool JSB_CCEaseBackOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseBackOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseBackOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseBackOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseBackOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseBackOut *proxy = [[JSB_CCEaseBackOut alloc] initWithJSObject:obj class:[CCEaseBackOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseBackOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseBackOut *real = (CCEaseBackOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackOut* (o)
JSBool JSB_CCEaseBackOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseBackOut* ret_val;

	ret_val = [CCEaseBackOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseBackOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseBackOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseBackOut_class->name = name;
	JSB_CCEaseBackOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseBackOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseBackOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseBackOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseBackOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseBackOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseBackOut_class->convert = JS_ConvertStub;
	JSB_CCEaseBackOut_class->finalize = JSB_CCEaseBackOut_finalize;
	JSB_CCEaseBackOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseBackOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseBackOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseBackOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseBackOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseBackOut_class, JSB_CCEaseBackOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseBackOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseBackOut_class, JSB_CCEaseBackOut_object, NULL);
	JSB_CCEaseBackOut *proxy = [[JSB_CCEaseBackOut alloc] initWithJSObject:jsobj class:[CCEaseBackOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEasePolynomialOut
 */
#pragma mark - CCEasePolynomialOut

JSClass* JSB_CCEasePolynomialOut_class = NULL;
JSObject* JSB_CCEasePolynomialOut_object = NULL;
// Constructor
JSBool JSB_CCEasePolynomialOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEasePolynomialOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEasePolynomialOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEasePolynomialOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEasePolynomialOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEasePolynomialOut *proxy = [[JSB_CCEasePolynomialOut alloc] initWithJSObject:obj class:[CCEasePolynomialOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEasePolynomialOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEasePolynomialOut *real = (CCEasePolynomialOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEasePolynomialOut* (o)
JSBool JSB_CCEasePolynomialOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEasePolynomialOut* ret_val;

	ret_val = [CCEasePolynomialOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEasePolynomialOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEasePolynomialOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEasePolynomialOut_class->name = name;
	JSB_CCEasePolynomialOut_class->addProperty = JS_PropertyStub;
	JSB_CCEasePolynomialOut_class->delProperty = JS_PropertyStub;
	JSB_CCEasePolynomialOut_class->getProperty = JS_PropertyStub;
	JSB_CCEasePolynomialOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEasePolynomialOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEasePolynomialOut_class->resolve = JS_ResolveStub;
	JSB_CCEasePolynomialOut_class->convert = JS_ConvertStub;
	JSB_CCEasePolynomialOut_class->finalize = JSB_CCEasePolynomialOut_finalize;
	JSB_CCEasePolynomialOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEasePolynomialOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEasePolynomialOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEasePolynomialOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEasePolynomialOut_object = JS_InitClass(cx, globalObj, JSB_CCEasePolynomial_object, JSB_CCEasePolynomialOut_class, JSB_CCEasePolynomialOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEasePolynomialOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEasePolynomialOut_class, JSB_CCEasePolynomialOut_object, NULL);
	JSB_CCEasePolynomialOut *proxy = [[JSB_CCEasePolynomialOut alloc] initWithJSObject:jsobj class:[CCEasePolynomialOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWavesTiles3D
 */
#pragma mark - CCWavesTiles3D

JSClass* JSB_CCWavesTiles3D_class = NULL;
JSObject* JSB_CCWavesTiles3D_object = NULL;
// Constructor
JSBool JSB_CCWavesTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCWavesTiles3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCWavesTiles3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCWavesTiles3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCWavesTiles3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCWavesTiles3D *proxy = [[JSB_CCWavesTiles3D alloc] initWithJSObject:obj class:[CCWavesTiles3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: CCWavesTiles3D* (o)
JSBool JSB_CCWavesTiles3D_actionWithDuration_size_waves_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCWavesTiles3D* ret_val;

	ret_val = [CCWavesTiles3D actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWavesTiles3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCWavesTiles3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, NSUInteger, float
// Ret value: None (None)
JSBool JSB_CCWavesTiles3D_initWithDuration_size_waves_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWavesTiles3D *real = [(CCWavesTiles3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 waves:(NSUInteger)arg2 amplitude:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWavesTiles3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCWavesTiles3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCWavesTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCWavesTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCWavesTiles3D_class->name = name;
	JSB_CCWavesTiles3D_class->addProperty = JS_PropertyStub;
	JSB_CCWavesTiles3D_class->delProperty = JS_PropertyStub;
	JSB_CCWavesTiles3D_class->getProperty = JS_PropertyStub;
	JSB_CCWavesTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCWavesTiles3D_class->enumerate = JS_EnumerateStub;
	JSB_CCWavesTiles3D_class->resolve = JS_ResolveStub;
	JSB_CCWavesTiles3D_class->convert = JS_ConvertStub;
	JSB_CCWavesTiles3D_class->finalize = JSB_CCWavesTiles3D_finalize;
	JSB_CCWavesTiles3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCWavesTiles3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCWavesTiles3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizeWavesAmplitude", JSB_CCWavesTiles3D_initWithDuration_size_waves_amplitude_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCWavesTiles3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCWavesTiles3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCWavesTiles3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCWavesTiles3D_actionWithDuration_size_waves_amplitude__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCWavesTiles3D_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCWavesTiles3D_class, JSB_CCWavesTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCWavesTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCWavesTiles3D_class, JSB_CCWavesTiles3D_object, NULL);
	JSB_CCWavesTiles3D *proxy = [[JSB_CCWavesTiles3D alloc] initWithJSObject:jsobj class:[CCWavesTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTurnOffTiles
 */
#pragma mark - CCTurnOffTiles

JSClass* JSB_CCTurnOffTiles_class = NULL;
JSObject* JSB_CCTurnOffTiles_object = NULL;
// Constructor
JSBool JSB_CCTurnOffTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTurnOffTiles createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTurnOffTiles_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTurnOffTiles)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTurnOffTiles_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTurnOffTiles *proxy = [[JSB_CCTurnOffTiles alloc] initWithJSObject:obj class:[CCTurnOffTiles class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, unsigned int
// Ret value: CCTurnOffTiles* (o)
JSBool JSB_CCTurnOffTiles_actionWithDuration_size_seed__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTurnOffTiles* ret_val;

	ret_val = [CCTurnOffTiles actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 seed:(unsigned int)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, unsigned int
// Ret value: None (None)
JSBool JSB_CCTurnOffTiles_initWithDuration_size_seed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; uint32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTurnOffTiles *real = [(CCTurnOffTiles*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 seed:(unsigned int)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCTurnOffTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTurnOffTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTurnOffTiles_class->name = name;
	JSB_CCTurnOffTiles_class->addProperty = JS_PropertyStub;
	JSB_CCTurnOffTiles_class->delProperty = JS_PropertyStub;
	JSB_CCTurnOffTiles_class->getProperty = JS_PropertyStub;
	JSB_CCTurnOffTiles_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTurnOffTiles_class->enumerate = JS_EnumerateStub;
	JSB_CCTurnOffTiles_class->resolve = JS_ResolveStub;
	JSB_CCTurnOffTiles_class->convert = JS_ConvertStub;
	JSB_CCTurnOffTiles_class->finalize = JSB_CCTurnOffTiles_finalize;
	JSB_CCTurnOffTiles_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSizeSeed", JSB_CCTurnOffTiles_initWithDuration_size_seed_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTurnOffTiles_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTurnOffTiles_actionWithDuration_size_seed__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTurnOffTiles_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCTurnOffTiles_class, JSB_CCTurnOffTiles_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTurnOffTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTurnOffTiles_class, JSB_CCTurnOffTiles_object, NULL);
	JSB_CCTurnOffTiles *proxy = [[JSB_CCTurnOffTiles alloc] initWithJSObject:jsobj class:[CCTurnOffTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionJumpZoom
 */
#pragma mark - CCTransitionJumpZoom

JSClass* JSB_CCTransitionJumpZoom_class = NULL;
JSObject* JSB_CCTransitionJumpZoom_object = NULL;
// Constructor
JSBool JSB_CCTransitionJumpZoom_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionJumpZoom createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionJumpZoom_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionJumpZoom)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionJumpZoom_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionJumpZoom *proxy = [[JSB_CCTransitionJumpZoom alloc] initWithJSObject:obj class:[CCTransitionJumpZoom class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSB_CCTransitionJumpZoom_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCTransitionJumpZoom *real = [(CCTransitionJumpZoom*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionJumpZoom* (o)
JSBool JSB_CCTransitionJumpZoom_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionJumpZoom* ret_val;

	ret_val = [CCTransitionJumpZoom transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionJumpZoom* (o)
JSBool JSB_CCTransitionJumpZoom_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionJumpZoom* ret_val;

	ret_val = [CCTransitionJumpZoom node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionJumpZoom_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionJumpZoom_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionJumpZoom_class->name = name;
	JSB_CCTransitionJumpZoom_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionJumpZoom_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionJumpZoom_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionJumpZoom_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionJumpZoom_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionJumpZoom_class->resolve = JS_ResolveStub;
	JSB_CCTransitionJumpZoom_class->convert = JS_ConvertStub;
	JSB_CCTransitionJumpZoom_class->finalize = JSB_CCTransitionJumpZoom_finalize;
	JSB_CCTransitionJumpZoom_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSB_CCTransitionJumpZoom_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionJumpZoom_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionJumpZoom_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionJumpZoom_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionJumpZoom_object = JS_InitClass(cx, globalObj, JSB_CCTransitionScene_object, JSB_CCTransitionJumpZoom_class, JSB_CCTransitionJumpZoom_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionJumpZoom

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionJumpZoom_class, JSB_CCTransitionJumpZoom_object, NULL);
	JSB_CCTransitionJumpZoom *proxy = [[JSB_CCTransitionJumpZoom alloc] initWithJSObject:jsobj class:[CCTransitionJumpZoom class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSplitCols
 */
#pragma mark - CCSplitCols

JSClass* JSB_CCSplitCols_class = NULL;
JSObject* JSB_CCSplitCols_object = NULL;
// Constructor
JSBool JSB_CCSplitCols_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSplitCols createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSplitCols_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSplitCols)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSplitCols_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSplitCols *proxy = [[JSB_CCSplitCols alloc] initWithJSObject:obj class:[CCSplitCols class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: CCSplitCols* (o)
JSBool JSB_CCSplitCols_actionWithDuration_cols__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSplitCols* ret_val;

	ret_val = [CCSplitCols actionWithDuration:(ccTime)arg0 cols:(NSUInteger)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: None (None)
JSBool JSB_CCSplitCols_initWithDuration_cols_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSplitCols *real = [(CCSplitCols*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 cols:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

void JSB_CCSplitCols_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSplitCols_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSplitCols_class->name = name;
	JSB_CCSplitCols_class->addProperty = JS_PropertyStub;
	JSB_CCSplitCols_class->delProperty = JS_PropertyStub;
	JSB_CCSplitCols_class->getProperty = JS_PropertyStub;
	JSB_CCSplitCols_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSplitCols_class->enumerate = JS_EnumerateStub;
	JSB_CCSplitCols_class->resolve = JS_ResolveStub;
	JSB_CCSplitCols_class->convert = JS_ConvertStub;
	JSB_CCSplitCols_class->finalize = JSB_CCSplitCols_finalize;
	JSB_CCSplitCols_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationCols", JSB_CCSplitCols_initWithDuration_cols_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSplitCols_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCSplitCols_actionWithDuration_cols__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSplitCols_object = JS_InitClass(cx, globalObj, JSB_CCTiledGrid3DAction_object, JSB_CCSplitCols_class, JSB_CCSplitCols_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSplitCols

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSplitCols_class, JSB_CCSplitCols_object, NULL);
	JSB_CCSplitCols *proxy = [[JSB_CCSplitCols alloc] initWithJSObject:jsobj class:[CCSplitCols class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeUp
 */
#pragma mark - CCTransitionFadeUp

JSClass* JSB_CCTransitionFadeUp_class = NULL;
JSObject* JSB_CCTransitionFadeUp_object = NULL;
// Constructor
JSBool JSB_CCTransitionFadeUp_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionFadeUp createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionFadeUp_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionFadeUp)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionFadeUp_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionFadeUp *proxy = [[JSB_CCTransitionFadeUp alloc] initWithJSObject:obj class:[CCTransitionFadeUp class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCActionInterval* (o)
JSBool JSB_CCTransitionFadeUp_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCActionInterval* ret_val;

	CCTransitionFadeUp *real = (CCTransitionFadeUp*) [proxy realObj];
	ret_val = [real actionWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeUp* (o)
JSBool JSB_CCTransitionFadeUp_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionFadeUp* ret_val;

	ret_val = [CCTransitionFadeUp transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeUp* (o)
JSBool JSB_CCTransitionFadeUp_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionFadeUp* ret_val;

	ret_val = [CCTransitionFadeUp node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionFadeUp_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionFadeUp_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionFadeUp_class->name = name;
	JSB_CCTransitionFadeUp_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionFadeUp_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionFadeUp_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionFadeUp_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionFadeUp_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionFadeUp_class->resolve = JS_ResolveStub;
	JSB_CCTransitionFadeUp_class->convert = JS_ConvertStub;
	JSB_CCTransitionFadeUp_class->finalize = JSB_CCTransitionFadeUp_finalize;
	JSB_CCTransitionFadeUp_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSB_CCTransitionFadeUp_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionFadeUp_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionFadeUp_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionFadeUp_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionFadeUp_object = JS_InitClass(cx, globalObj, JSB_CCTransitionFadeTR_object, JSB_CCTransitionFadeUp_class, JSB_CCTransitionFadeUp_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionFadeUp

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionFadeUp_class, JSB_CCTransitionFadeUp_object, NULL);
	JSB_CCTransitionFadeUp *proxy = [[JSB_CCTransitionFadeUp alloc] initWithJSObject:jsobj class:[CCTransitionFadeUp class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTimerTargetSelector
 */
#pragma mark - CCTimerTargetSelector

JSClass* JSB_CCTimerTargetSelector_class = NULL;
JSObject* JSB_CCTimerTargetSelector_object = NULL;
// Constructor
JSBool JSB_CCTimerTargetSelector_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTimerTargetSelector createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTimerTargetSelector_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTimerTargetSelector)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTimerTargetSelector_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTimerTargetSelector *proxy = [[JSB_CCTimerTargetSelector alloc] initWithJSObject:obj class:[CCTimerTargetSelector class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

void JSB_CCTimerTargetSelector_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTimerTargetSelector_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTimerTargetSelector_class->name = name;
	JSB_CCTimerTargetSelector_class->addProperty = JS_PropertyStub;
	JSB_CCTimerTargetSelector_class->delProperty = JS_PropertyStub;
	JSB_CCTimerTargetSelector_class->getProperty = JS_PropertyStub;
	JSB_CCTimerTargetSelector_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTimerTargetSelector_class->enumerate = JS_EnumerateStub;
	JSB_CCTimerTargetSelector_class->resolve = JS_ResolveStub;
	JSB_CCTimerTargetSelector_class->convert = JS_ConvertStub;
	JSB_CCTimerTargetSelector_class->finalize = JSB_CCTimerTargetSelector_finalize;
	JSB_CCTimerTargetSelector_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("ctor", JSB_CCTimerTargetSelector_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCTimerTargetSelector_object = JS_InitClass(cx, globalObj, JSB_CCTimer_object, JSB_CCTimerTargetSelector_class, JSB_CCTimerTargetSelector_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTimerTargetSelector

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTimerTargetSelector_class, JSB_CCTimerTargetSelector_object, NULL);
	JSB_CCTimerTargetSelector *proxy = [[JSB_CCTimerTargetSelector alloc] initWithJSObject:jsobj class:[CCTimerTargetSelector class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRenderTexture
 */
#pragma mark - CCRenderTexture

JSClass* JSB_CCRenderTexture_class = NULL;
JSObject* JSB_CCRenderTexture_object = NULL;
// Constructor
JSBool JSB_CCRenderTexture_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCRenderTexture createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCRenderTexture_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCRenderTexture)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCRenderTexture_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCRenderTexture *proxy = [[JSB_CCRenderTexture alloc] initWithJSObject:obj class:[CCRenderTexture class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCRenderTexture_autoDraw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real autoDraw ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCRenderTexture_begin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real begin ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float, float
// Ret value: void (None)
JSBool JSB_CCRenderTexture_beginWithClear_g_b_a_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float, float, float
// Ret value: void (None)
JSBool JSB_CCRenderTexture_beginWithClear_g_b_a_depth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3 depth:(float)arg4  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float, float, float, int
// Ret value: void (None)
JSBool JSB_CCRenderTexture_beginWithClear_g_b_a_depth_stencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; int32_t arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3 depth:(float)arg4 stencil:(int)arg5  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float, float, float, float
// Ret value: void (None)
JSBool JSB_CCRenderTexture_clear_g_b_a_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F (N/A)
JSBool JSB_CCRenderTexture_clearColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real clearColor ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_ccColor4F( cx, (ccColor4F)ret_val ));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLclampf (d)
JSBool JSB_CCRenderTexture_clearDepth(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLclampf ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real clearDepth ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCRenderTexture_clearDepth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clearDepth:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLbitfield (u)
JSBool JSB_CCRenderTexture_clearFlags(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLbitfield ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real clearFlags ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSB_CCRenderTexture_clearStencil(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLint ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real clearStencil ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSB_CCRenderTexture_clearStencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clearStencil:(int)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCRenderTexture_end(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real end ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat
// Ret value: None (None)
JSBool JSB_CCRenderTexture_initWithWidth_height_pixelFormat_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = [(CCRenderTexture*)[proxy.klass alloc] initWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat, GLuint
// Ret value: None (None)
JSBool JSB_CCRenderTexture_initWithWidth_height_pixelFormat_depthStencilFormat_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; uint32_t arg3; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = [(CCRenderTexture*)[proxy.klass alloc] initWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2 depthStencilFormat:(GLuint)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat, GLuint
// Ret value: CCRenderTexture* (o)
JSBool JSB_CCRenderTexture_renderTextureWithWidth_height_pixelFormat_depthStencilFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc >= 2 && argc <= 4 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; uint32_t arg3; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCRenderTexture* ret_val;

	if( argc == 2 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2  ];
	}
	else if( argc == 4 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2 depthStencilFormat:(GLuint)arg3  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, tCCImageFormat
// Ret value: BOOL (b)
JSBool JSB_CCRenderTexture_saveToFile_format_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; int32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	BOOL ret_val;

	if( argc == 1 ) {
		CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real saveToFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real saveToFile:(NSString*)arg0 format:(tCCImageFormat)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setAutoDraw_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setAutoDraw:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setClearColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 

	ok &= JSB_jsval_to_ccColor4F( cx, *argvp++, (ccColor4F*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setClearColor:(ccColor4F)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLclampf
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setClearDepth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setClearDepth:(GLclampf)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLbitfield
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setClearFlags_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setClearFlags:(GLbitfield)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLint
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setClearStencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setClearStencil:(GLint)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSB_CCRenderTexture_setSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setSprite:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSprite* (o)
JSBool JSB_CCRenderTexture_sprite(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSprite* ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real sprite ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCRenderTexture_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCRenderTexture_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCRenderTexture_class->name = name;
	JSB_CCRenderTexture_class->addProperty = JS_PropertyStub;
	JSB_CCRenderTexture_class->delProperty = JS_PropertyStub;
	JSB_CCRenderTexture_class->getProperty = JS_PropertyStub;
	JSB_CCRenderTexture_class->setProperty = JS_StrictPropertyStub;
	JSB_CCRenderTexture_class->enumerate = JS_EnumerateStub;
	JSB_CCRenderTexture_class->resolve = JS_ResolveStub;
	JSB_CCRenderTexture_class->convert = JS_ConvertStub;
	JSB_CCRenderTexture_class->finalize = JSB_CCRenderTexture_finalize;
	JSB_CCRenderTexture_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAutoDraw", JSB_CCRenderTexture_autoDraw, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("begin", JSB_CCRenderTexture_begin, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBA", JSB_CCRenderTexture_beginWithClear_g_b_a_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBADepth", JSB_CCRenderTexture_beginWithClear_g_b_a_depth_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBADepthStencil", JSB_CCRenderTexture_beginWithClear_g_b_a_depth_stencil_, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("clear", JSB_CCRenderTexture_clear_g_b_a_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getClearColor", JSB_CCRenderTexture_clearColor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getClearDepth", JSB_CCRenderTexture_clearDepth, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("clearDepth", JSB_CCRenderTexture_clearDepth_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getClearFlags", JSB_CCRenderTexture_clearFlags, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getClearStencil", JSB_CCRenderTexture_clearStencil, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("clearStencil", JSB_CCRenderTexture_clearStencil_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("end", JSB_CCRenderTexture_end, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithWidthHeightPixelFormat", JSB_CCRenderTexture_initWithWidth_height_pixelFormat_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithWidthHeightPixelFormatDepthStencilFormat", JSB_CCRenderTexture_initWithWidth_height_pixelFormat_depthStencilFormat_, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("saveToFile", JSB_CCRenderTexture_saveToFile_format_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAutoDraw", JSB_CCRenderTexture_setAutoDraw_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setClearColor", JSB_CCRenderTexture_setClearColor_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setClearDepth", JSB_CCRenderTexture_setClearDepth_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setClearFlags", JSB_CCRenderTexture_setClearFlags_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setClearStencil", JSB_CCRenderTexture_setClearStencil_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setSprite", JSB_CCRenderTexture_setSprite_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSprite", JSB_CCRenderTexture_sprite, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCRenderTexture_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCRenderTexture_renderTextureWithWidth_height_pixelFormat_depthStencilFormat__static, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCRenderTexture_object = JS_InitClass(cx, globalObj, JSB_CCNode_object, JSB_CCRenderTexture_class, JSB_CCRenderTexture_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCRenderTexture

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCRenderTexture_class, JSB_CCRenderTexture_object, NULL);
	JSB_CCRenderTexture *proxy = [[JSB_CCRenderTexture alloc] initWithJSObject:jsobj class:[CCRenderTexture class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTwirl
 */
#pragma mark - CCTwirl

JSClass* JSB_CCTwirl_class = NULL;
JSObject* JSB_CCTwirl_object = NULL;
// Constructor
JSBool JSB_CCTwirl_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTwirl createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTwirl_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTwirl)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTwirl_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTwirl *proxy = [[JSB_CCTwirl alloc] initWithJSObject:obj class:[CCTwirl class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, NSUInteger, float
// Ret value: CCTwirl* (o)
JSBool JSB_CCTwirl_actionWithDuration_size_position_twirls_amplitude__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; uint32_t arg3; double arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTwirl* ret_val;

	ret_val = [CCTwirl actionWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 twirls:(NSUInteger)arg3 amplitude:(float)arg4  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCTwirl_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real amplitude ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSB_CCTwirl_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	float ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real amplitudeRate ];

	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CGSize, CGPoint, NSUInteger, float
// Ret value: None (None)
JSBool JSB_CCTwirl_initWithDuration_size_position_twirls_amplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGSize arg1; CGPoint arg2; uint32_t arg3; double arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTwirl *real = [(CCTwirl*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 size:(CGSize)arg1 position:(CGPoint)arg2 twirls:(NSUInteger)arg3 amplitude:(float)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint (N/A)
JSBool JSB_CCTwirl_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real position ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_CGPoint( cx, (CGPoint)ret_val ));

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCTwirl_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSB_CCTwirl_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCTwirl_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTwirl_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTwirl_class->name = name;
	JSB_CCTwirl_class->addProperty = JS_PropertyStub;
	JSB_CCTwirl_class->delProperty = JS_PropertyStub;
	JSB_CCTwirl_class->getProperty = JS_PropertyStub;
	JSB_CCTwirl_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTwirl_class->enumerate = JS_EnumerateStub;
	JSB_CCTwirl_class->resolve = JS_ResolveStub;
	JSB_CCTwirl_class->convert = JS_ConvertStub;
	JSB_CCTwirl_class->finalize = JSB_CCTwirl_finalize;
	JSB_CCTwirl_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSB_CCTwirl_amplitude, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSB_CCTwirl_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSizePositionTwirlsAmplitude", JSB_CCTwirl_initWithDuration_size_position_twirls_amplitude_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSB_CCTwirl_position, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSB_CCTwirl_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSB_CCTwirl_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSB_CCTwirl_setPosition_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTwirl_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTwirl_actionWithDuration_size_position_twirls_amplitude__static, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTwirl_object = JS_InitClass(cx, globalObj, JSB_CCGrid3DAction_object, JSB_CCTwirl_class, JSB_CCTwirl_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTwirl

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTwirl_class, JSB_CCTwirl_object, NULL);
	JSB_CCTwirl *proxy = [[JSB_CCTwirl alloc] initWithJSObject:jsobj class:[CCTwirl class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTexturePVR
 */
#pragma mark - CCTexturePVR

JSClass* JSB_CCTexturePVR_class = NULL;
JSObject* JSB_CCTexturePVR_object = NULL;
// Constructor
JSBool JSB_CCTexturePVR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTexturePVR createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTexturePVR_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTexturePVR)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTexturePVR_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTexturePVR *proxy = [[JSB_CCTexturePVR alloc] initWithJSObject:obj class:[CCTexturePVR class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTexturePVR_forcePremultipliedAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real forcePremultipliedAlpha ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSB_CCTexturePVR_format(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real format ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTexturePVR_hasAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real hasAlpha ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTexturePVR_hasPremultipliedAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real hasPremultipliedAlpha ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: uint32_t (u)
JSBool JSB_CCTexturePVR_height(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	uint32_t ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real height ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSB_CCTexturePVR_initWithContentsOfFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexturePVR *real = [(CCTexturePVR*)[proxy.klass alloc] initWithContentsOfFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint (u)
JSBool JSB_CCTexturePVR_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLuint ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real name ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSB_CCTexturePVR_numberOfMipmaps(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real numberOfMipmaps ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexturePVR* (o)
JSBool JSB_CCTexturePVR_pvrTextureWithContentsOfFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTexturePVR* ret_val;

	ret_val = [CCTexturePVR pvrTextureWithContentsOfFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCTexturePVR_retainName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real retainName ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSB_CCTexturePVR_setRetainName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	[real setRetainName:(BOOL)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: uint32_t (u)
JSBool JSB_CCTexturePVR_width(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	uint32_t ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real width ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

void JSB_CCTexturePVR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTexturePVR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTexturePVR_class->name = name;
	JSB_CCTexturePVR_class->addProperty = JS_PropertyStub;
	JSB_CCTexturePVR_class->delProperty = JS_PropertyStub;
	JSB_CCTexturePVR_class->getProperty = JS_PropertyStub;
	JSB_CCTexturePVR_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTexturePVR_class->enumerate = JS_EnumerateStub;
	JSB_CCTexturePVR_class->resolve = JS_ResolveStub;
	JSB_CCTexturePVR_class->convert = JS_ConvertStub;
	JSB_CCTexturePVR_class->finalize = JSB_CCTexturePVR_finalize;
	JSB_CCTexturePVR_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getForcePremultipliedAlpha", JSB_CCTexturePVR_forcePremultipliedAlpha, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFormat", JSB_CCTexturePVR_format, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getHasAlpha", JSB_CCTexturePVR_hasAlpha, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getHasPremultipliedAlpha", JSB_CCTexturePVR_hasPremultipliedAlpha, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getHeight", JSB_CCTexturePVR_height, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithContentsOfFile", JSB_CCTexturePVR_initWithContentsOfFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getName", JSB_CCTexturePVR_name, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getNumberOfMipmaps", JSB_CCTexturePVR_numberOfMipmaps, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getRetainName", JSB_CCTexturePVR_retainName, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setRetainName", JSB_CCTexturePVR_setRetainName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getWidth", JSB_CCTexturePVR_width, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTexturePVR_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("pvrTextureWithContentsOfFile", JSB_CCTexturePVR_pvrTextureWithContentsOfFile__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTexturePVR_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCTexturePVR_class, JSB_CCTexturePVR_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTexturePVR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTexturePVR_class, JSB_CCTexturePVR_object, NULL);
	JSB_CCTexturePVR *proxy = [[JSB_CCTexturePVR alloc] initWithJSObject:jsobj class:[CCTexturePVR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGLProgram
 */
#pragma mark - CCGLProgram

JSClass* JSB_CCGLProgram_class = NULL;
JSObject* JSB_CCGLProgram_object = NULL;
// Constructor
JSBool JSB_CCGLProgram_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGLProgram createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGLProgram_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGLProgram)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGLProgram_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGLProgram *proxy = [[JSB_CCGLProgram alloc] initWithJSObject:obj class:[CCGLProgram class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: NSString*, GLuint
// Ret value: void (None)
JSBool JSB_CCGLProgram_addAttribute_index_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real addAttribute:(NSString*)arg0 index:(GLuint)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCGLProgram_fragmentShaderLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real fragmentShaderLog ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: char*, char*
// Ret value: None (None)
JSBool JSB_CCGLProgram_initWithVertexShaderByteArray_fragmentShaderByteArray_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	const char* arg0; const char* arg1; 

	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGLProgram *real = [(CCGLProgram*)[proxy.klass alloc] initWithVertexShaderByteArray:(char*)arg0 fragmentShaderByteArray:(char*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSB_CCGLProgram_initWithVertexShaderFilename_fragmentShaderFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && ![proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGLProgram *real = [(CCGLProgram*)[proxy.klass alloc] initWithVertexShaderFilename:(NSString*)arg0 fragmentShaderFilename:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSB_CCGLProgram_link(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	BOOL ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real link ];

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint (u)
JSBool JSB_CCGLProgram_program(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLuint ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real program ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCGLProgram_programLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real programLog ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

// Arguments: char*, char*
// Ret value: CCGLProgram* (o)
JSBool JSB_CCGLProgram_programWithVertexShaderByteArray_fragmentShaderByteArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	const char* arg0; const char* arg1; 

	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_charptr( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGLProgram* ret_val;

	ret_val = [CCGLProgram programWithVertexShaderByteArray:(char*)arg0 fragmentShaderByteArray:(char*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCGLProgram* (o)
JSBool JSB_CCGLProgram_programWithVertexShaderFilename_fragmentShaderFilename__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGLProgram* ret_val;

	ret_val = [CCGLProgram programWithVertexShaderFilename:(NSString*)arg0 fragmentShaderFilename:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void (None)
JSBool JSB_CCGLProgram_setUniformLocation_withF1_f2_f3_f4_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 2 && argc <= 5 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; double arg2; double arg3; double arg4; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	}
	if (argc >= 5) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 2 ) {
		CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1  ];
	}
	else if( argc == 3 ) {
		CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2  ];
	}
	else if( argc == 4 ) {
		CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2 f3:(GLfloat)arg3  ];
	}
	else if( argc == 5 ) {
		CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2 f3:(GLfloat)arg3 f4:(GLfloat)arg4  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: GLint, GLint
// Ret value: void (None)
JSBool JSB_CCGLProgram_setUniformLocation_withI1_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withI1:(GLint)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGLProgram_setUniformsForBuiltins(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformsForBuiltins ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: GLint (i)
JSBool JSB_CCGLProgram_uniformLocationForName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLint ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real uniformLocationForName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGLProgram_updateUniforms(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real updateUniforms ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCGLProgram_use(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real use ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSB_CCGLProgram_vertexShaderLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real vertexShaderLog ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSString( cx, (NSString*) ret_val ));

	return JS_TRUE;
}

void JSB_CCGLProgram_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGLProgram_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGLProgram_class->name = name;
	JSB_CCGLProgram_class->addProperty = JS_PropertyStub;
	JSB_CCGLProgram_class->delProperty = JS_PropertyStub;
	JSB_CCGLProgram_class->getProperty = JS_PropertyStub;
	JSB_CCGLProgram_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGLProgram_class->enumerate = JS_EnumerateStub;
	JSB_CCGLProgram_class->resolve = JS_ResolveStub;
	JSB_CCGLProgram_class->convert = JS_ConvertStub;
	JSB_CCGLProgram_class->finalize = JSB_CCGLProgram_finalize;
	JSB_CCGLProgram_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAttribute", JSB_CCGLProgram_addAttribute_index_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getFragmentShaderLog", JSB_CCGLProgram_fragmentShaderLog, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("initWithString", JSB_CCGLProgram_initWithVertexShaderByteArray_fragmentShaderByteArray_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("init", JSB_CCGLProgram_initWithVertexShaderFilename_fragmentShaderFilename_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("link", JSB_CCGLProgram_link, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProgram", JSB_CCGLProgram_program, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getProgramLog", JSB_CCGLProgram_programLog, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationF32", JSB_CCGLProgram_setUniformLocation_withF1_f2_f3_f4_, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationI32", JSB_CCGLProgram_setUniformLocation_withI1_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setUniformsForBuiltins", JSB_CCGLProgram_setUniformsForBuiltins, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getUniformLocation", JSB_CCGLProgram_uniformLocationForName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("updateUniforms", JSB_CCGLProgram_updateUniforms, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("use", JSB_CCGLProgram_use, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getVertexShaderLog", JSB_CCGLProgram_vertexShaderLog, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGLProgram_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("createWithString", JSB_CCGLProgram_programWithVertexShaderByteArray_fragmentShaderByteArray__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("create", JSB_CCGLProgram_programWithVertexShaderFilename_fragmentShaderFilename__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCGLProgram_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCGLProgram_class, JSB_CCGLProgram_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGLProgram

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGLProgram_class, JSB_CCGLProgram_object, NULL);
	JSB_CCGLProgram *proxy = [[JSB_CCGLProgram alloc] initWithJSObject:jsobj class:[CCGLProgram class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrid3D
 */
#pragma mark - CCGrid3D

JSClass* JSB_CCGrid3D_class = NULL;
JSObject* JSB_CCGrid3D_object = NULL;
// Constructor
JSBool JSB_CCGrid3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCGrid3D createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCGrid3D_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCGrid3D)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCGrid3D_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCGrid3D *proxy = [[JSB_CCGrid3D alloc] initWithJSObject:obj class:[CCGrid3D class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSB_CCGrid3D_originalVertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccVertex3F ret_val;

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	ret_val = [real originalVertex:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 3, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: CGPoint, ccVertex3F
// Ret value: void (None)
JSBool JSB_CCGrid3D_setVertex_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; ccVertex3F arg1; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JSB_jsval_to_struct( cx, *argvp++, &arg1, sizeof(ccVertex3F) );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	[real setVertex:(CGPoint)arg0 vertex:(ccVertex3F)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSB_CCGrid3D_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= JSB_jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	ccVertex3F ret_val;

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	ret_val = [real vertex:(CGPoint)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_struct( cx, 3, &ret_val, js::ArrayBufferView::TYPE_FLOAT32 ));

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: CCGrid3D* (o)
JSBool JSB_CCGrid3D_gridWithSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGrid3D* ret_val;

	ret_val = [CCGrid3D gridWithSize:(CGSize)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: CGSize, CCTexture2D*, BOOL
// Ret value: CCGrid3D* (o)
JSBool JSB_CCGrid3D_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; id arg1; JSBool arg2; 

	ok &= JSB_jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCGrid3D* ret_val;

	ret_val = [CCGrid3D gridWithSize:(CGSize)arg0 texture:arg1 flippedTexture:(BOOL)arg2  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCGrid3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCGrid3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCGrid3D_class->name = name;
	JSB_CCGrid3D_class->addProperty = JS_PropertyStub;
	JSB_CCGrid3D_class->delProperty = JS_PropertyStub;
	JSB_CCGrid3D_class->getProperty = JS_PropertyStub;
	JSB_CCGrid3D_class->setProperty = JS_StrictPropertyStub;
	JSB_CCGrid3D_class->enumerate = JS_EnumerateStub;
	JSB_CCGrid3D_class->resolve = JS_ResolveStub;
	JSB_CCGrid3D_class->convert = JS_ConvertStub;
	JSB_CCGrid3D_class->finalize = JSB_CCGrid3D_finalize;
	JSB_CCGrid3D_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("originalVertex", JSB_CCGrid3D_originalVertex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("setVertexVertex", JSB_CCGrid3D_setVertex_vertex_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("vertex", JSB_CCGrid3D_vertex_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCGrid3D_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("gridWithSize", JSB_CCGrid3D_gridWithSize__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("gridWithSizeTextureFlippedTexture", JSB_CCGrid3D_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCGrid3D_object = JS_InitClass(cx, globalObj, JSB_CCGridBase_object, JSB_CCGrid3D_class, JSB_CCGrid3D_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCGrid3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCGrid3D_class, JSB_CCGrid3D_object, NULL);
	JSB_CCGrid3D *proxy = [[JSB_CCGrid3D alloc] initWithJSObject:jsobj class:[CCGrid3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionManager
 */
#pragma mark - CCActionManager

JSClass* JSB_CCActionManager_class = NULL;
JSObject* JSB_CCActionManager_object = NULL;
// Constructor
JSBool JSB_CCActionManager_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCActionManager createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCActionManager_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCActionManager)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCActionManager_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCActionManager *proxy = [[JSB_CCActionManager alloc] initWithJSObject:obj class:[CCActionManager class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCAction*, NSObject*, BOOL
// Ret value: void (None)
JSBool JSB_CCActionManager_addAction_target_paused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; JSBool arg2; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real addAction:arg0 target:arg1 paused:(BOOL)arg2  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger, NSObject*
// Ret value: CCAction* (o)
JSBool JSB_CCActionManager_getActionByTag_target_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; id arg1; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCAction* ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real getActionByTag:(NSInteger)arg0 target:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: NSUInteger (u)
JSBool JSB_CCActionManager_numberOfRunningActionsInTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	NSUInteger ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real numberOfRunningActionsInTarget:arg0  ];

	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSSet* (set)
JSBool JSB_CCActionManager_pauseAllRunningActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	NSSet* ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real pauseAllRunningActions ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSSet( cx, (NSSet*) ret_val ));

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCActionManager_pauseTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real pauseTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: void (None)
JSBool JSB_CCActionManager_removeAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSInteger, NSObject*
// Ret value: void (None)
JSBool JSB_CCActionManager_removeActionByTag_target_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; id arg1; 

	ok &= JSB_jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeActionByTag:(NSInteger)arg0 target:arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCActionManager_removeAllActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAllActions ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCActionManager_removeAllActionsFromTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAllActionsFromTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSB_CCActionManager_resumeTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real resumeTarget:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSSet*
// Ret value: void (None)
JSBool JSB_CCActionManager_resumeTargets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSSet* arg0; 

	ok &= JSB_jsval_to_NSSet( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real resumeTargets:(NSSet*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

void JSB_CCActionManager_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCActionManager_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCActionManager_class->name = name;
	JSB_CCActionManager_class->addProperty = JS_PropertyStub;
	JSB_CCActionManager_class->delProperty = JS_PropertyStub;
	JSB_CCActionManager_class->getProperty = JS_PropertyStub;
	JSB_CCActionManager_class->setProperty = JS_StrictPropertyStub;
	JSB_CCActionManager_class->enumerate = JS_EnumerateStub;
	JSB_CCActionManager_class->resolve = JS_ResolveStub;
	JSB_CCActionManager_class->convert = JS_ConvertStub;
	JSB_CCActionManager_class->finalize = JSB_CCActionManager_finalize;
	JSB_CCActionManager_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAction", JSB_CCActionManager_addAction_target_paused_, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getActionByTag", JSB_CCActionManager_getActionByTag_target_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("numberOfRunningActionsInTarget", JSB_CCActionManager_numberOfRunningActionsInTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseAllRunningActions", JSB_CCActionManager_pauseAllRunningActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("pauseTarget", JSB_CCActionManager_pauseTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAction", JSB_CCActionManager_removeAction_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeActionByTag", JSB_CCActionManager_removeActionByTag_target_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAllActions", JSB_CCActionManager_removeAllActions, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeAllActionsFromTarget", JSB_CCActionManager_removeAllActionsFromTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resumeTarget", JSB_CCActionManager_resumeTarget_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("resumeTargets", JSB_CCActionManager_resumeTargets_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCActionManager_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_CCActionManager_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCActionManager_class, JSB_CCActionManager_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCActionManager

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCActionManager_class, JSB_CCActionManager_object, NULL);
	JSB_CCActionManager *proxy = [[JSB_CCActionManager alloc] initWithJSObject:jsobj class:[CCActionManager class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteFrameCache
 */
#pragma mark - CCSpriteFrameCache

JSClass* JSB_CCSpriteFrameCache_class = NULL;
JSObject* JSB_CCSpriteFrameCache_object = NULL;
// Constructor
JSBool JSB_CCSpriteFrameCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCSpriteFrameCache createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCSpriteFrameCache_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCSpriteFrameCache)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCSpriteFrameCache_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCSpriteFrameCache *proxy = [[JSB_CCSpriteFrameCache alloc] initWithJSObject:obj class:[CCSpriteFrameCache class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*, NSString*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_addSpriteFrame_name_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFrame:arg0 name:(NSString*)arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_addSpriteFramesWithFile_texture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; id arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0 texture:arg1  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_addSpriteFramesWithFile_textureFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc >= 1 && argc <= 2 , cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg1 );
	}
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	if( argc == 1 ) {
		CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0 textureFilename:(NSString*)arg1  ];
	}
	else
		JSB_PRECONDITION2(NO, cx, JS_FALSE, "Error in number of arguments");


	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_purgeSharedSpriteFrameCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	[CCSpriteFrameCache purgeSharedSpriteFrameCache ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_removeSpriteFrameByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFrameByName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_removeSpriteFrames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFrames ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_removeSpriteFramesFromFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFramesFromFile:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_removeSpriteFramesFromTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFramesFromTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSB_CCSpriteFrameCache_removeUnusedSpriteFrames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeUnusedSpriteFrames ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrameCache* (o)
JSBool JSB_CCSpriteFrameCache_sharedSpriteFrameCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCSpriteFrameCache* ret_val;

	ret_val = [CCSpriteFrameCache sharedSpriteFrameCache ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCSpriteFrame* (o)
JSBool JSB_CCSpriteFrameCache_spriteFrameByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= JSB_jsval_to_NSString( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCSpriteFrame* ret_val;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	ret_val = [real spriteFrameByName:(NSString*)arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCSpriteFrameCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCSpriteFrameCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCSpriteFrameCache_class->name = name;
	JSB_CCSpriteFrameCache_class->addProperty = JS_PropertyStub;
	JSB_CCSpriteFrameCache_class->delProperty = JS_PropertyStub;
	JSB_CCSpriteFrameCache_class->getProperty = JS_PropertyStub;
	JSB_CCSpriteFrameCache_class->setProperty = JS_StrictPropertyStub;
	JSB_CCSpriteFrameCache_class->enumerate = JS_EnumerateStub;
	JSB_CCSpriteFrameCache_class->resolve = JS_ResolveStub;
	JSB_CCSpriteFrameCache_class->convert = JS_ConvertStub;
	JSB_CCSpriteFrameCache_class->finalize = JSB_CCSpriteFrameCache_finalize;
	JSB_CCSpriteFrameCache_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addSpriteFrameName", JSB_CCSpriteFrameCache_addSpriteFrame_name_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addSpriteFramesWithFileTexture", JSB_CCSpriteFrameCache_addSpriteFramesWithFile_texture_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrames", JSB_CCSpriteFrameCache_addSpriteFramesWithFile_textureFilename_, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFrameByName", JSB_CCSpriteFrameCache_removeSpriteFrameByName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFrames", JSB_CCSpriteFrameCache_removeSpriteFrames, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFramesFromFile", JSB_CCSpriteFrameCache_removeSpriteFramesFromFile_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFramesFromTexture", JSB_CCSpriteFrameCache_removeSpriteFramesFromTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("removeUnusedSpriteFrames", JSB_CCSpriteFrameCache_removeUnusedSpriteFrames, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getSpriteFrame", JSB_CCSpriteFrameCache_spriteFrameByName_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCSpriteFrameCache_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedSpriteFrameCache", JSB_CCSpriteFrameCache_purgeSharedSpriteFrameCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSB_CCSpriteFrameCache_sharedSpriteFrameCache_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCSpriteFrameCache_object = JS_InitClass(cx, globalObj, JSB_NSObject_object, JSB_CCSpriteFrameCache_class, JSB_CCSpriteFrameCache_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCSpriteFrameCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCSpriteFrameCache_class, JSB_CCSpriteFrameCache_object, NULL);
	JSB_CCSpriteFrameCache *proxy = [[JSB_CCSpriteFrameCache alloc] initWithJSObject:jsobj class:[CCSpriteFrameCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineOut
 */
#pragma mark - CCEaseSineOut

JSClass* JSB_CCEaseSineOut_class = NULL;
JSObject* JSB_CCEaseSineOut_object = NULL;
// Constructor
JSBool JSB_CCEaseSineOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCEaseSineOut createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCEaseSineOut_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCEaseSineOut)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCEaseSineOut_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCEaseSineOut *proxy = [[JSB_CCEaseSineOut alloc] initWithJSObject:obj class:[CCEaseSineOut class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSB_CCEaseSineOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	CCEaseSineOut *real = (CCEaseSineOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];

	JS_SET_RVAL(cx, vp, JSVAL_VOID);

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineOut* (o)
JSBool JSB_CCEaseSineOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCEaseSineOut* ret_val;

	ret_val = [CCEaseSineOut actionWithAction:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCEaseSineOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCEaseSineOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCEaseSineOut_class->name = name;
	JSB_CCEaseSineOut_class->addProperty = JS_PropertyStub;
	JSB_CCEaseSineOut_class->delProperty = JS_PropertyStub;
	JSB_CCEaseSineOut_class->getProperty = JS_PropertyStub;
	JSB_CCEaseSineOut_class->setProperty = JS_StrictPropertyStub;
	JSB_CCEaseSineOut_class->enumerate = JS_EnumerateStub;
	JSB_CCEaseSineOut_class->resolve = JS_ResolveStub;
	JSB_CCEaseSineOut_class->convert = JS_ConvertStub;
	JSB_CCEaseSineOut_class->finalize = JSB_CCEaseSineOut_finalize;
	JSB_CCEaseSineOut_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSB_CCEaseSineOut_update_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCEaseSineOut_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCEaseSineOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCEaseSineOut_object = JS_InitClass(cx, globalObj, JSB_CCActionEase_object, JSB_CCEaseSineOut_class, JSB_CCEaseSineOut_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCEaseSineOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCEaseSineOut_class, JSB_CCEaseSineOut_object, NULL);
	JSB_CCEaseSineOut *proxy = [[JSB_CCEaseSineOut alloc] initWithJSObject:jsobj class:[CCEaseSineOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressOutIn
 */
#pragma mark - CCTransitionProgressOutIn

JSClass* JSB_CCTransitionProgressOutIn_class = NULL;
JSObject* JSB_CCTransitionProgressOutIn_object = NULL;
// Constructor
JSBool JSB_CCTransitionProgressOutIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = [JSB_CCTransitionProgressOutIn createJSObjectWithRealObject:nil context:cx];
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));
	return JS_TRUE;
}

// Destructor
void JSB_CCTransitionProgressOutIn_finalize(JSFreeOp *fop, JSObject *obj)
{
	CCLOGINFO(@"jsbindings: finalizing JS object %p (CCTransitionProgressOutIn)", obj);
//	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(obj);
//	if (proxy) {
//		[[proxy realObj] release];
//	}
	JSB_del_proxy_for_jsobject( obj );
}

// 'ctor' method. Needed for subclassing native objects in JS
JSBool JSB_CCTransitionProgressOutIn_ctor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_PRECONDITION2( !JSB_get_proxy_for_jsobject(obj), cx, JS_FALSE, "Object already initialzied. error" );

	JSB_CCTransitionProgressOutIn *proxy = [[JSB_CCTransitionProgressOutIn alloc] initWithJSObject:obj class:[CCTransitionProgressOutIn class]];
	[[proxy class] swizzleMethods];

	JS_SET_RVAL(cx, vp, JSVAL_TRUE);

	return JS_TRUE;
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSB_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSB_NSObject *proxy = (JSB_NSObject*) JSB_get_proxy_for_jsobject(jsthis);

	JSB_PRECONDITION2( proxy && [proxy realObj], cx, JS_FALSE, "Invalid Proxy object");
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCProgressTimer* ret_val;

	CCTransitionProgressOutIn *real = (CCTransitionProgressOutIn*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:arg0  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressOutIn* (o)
JSBool JSB_CCTransitionProgressOutIn_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JSB_jsval_to_NSObject( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	CCTransitionProgressOutIn* ret_val;

	ret_val = [CCTransitionProgressOutIn transitionWithDuration:(ccTime)arg0 scene:arg1  ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressOutIn* (o)
JSBool JSB_CCTransitionProgressOutIn_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	CCTransitionProgressOutIn* ret_val;

	ret_val = [CCTransitionProgressOutIn node ];

	JS_SET_RVAL(cx, vp, JSB_jsval_from_NSObject(cx, ret_val));

	return JS_TRUE;
}

void JSB_CCTransitionProgressOutIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_CCTransitionProgressOutIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_CCTransitionProgressOutIn_class->name = name;
	JSB_CCTransitionProgressOutIn_class->addProperty = JS_PropertyStub;
	JSB_CCTransitionProgressOutIn_class->delProperty = JS_PropertyStub;
	JSB_CCTransitionProgressOutIn_class->getProperty = JS_PropertyStub;
	JSB_CCTransitionProgressOutIn_class->setProperty = JS_StrictPropertyStub;
	JSB_CCTransitionProgressOutIn_class->enumerate = JS_EnumerateStub;
	JSB_CCTransitionProgressOutIn_class->resolve = JS_ResolveStub;
	JSB_CCTransitionProgressOutIn_class->convert = JS_ConvertStub;
	JSB_CCTransitionProgressOutIn_class->finalize = JSB_CCTransitionProgressOutIn_finalize;
	JSB_CCTransitionProgressOutIn_class->flags = 0;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSB_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("ctor", JSB_CCTransitionProgressOutIn_ctor, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSB_CCTransitionProgressOutIn_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FN("node", JSB_CCTransitionProgressOutIn_node_static, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSB_CCTransitionProgressOutIn_object = JS_InitClass(cx, globalObj, JSB_CCTransitionProgress_object, JSB_CCTransitionProgressOutIn_class, JSB_CCTransitionProgressOutIn_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

@implementation JSB_CCTransitionProgressOutIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSB_CCTransitionProgressOutIn_class, JSB_CCTransitionProgressOutIn_object, NULL);
	JSB_CCTransitionProgressOutIn *proxy = [[JSB_CCTransitionProgressOutIn alloc] initWithJSObject:jsobj class:[CCTransitionProgressOutIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSB_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end


#endif // JSB_INCLUDE_COCOS2D
